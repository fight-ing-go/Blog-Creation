<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="fighting"><meta name="author" content="EasyBoy"><title>Linux多进程的一些知识点 | EasyBoy</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/cell-16x16-next.png"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"easyboy-blog.com",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!1,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpeg",favicon:"/images/cell-16x16-next.png",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!1,scale:!1},first_screen:{enable:!0,background_img:"https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/wallpaper_img/wallhaven-8omxly_3840x2160.2jbfmfsgxcy0.jpg",description:"Welcome to Easyboy's Blog"},scroll:{progress_bar:{enable:!1},percent:{enable:!1}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="home-laser" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/cell-32x32-next.png"> </a><a class="logo-title" href="/">EasyBoy</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">Linux多进程的一些知识点</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpeg"></div><div class="info"><div class="author"><span class="name">EasyBoy</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2022-07-04 22:08:19</span> <span class="mobile">2022-07-04 22:08</span><span class="pc">更新于：2022-07-04</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/">多进程</a>&nbsp;</li><li>| <a href="/tags/Linux/">Linux</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.7k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><ol><li>同一主机：<br>$$<br>同一主机进程间通信=\left{<br>\begin{matrix}<br>Unix进程间通信方式 \<br>System V进程间通信方式 \<br>POSIX进程间通信方式<br>\end{matrix}<br>\right.<br>$$<br>$$<br>Unix进程间通信方式=\left{<br>\begin{matrix}<br>匿名管道 \<br>有名管道 \<br>信号<br>\end{matrix}<br>\right.<br>$$<br>$$<br>System V进程间通信 、<br>POSIX进程间通信 =\left{<br>\begin{matrix}<br>消息队列 \<br>共享内存 \<br>信号量<br>\end{matrix}<br>\right.<br>$$</li><li>不同主机（网络）进程间通信：Socket<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1></li><li>管道是在内核内存中维护的缓冲器，不同操作系统大小不一定相同。</li><li>管道拥有文件的特质：读和写。匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</li><li>一个管道是一个字节流，可以从中读取任意大小的数据块。</li><li>管道传递的数据是顺序的，读出来的顺序和写入时一致。</li><li>管道的数据传递是单向的，一端写入，一端用于读取，属于半双工。</li><li>管道内数据是一次性操作，一旦被读走，就会被删掉来释放空间。</li><li>匿名管道只能在具有公共祖先的进程中使用。（因为拥有相同的文件描述符，指向的管道一致）。</li><li>管道的数据结构是环形的。</li></ol><p>（堵塞）管道<strong>读写</strong>特点：</p><ol><li>如果管道写端的文件描述符都关闭了，且管道内无数据后，再次read将会<strong>返回0</strong>，而不是堵塞。</li><li>如果管道读端的文件描述符都关闭了，这时候向管道写数据，该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。</li><li>如果管道读端的文件描述符没有关闭，且没有从管道读数据，那么在管道写满后再次write会<strong>堵塞</strong>，直到有空位置才能再次写入数据并返回。</li><li>进程启动，若只先开启读端，将会堵塞，直到读端开启。同理，若只开启写段，也会堵塞到读端开启。</li></ol><p><strong>匿名管道（pipe）</strong>：通过一个没有实体的管道，实现具有亲缘关系的进程间通信。</p><p><strong>有名管道（FIFO）</strong>：克服了匿名管道只能用于亲缘关系的进程通信。<br>有名管道提供了一个路径名与之关联，以FIFO文件形式存在于文件系统中，进程间可以访问该路径而彼此通信。</p><p>匿名有名的不同点：</p><ol><li>FIFO在文件系统中作为一个特殊文件存在，但其内容存放于内存中。</li><li>FIFO文件在进程退出后继续保存在文件系统中。</li><li>FIFO有名字，因而不相关的进程可以访问该文件进行通信。</li></ol><h1 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h1><p>kill -l: 查看系统定义的信号列表<br>信号编号-信号名-默认动作-对应事件<br>2:SIGINT：终止进程。&lt;Ctrl+C&gt;，用户终端向正在运行中的由该终端启动的程序发出此信号。<br>3.SIGQUIT：终止进程。&lt;Ctrl+\&gt;,同信号2。<br>9.SIGKILL：终止进程（可以杀死任何进程）。无条件终止进程，该信号不能被忽略，处理和阻塞。<br>11.SIGSEGV：终止进程并产生core文件。指示进程进行了无效内存访问。<br>13.SIGPIPE：终止进程。pipe向一个没有读端的管道写数据。<br>17.SIGCHIL：忽略这个信号。子进程结束时，父进程收到该信号。<br>18.SIGCONT：继续/忽略。如果进程已停止，则使其继续运行。<br>19.SIGSTOP：终止进程。停止进程的执行。该信号不能被忽略，处理和阻塞。<br>SIGKILL和SIGSTOP只能执行默认动作。</p><p>查看信号详细信息：man 7 signal<br>信号的五种默认处理动作：</p><ol><li>Term：终止进程</li><li>Ign：当前进程忽略掉这个信号</li><li>Core：终止进程并生成core文件</li><li>Stop：暂停当前进程</li><li>Cont：继续执行当前被暂停的进程<br>信号的状态：产生、未决（没有被处理的状态）、递达（信号被处理了）</li></ol><p>SIGCHLD信号产生条件：<br>* 子进程终止时<br>* 子进程接收到SIGSTOP信号停止时<br>* 子进程处在停止态，接收到SIGCONT唤醒时<br>产生的SIGCHLD信号会发送给父进程，父进程默认忽略该信号。</p><h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>两个主要信号集：<br>阻塞信号集：阻止信号响应，并不阻止产生。<br>未决信号集：还未产生响应的信号。</p><ol><li>在内核中，所有没被处理的信号存储在一个集合中，信号状态存储在第二个标志位上。标志位为0，信号不是处于未决状态；标志位为1，信号处于未决状态。</li><li>处理未决信号前，需要和阻塞信号机比较。阻塞信号集默认不阻塞任何信号，如果要阻塞，需要调用系统API。</li><li>在处理未决信号前对阻塞信号集的标志位进行查询。若没有设置阻塞，则正常处理信号；若阻塞了，信号就继续处于未决状态，直至阻塞解除。</li></ol><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对<strong>其他所有</strong>共享同一个段的进程可用。<br>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。<br>共享内存和内存映射的区别：</p><ol><li><p>共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)</p></li><li><p>共享内存效果更高</p></li><li><p>内存</p><p>所有的进程操作的是同一块共享内存。<br>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</p></li><li><p>数据安全</p><ul><li>进程突然退出<br>共享内存还存在内存映射区消失</li><li>运行进程的电脑死机，宕机了<br>数据存在在共享内存中，没有了<br>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</li></ul></li><li><p>生命周期</p><ul><li>内存映射区: 进程退出，内存映射区销毁</li><li>共享内存: 进程退出，共享内存还在，标记删除，或者关机</li></ul></li></ol><h1 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程组是一组相关进程的集合。</li><li>进程组由一个或多个共享同一进程组标识符(PGID)的进程组成。</li><li>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID，新进程</li><li>会继承其父进程所属的进程组ID。</li><li>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。</li><li>进程组首进程无需是最后一个离开进程组的成员。<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2></li><li>会话是一组进程组的集合。</li><li>会话首进程是创建该新会话的进程，其进程ID 会成为会话 ID。新进程会继承其父进程的会话ID。</li><li>一个会话中的所有进程共享<strong>单个</strong>控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li><li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li><li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li></ul><p>#守护进程（Daemon 进程）<br>也称精灵进程，是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端且周期性执行某种任务或等待处理某些事件，名字一般以d结尾，如Internet服务器inetd,Web服务器httpd。</p><ul><li>生命周期长，在系统启动的时候就被创建并一直运行至系统关闭。</li><li>后台运行且没有控制终端，确保内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号。<h2 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h2></li></ul><ul><li>执行一个 fork()，之 后父进程退出，子进程继续执行。（*必要）<br>（父进程退出能够不让终端在父进程结束后显示shell提示符；使用fork确保创建的子进程不会成为进程组的首进程）</li><li>子进程调用setsid()开启一个新会话。（*必要）<br>（首先，进程创建新的会话时，会该进程会成为新会话新进程组的首进程，如果用父进程创建，回合原来的进程组会话冲突，因此要用子进程创建。其次，创建新的会话，如果不建立连接的话，会话是没有控制终端的，也就符合的守护进程的要求。）</li><li>清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限。(函数umask(xxx);)</li><li>修改进程的当前工作目录，通常会改为根目录(/)。<br>（主要因为守护进程是要存活到系统结束，如果在其他目录，该目录就无法卸载，如u盘目录。函数chdir();）</li><li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>（原因同上，防止无法卸载某些关联磁盘）</li><li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null并使用dup2()使所有这些描述符指向这个设备。<br>（防止系统调用这些关闭了的文件描述符后出错，重定向到null目录，null目录内的内容会自动被丢弃）</li><li>核心业务逻辑（*必要）</li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：Linux多进程的一些知识点</li><li>本文作者：EasyBoy</li><li>创建时间：2022-07-04 22:08:19</li><li>本文链接：https://easyboy-blog.com/linux-multiprocess.html</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/">#多进程</a>&nbsp;</li><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li></ul><div class="article-nav"><div class="article-next"><a class="next" rel="next" href="/correlation-analysis.html"><span class="title flex-center"><span class="post-nav-title-item">论文复现：基于相关性分析的工业时序数据异常检测</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div class="valine-container"><script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><div id="vcomments"></div><script data-pjax>function loadValine(){function e(e){switch(e){case"en":return"Author";case"zh-CN":return"博主";default:return"Master"}}new Valine({el:"#vcomments",appId:"TSl5PlExO22wiwkA3e15kGvM-gzGzoHsz",appKey:"36AERjunsq15rL0xcz3ovKbG",meta:["nick","mail","link"],avatar:"wavatar",enableQQ:!0,placeholder:"😜 尽情吐槽吧~",lang:"zh-CN".toLowerCase()});const a=setInterval(()=>{const n=document.querySelectorAll("#vcomments .vcards .vcard");if(n.length>0){let t="EasyBoy";if(t)for(let a of n){const n=a.querySelector(".vhead .vnick"),l=n.innerHTML;l===t&&(n.innerHTML=`${l} <span class="author">${e(KEEP.hexo_config.language)}</span>`)}clearInterval(a)}else clearInterval(a)},2e3)}{const e=setTimeout(()=>{loadValine(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">EasyBoy</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">进程间通信方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-text">管道</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E4%BF%A1%E5%8F%B7"><span class="nav-text">Linux信号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">信号集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%BC%9A%E8%AF%9D"><span class="nav-text">进程组与会话</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-text">会话</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-text">守护进程创建步骤</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>