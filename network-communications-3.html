<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/cell-32x32-next.png"><link rel="icon" href="/img/cell-32x32-next.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="laser"><meta name="keywords" content=""><meta name="description" content="TCP通信流程UPD和TCP之间的差异：     UDP TCP    是否创建连接 无连接 面向连接   是否可靠 不可靠 可靠的   连接的对象个数 一对一、一对多、多对一、多对多 支持一对一   传输的方式 面向数据报 面向字节流   首部开销 8个字节 最少20个字节   适用场景 实时应用（视频会议，直播) 可靠性高的应用(文件传输)   TCP的通信流程图：   服务器端通信流程1．创"><meta property="og:type" content="article"><meta property="og:title" content="Linux网络通信基础（3）"><meta property="og:url" content="https://easyboy-blog.com/network-communications-3.html"><meta property="og:site_name" content="home-laser"><meta property="og:description" content="TCP通信流程UPD和TCP之间的差异：     UDP TCP    是否创建连接 无连接 面向连接   是否可靠 不可靠 可靠的   连接的对象个数 一对一、一对多、多对一、多对多 支持一对一   传输的方式 面向数据报 面向字节流   首部开销 8个字节 最少20个字节   适用场景 实时应用（视频会议，直播) 可靠性高的应用(文件传输)   TCP的通信流程图：   服务器端通信流程1．创"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.3qrqc9556i00.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.54mqaowxcu40.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.6mzi7aovung0.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.5ks8mv38ykk.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.6r3zm71zzug0.jpg"><meta property="article:published_time" content="2022-08-01T13:09:20.775Z"><meta property="article:modified_time" content="2022-08-01T13:26:27.825Z"><meta property="article:author" content="laser"><meta property="article:tag" content="网络通信"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.3qrqc9556i00.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Linux网络通信基础（3） - home-laser</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"easyboy-blog.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"C"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="home-laser" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>EASY</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/wallpaper_img/wallhaven-9my82x_1920x1091.5ivtqxlw8ho0.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Linux网络通信基础（3）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-01 21:09" pubdate>2022年8月1日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 55 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Linux网络通信基础（3）</h1><div class="markdown-body"><h1 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h1><p>UPD和TCP之间的差异：</p><table><thead><tr><th align="center"></th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否创建连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠</td><td align="center">可靠的</td></tr><tr><td align="center">连接的对象个数</td><td align="center">一对一、一对多、多对一、多对多</td><td align="center">支持一对一</td></tr><tr><td align="center">传输的方式</td><td align="center">面向数据报</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">8个字节</td><td align="center">最少20个字节</td></tr><tr><td align="center">适用场景</td><td align="center">实时应用（视频会议，直播)</td><td align="center">可靠性高的应用(文件传输)</td></tr></tbody></table><p>TCP的通信流程图：</p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.3qrqc9556i00.jpg" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%"><h2 id="服务器端通信流程"><a href="#服务器端通信流程" class="headerlink" title="服务器端通信流程"></a>服务器端通信流程</h2><p>1．创建一个用于监听的套接字 – socket()<br>-监听:监听有客户端的连接<br>-套接字:其实就是一个文件描述符(sockfd),sockfd会监听指向的伪文件（伪文件有读、写两个缓冲区）<br>2．将这个监听文件描述符和本地服务器的IP和端口绑定 – bind()<br>-客户端连接服务器的时候使用的就是这个IP和端口<br>3．设置监听，监听的socket开始工作 – listen()<br>-sockfd会监听指向的读缓冲区是否有内容，即客户端是否有发送数据过来<br>4．阻塞等待 – accept()<br>-当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的新的套接字,这个socket区别于前面只用于监听的socket，是用来和客户端通信的<br>5．通信<br>-接收数据 – recv()<br>-发送数据 – send()<br>6．通信结束，断开连接 – close()</p><h2 id="客户端通信流程"><a href="#客户端通信流程" class="headerlink" title="客户端通信流程"></a>客户端通信流程</h2><p>1．创建一个用于通信的套接字 – socket()<br>2．连接服务器，需要指定连接的服务器的IP和端口 – connect()<br>3．连接成功了，客户端可以直接和服务器通信<br>-接收数据 – recv()<br>-发送数据 – send()<br>4．通信结束，断开连接 – close()</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span><span class="hljs-comment">//包含了这个头文件，上面两个就可以省略</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain，<span class="hljs-type">int</span> type，<span class="hljs-type">int</span> protoco1)</span>;<br>    -功能:创建一个套接字<br>    -参数:<br>        - domain:协议族<br>            AF_INET : ipv4AF_INET6 : ipv6<br>            AF_UNIX，AF_LOCAL:本地套接字通信（进程间通信)<br>        - type:通信过程中使用的协议类型<br>        	SOCK_STREAM :流式协议soCK_DGRAM:报式协议<br>        - protoco1 :具体的一个协议。一般写<span class="hljs-number">0</span><br>            - SOCK_STREAM:流式协议默认使用TCP<br>            - SOCK_DGRAM∶报式协议默认使用UDp-返回值:<br>    -成功:返回文件描述符，操作的就是内核缓冲区。<br>    -失败:<span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr，<span class="hljs-type">socklen_t</span> addrlen)</span>;<br>    -功能:绑定，将fd和本地的IP＋端口进行绑定<br>    -参数:<br>        - sockfd :通过socket函数得到的文件描述符<br>        - addr :需要绑定的socket地址，这个地址封装了ip和端口号的信息<br>        - addrlen :第二个参数结构体占的内存大小<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">int</span> backlog)</span>;<br>    -功能:监听这个socket上的连接<br>    -参数:<br>        - sockfd :通过socket()函数得到的文件描述符<br>        - backlog :未连接的和已经连接的和的最大值，可在/proc/sys/net/core/somaxconn下查看系统设置的最大值，不能超过这个值<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-keyword">struct</span> sockaddr *addr ，<span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>    -功能:接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接<br>    -参数:<br>        - sockfd :用于监听的文件描述符<br>        - addr :传出参数，记录了连接成功后客户端的地址信息（ip, port)<br>        - addr len :指定第二个参数的对应的内存大小<br>    -返回值:<br>        -成功:用于通信的文件描述符<br>        - <span class="hljs-number">-1</span> :失败<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr，<span class="hljs-type">socklen_t</span> addrlen)</span>;<br>-功能:客户端连接服务器<br>-参数:<br>    - sockfd :用于通信的文件描述符<br>    - addr :客户端要连接的服务器的地址信息<br>    - addrlen :第二个参数的内存大小<br>-返回值:<br>	成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd，<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf，<span class="hljs-type">size_t</span> count)</span>;<span class="hljs-comment">//写数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd， <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<span class="hljs-comment">//读数据</span><br>        <br></code></pre></td></tr></tbody></table></figure><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP是一种<strong>面向连接的单播协议</strong>，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的”连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如IP地址、端口号等。<br>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。<br>其中，三次握手是为了保证通信连接的建立。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.54mqaowxcu40.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><p>**16位源/目的端口号:**告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序(目的端口)的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号。<br>**32位序号 :**一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN (Initial Sequence Number，初始序号值)。那么在该传输方向上(从A到B)，后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP 报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN +1025。另外一个传输方向(从B到A)的TCP报文段的序号值也具有相同的含义。<br><strong>32位确认号:<strong>用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的</strong>序号值＋标志位长度(SYN，FIN)+数据长度</strong>。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同样携带自己的序号和对A发送来的报文段的确认序号。<br>**4位头部长度:**标识该TCP头部有多少个32 bit(4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。<br><strong>6位标志位包含如下几项:</strong></p><ul><li>URG标志，表示紧急指针(urgent pointer）是否有效。</li><li>ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。</li><li>PSH标志，表示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间(如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中)。</li><li>RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。</li><li>SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</li><li>FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</li></ul><p>**16位窗口大小(window size):**是TCP流星控制的一个手段。这里说的窗口，指的是接收通告窗口(Receiver Window，RWND)。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。<br>**16位校验和（TCP checksum):**由发送端填充，接收端对TCP报文段执行CRC算法以校验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的—个重要保障。<br>**16位紧急指针:**是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</p><p><strong>三次握手原理：</strong><br>TCP是在客户端和服务器之间建立一条连接的。那么如何确保这条连接是可靠的？这就需要服务器和客户端都能保证双方的收发是没问题的，实现手段靠的就是三次握手原则。<br>这里以四位收发标志位代表收发功能的确定，0表示不确定，1表示确定。前两位表示客户端收发，后两位表示服务器收发。字母C代表客户端，S代表服务器。<br>三次握手通信流程如下：</p><ol><li>客户端向服务器端发送建立连接的请求，此时可确定客户端发的功能，标志位为C-0100。</li><li>服务器端收到连接请求，确定了客户端的发的功能，自己的收的功能。标志位为S-0110。</li><li>服务器又向客户端发送应答和建立连接请求的消息，确定了自己的发的功能。标志位为S-0111。</li><li>客户端收到了服务器发送的消息，确定了自己收的功能，和服务器收发的功能。标志位C-1111。</li><li>最后客户端向服务器发送应答消息，服务器接收后确定自己发的功能。标志位S-1111。</li></ol><p>这样，经过三次消息的发送应答，服务器和客户端都确定的双发的收发功能，能够建立可靠连接。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.6mzi7aovung0.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><p>上图是三次握手的时序图。</p><p>第一次握手,发送客户端TCP报文（客户端进入SYN_SENT状态）:</p><ol><li>客户端将SYN标志位置为1</li><li>生成一个随机的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小)，如J(100)表示发送的数据大小为100，这里表示方法只用来方便阅读识别，实际通信并没有括号</li></ol><p>第二次握手，收到客户端报文后发送服务器端TCP报文（服务器进入SYN_RCVD状态）:</p><ol><li>服务器端接收客户端的连接:ACK=1</li><li>服务器会回发一个确认序号:ack=客户端的序号＋数据长度(接收到的数据量)＋SYN/FIN(按一个字节算)</li><li>服务器端会向客户端发起连接请求:SYN=1</li><li>服务器会生成一个随机序号: seq = K</li></ol><p>第三次握手，收到服务器端报文后发送客户端TCP报文（客户端进入ESTABLISHED状态，服务器进入ESTABLISHED状态）:</p><ol><li>客户端应答服务器的连接请求:ACK=1</li><li>客户端回复收到了服务器端的数据: ack=服务端的序号＋数据长度＋SYN/FIN(按一个字节算）</li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>同三次握手，当TCP通信双发断开连接时，需要通过四次挥手实现断开连接。 发送过FIN信号的一方在断开连接前不能发只能收。</p><p>通信时序图如下：</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.5ks8mv38ykk.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><p>为什么断开连接时，不像建立连接那样把ACK和FIN放一起发？</p><p>首先要知道，发送过FIN信号的一方在断开连接前不能发只能收。比如当客户端单方面要结束通信时，发送了FIN信号，然后它就不能再发数据了。但是此时服务器如果还有数据要发送给客户端，就不能发FIN信号，只能先给客户端一个ACK响应，然后继续发数据，当发完了再发送FIN信号告知客户端结束通信。这就是为什么要把ACK和FIN分开发送的原因。</p><p>在最后进入TIME_WAIT状态，通常这个状态会持续一段时间：2msl，这又是为什么？</p><p>首先解释一下MSL (Maximum Segment Lifetime):官方建议：2分钟,TCP中实际是30s。<br>通俗的讲，在客户端最后接收到服务器发来的FIN信号后需要再给服务器一个应答，然而服务器是不一定能收到这个应答的。如果收不到服务器会再次发送FIN信号，但客户端要是给完应答直接关了通道的话，就收不到了，这就导致服务器端的连接关不掉。为了防止这个意外的发送，就让TIME_WAIT状态持续2msl，来保证服务器丢失ACK应答后能再次发送ACK，确保双方通道都能关闭。</p><blockquote><p><strong>半连接：</strong>当TCP链接中A向B发送FIN请求关闭，另一端B回应ACK之后(A端进入FIN_WAIT_2状态)，并没有立即发送FIN给A，A方处于半连接状态(半开关)，此时A可以接收B发送的数据，但是A已经不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /socket.h&gt;</span></span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">int</span> how)</span> ;<br> sockfd:需要关闭`socket`的描述符<br> how:允许为`shutdown`操作选择以下几种方式:<br> SHUT_RD(O):关闭`sockfd`上的读功能，此选项将不允许`sockfd`进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。<br> SHUT_wR(<span class="hljs-number">1</span>):关闭`sockfd`的写功能，此选项将不允许`sockfd`进行写操作。进程不能在对此套接字发出写操作。<br> SHUT_RDNR(<span class="hljs-number">2</span>):关闭`sockfd`的读写功能。相当于调用`shutdown`两次:首先是以`SHUT_RD` ,然后是`SHUT_WR`。<br></code></pre></td></tr></tbody></table></figure><p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:<br>1.如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用close，套接字将被释放。<br>⒉在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但如果一个进程close(sfd)将不会影响到其它进程。</p><p><strong>端口复用：</strong>当设置socket与端口绑定时，其他socket就无法再使用这个端口了。但这引出了一个问题，当通信双发一端如服务器还没来得及断开连接就突然关掉了，这时候服务器TCP的通信状态就会变成TIME_WAIT状态，端口仍然占用着，直到过去2msl时间才会彻底关闭socket解除端口占用。为了解决这个问题就利用了端口复用技术。</p><p>端口复用就是让端口不止能连接到一个socket，这样即使一方突然关掉，也能重新使用该端口。对应Linux系统的API接口为<code>setsockopt</code>。</p></blockquote><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><blockquote><p>滑动窗口(Sliding window)是一种流量控制技术。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包(称窗口尺寸)。</p></blockquote><p>TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报。<br>滑动窗口是TCP中实现诸如ACK确认、流量控制、拥塞控制的承载结构。</p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.6r3zm71zzug0.jpg" srcset="/img/loading.gif" lazyload alt="image" style="zoom:80%"><p>上图为TCP通信收发数据的一次流程图。<br>其中mss : Maximum segment size(一条数据的最大的数据量)；win:滑动窗口</p><ol><li>客户端向服务器发起连接，客户端的滑动窗口是4096，一次发送的最大数据量是1460</li><li>服务器接收连接，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024</li><li>第三次握手应答</li><li>4-9客户端连续给服务器发送了6k的数据，每次发送1k，到第九步时服务器的缓冲区满了，需要处理</li><li>第10次，服务器告诉客户端:发送的6k数据已经接收到，存储在缓冲区中，缓冲区数据已经处理了2k,可用窗口大小是2k</li><li>第11次，服务器告诉客户端:发送的6k数据已经接收到，存储在缓冲区中，缓冲区数据已经处理了4k,可用窗口大小是4</li><li>第12次，客户端给服务器发送了1k的数据</li><li>第13次，客户端主动请求和服务器断开连接，并且给服务器发送了1k的数据</li><li>第14次，服务器回复ACK 8194，a:同意断开连接的请求b:告诉客户端已经接受到方才发的2k的数据c:滑动窗口2k</li><li>第15、16次，通知客户端滑动窗口的大小</li><li>第17次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</li><li>第18次，第四次回收,客户端同意了服务器端的断开请求</li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" class="category-chain-item">网络通信</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">#网络通信</a></div></div><div class="license-box my-3"><div class="license-title"><div>Linux网络通信基础（3）</div><div>https://easyboy-blog.com/network-communications-3.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>laser</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月1日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/network-communications-2.html" title="Linux网络通信基础（2）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux网络通信基础（2）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/network-communications-1.html" title="Linux网络通信基础（1）"><span class="hidden-mobile">Linux网络通信基础（1）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.17/Valine.min.js",(function(){var i=Object.assign({appId:"TSl5PlExO22wiwkA3e15kGvM-gzGzoHsz",appKey:"36AERjunsq15rL0xcz3ovKbG",path:"window.location.pathname",placeholder:"尽情吐槽吧~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>