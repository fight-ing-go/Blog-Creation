<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/cell-32x32-next.png"><link rel="icon" href="/img/cell-32x32-next.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="laser"><meta name="keywords" content=""><meta name="description" content="c++面对对象和面对过程面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，描叙某个对象在整个解决问题的步骤中的属性和行为。 编译流程预处理：将头文件内容复制到源代码中、删除注释、对宏进行替换等编译：将源代码转换为汇编代码汇编：将汇编代码转"><meta property="og:type" content="article"><meta property="og:title" content="haochenBlog"><meta property="og:url" content="https://haochendaily.com/mian-jing-wen-da.html"><meta property="og:site_name" content="haochenBlog"><meta property="og:description" content="c++面对对象和面对过程面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，描叙某个对象在整个解决问题的步骤中的属性和行为。 编译流程预处理：将头文件内容复制到源代码中、删除注释、对宏进行替换等编译：将源代码转换为汇编代码汇编：将汇编代码转"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/面试问答/image.5qtv49c3s2k0.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.4vzdy0joj2u0.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.3jl9hsmxsaw0.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.7hghr53qvrk0.jpg"><meta property="og:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.w37252o41ds.jpg"><meta property="article:published_time" content="2022-09-29T11:32:58.847Z"><meta property="article:modified_time" content="2022-10-12T15:29:28.032Z"><meta property="article:author" content="laser"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/面试问答/image.5qtv49c3s2k0.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>haochenBlog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"haochendaily.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"C"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="haochenBlog" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>EASY</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/wallpaper_img/wallhaven-72ywpv_1920x1080.1t8ds73xt2yo.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text=""></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-09-29 19:32" pubdate>2022年9月29日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 18k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 150 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none"></h1><div class="markdown-body"><h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h2 id="面对对象和面对过程"><a href="#面对对象和面对过程" class="headerlink" title="面对对象和面对过程"></a>面对对象和面对过程</h2><p>面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。<br>面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，描叙某个对象在整个解决问题的步骤中的属性和行为。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>预处理：将头文件内容复制到源代码中、删除注释、对宏进行替换等<br>编译：将源代码转换为汇编代码<br>汇编：将汇编代码转换为机器码<br>链接：链接目标代码、其他目标代码、启动代码等生成可执行文件。</p><blockquote><p>编译能使用gcc/g++，因为在编译阶段g++能自动调用gcc，两者等价；但gcc不能进行库连接，所以链接用g++或gcc -lstdc++。</p></blockquote><h2 id="静态连接库、动态链接库"><a href="#静态连接库、动态链接库" class="headerlink" title="静态连接库、动态链接库"></a>静态连接库、动态链接库</h2><p>动态函数库在编译的时候并没有被编译进目标代码中，程序执行到相关函数时才调用该函数库里的相应函数，动态函数库所产生的可执行文件比较小。<br>整个函数库在编译时都会被整合进目标代码中，编译后的执行程序不需要外部的函数库支持，利用静态函数库编译成的文件比较大<br>在Win下，动态库以.dll结尾，静态库以.lib结尾。<br>在Linux下，动态库文件以.so结尾，静态库以.a结尾。<br>静态库生成：<br>默认就是在编静态库，-c要求只预处理、编译，不链接。</p><blockquote><p>gcc -c hello.c<br>用ar命令将.o文件归档.a文件。#这里的ar相当于tar的作用，将多个目标打包。<br>ar -r libhello.a hello.o<br>静态库的链接：<br>-static选项是告诉编译器，-L大写的L指明库所在的目录，-l小写的L是在指出需要的动态库，hello是静态库。<br>gcc main.c -static -L . -lhello -o main<br>动态库的生成<br>在使用GCC编译程序时，只需加上-shared选项,<br>gcc hello.c -fPIC -shared -o libhello.so<br>动态库的链接<br>不加-static选项，-l小写的L是在指出需要的动态库。<br>gcc main.c -L . -lhello -o main</p></blockquote><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>“开”，指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；<br>“闭”，是指对于原有代码的修改是封闭的，即不应该修改原有的代码。<br>实现：把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。</p><h2 id="说说include头文件的顺序以及双引号””和尖括号-lt-gt-的区别"><a href="#说说include头文件的顺序以及双引号””和尖括号-lt-gt-的区别" class="headerlink" title="说说include头文件的顺序以及双引号””和尖括号<>的区别"></a>说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h2><p>区别：<br>（1）尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。<br>（2）编译器预处理阶段查找头文件的路径不一样。<br>查找路径：<br>（1）使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。<br>（2）使用双引号””的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</p><h2 id="c-特性-封装继承多态"><a href="#c-特性-封装继承多态" class="headerlink" title="c++特性-封装继承多态"></a>c++特性-封装继承多态</h2><p>封装：隐藏对象的属性和实现细节，仅仅对外提供接口和方法<br>继承：让某种类型对象获得另⼀个类型对象的属性和⽅法。实现继承、接口继承<br>多态：同一事物对不同对象表现出不同的能力，允许将⼦类类型的指针赋值给⽗类类型的指针。重载overload，编译时的多态；覆盖override，运行时的多态</p><h2 id="如何实现多态"><a href="#如何实现多态" class="headerlink" title="如何实现多态"></a>如何实现多态</h2><p>overload和override</p><h2 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h2><p>内存分配方式：<br>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。<br>栈: 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。<br>堆: 就是那些由new分配的内存块，一般一个new就要对应一个delete。<br>自由存储区: 就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。<br>全局/静态存储区: 全局变量和静态变量被分配到同一块内存中<br>常量存储区: 这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p><h2 id="c-程序组成"><a href="#c-程序组成" class="headerlink" title="c++程序组成"></a>c++程序组成</h2><div align="center"><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/面试问答/image.5qtv49c3s2k0.jpg" srcset="/img/loading.gif" lazyload width="60%/"></div><p>数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。<br>代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。<br>BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。<br>可执行程序在运行时又会多出两个区域：堆区和栈区。<br>堆区：动态申请内存用。堆从低地址向高地址增长。<br>栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。<br>最后还有一个共享区，位于堆和栈之间。</p><h2 id="内存泄露及解决办法："><a href="#内存泄露及解决办法：" class="headerlink" title="内存泄露及解决办法："></a>内存泄露及解决办法：</h2><p>什么是内存泄露？<br>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。<br>（1）new和malloc申请资源使用后，没有用delete和free释放；<br>（2）子类继承父类时，父类析构函数不是虚函数。<br>（3）Windows句柄资源使用后没有释放。</p><p>怎么检测？<br>第一：使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。<br>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查该链表。<br>第三：使用智能指针。<br>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p><h2 id="struct结构体与class对比"><a href="#struct结构体与class对比" class="headerlink" title="struct结构体与class对比"></a>struct结构体与class对比</h2><ul><li>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；</li><li>与class的区别：</li><li>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。</li><li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li><li>class 可以定义模板，而 struct 不能。</li></ul><h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>定义全局静态变量和局部静态变量：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；静态变量只能在本源文件中使用；</p><p>定义静态函数：静态函数只能在本源文件中使用；//示例 static int a; static void func();</p><p>定义类中的静态成员变量：类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。</p><p>定义类中的静态成员函数：所有这些对象的静态数据成员都共享这一块静态存储空间。<br>（C++规定静态成员函数没有this指针。无法对一个对象中的非静态成员进行访问。）</p><h2 id="简述const（星号）和（星号）const的区别"><a href="#简述const（星号）和（星号）const的区别" class="headerlink" title="简述const（星号）和（星号）const的区别"></a>简述const（星号）和（星号）const的区别</h2><p>//const* 是常量指针，*const 是指针常量<br>int const <em>a; //a指针所指向的内存里的值不变，即（</em>a）不变<br>int *const a; //a指针所指向的内存地址不变，即a不变</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>概念：指向函数的指针变量。指向函数的入口地址。<br>应用场景：回调。如果别人的库里面调用我们的函数，就叫Callback。例子：排序函数，使用自定义的函数比较大小。</p><h2 id="nullptr调用成员函数可以吗？为什么？"><a href="#nullptr调用成员函数可以吗？为什么？" class="headerlink" title="nullptr调用成员函数可以吗？为什么？"></a>nullptr调用成员函数可以吗？为什么？</h2><p>能。原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。用到this指针会报错。</p><h2 id="什么是野指针，怎么产生的，如何避免？"><a href="#什么是野指针，怎么产生的，如何避免？" class="headerlink" title="什么是野指针，怎么产生的，如何避免？"></a>什么是野指针，怎么产生的，如何避免？</h2><p>概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存<br>避免办法：<br>（1）初始化置NULL<br>（2）申请内存后判空<br>（3）指针释放后置NULL<br>（4）使用智能指针</p><h2 id="说说new和malloc的区别，各自底层实现原理。"><a href="#说说new和malloc的区别，各自底层实现原理。" class="headerlink" title="说说new和malloc的区别，各自底层实现原理。"></a>说说new和malloc的区别，各自底层实现原理。</h2><p>new是操作符，而malloc是函数。<br>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。<br>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。<br>new可以被重载；malloc不行<br>new发生错误抛出异常，malloc返回null。</p><p>malloc底层实现：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。<br>new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：<br>创建一个新的对象<br>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）<br>执行构造函数中的代码（为这个新对象添加属性）<br>返回新对象</p><h2 id="简述C-有几种传值方式，之间的区别是什么？"><a href="#简述C-有几种传值方式，之间的区别是什么？" class="headerlink" title="简述C++有几种传值方式，之间的区别是什么？"></a>简述C++有几种传值方式，之间的区别是什么？</h2><p>传参方式有这三种：值传递、引用传递、指针传递<br>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；<br>引用传递：形参在函数体内值发生变化，会影响实参的值；<br>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</p><h2 id="c-常用容器"><a href="#c-常用容器" class="headerlink" title="c++常用容器"></a>c++常用容器</h2><p>vector、list、deque、set、map等，⽤来存放数据</p><h2 id="c-11新特性"><a href="#c-11新特性" class="headerlink" title="c++11新特性"></a>c++11新特性</h2><p>auto: 让编译器在编译期就推导出变量的类型<br>decltype: 推导表达式类型，只⽤于编译器分析表达式的类型，表达式实际不会进⾏运算<br>右值引用<br>范围for循环: for（变量：对象）表达式<br>列表初始化<br>lambda表达式：表示⼀个可调⽤的代码单元<br>智能指针：std::shared_ptr、std::weak_ptr、std::unique_ptr</p><h2 id="智能指针："><a href="#智能指针：" class="headerlink" title="智能指针："></a>智能指针：</h2><p>std::shared_ptr：使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。<br>std::weak_ptr：获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。<br>std::unique_ptr：是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ol><li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li><li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li><li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li></ol><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>1.数组在内存中连续，链表不连续<br>2.数组长度固定，当扩大长度时会开辟新的内存空间存放数组，链表长度不固定<br>3.数组的删除插入会移动后面的元素，链表不会<br>4.数组查询效率高，链表需要遍历</p><h2 id="单链表判断是否有环，找到入环节点，优化"><a href="#单链表判断是否有环，找到入环节点，优化" class="headerlink" title="单链表判断是否有环，找到入环节点，优化"></a>单链表判断是否有环，找到入环节点，优化</h2><p>（1）用set存放以及遍历过的链表<br>（2）快慢指针</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>在c++ STL中属于容器适配器，底层实现一般是deque.<br>栈stack是先进后出，队列queue是先进先出。</p><h2 id="排序方法的了解"><a href="#排序方法的了解" class="headerlink" title="排序方法的了解"></a>排序方法的了解</h2><p>冒泡排序、选择排序、插入排序、希尔排序、快速排序、堆排序、归并排序、基数排序、桶排序、计数排序</p><h2 id="快排思路"><a href="#快排思路" class="headerlink" title="快排思路"></a>快排思路</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Paritition1</span>(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high) {<br>  <span class="hljs-type">int</span> pivot = A[low];<br>  <span class="hljs-keyword">while</span> (low &lt; high) {<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) {<br>      --high;<br>    }<br>    A[low] = A[high];<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) {<br>      ++low;<br>    }<br>    A[high] = A[low];<br>  }<br>  A[low] = pivot;<br>  <span class="hljs-keyword">return</span> low;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//快排母函数</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-keyword">if</span> (low &lt; high) {<br>    <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Paritition1</span>(A, low, high);<br>    <span class="hljs-built_in">QuickSort</span>(A, low, pivot - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">QuickSort</span>(A, pivot + <span class="hljs-number">1</span>, high);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="用两个栈模拟队列："><a href="#用两个栈模拟队列：" class="headerlink" title="用两个栈模拟队列："></a>用两个栈模拟队列：</h2><p>push时直接加入到栈中，pop时，当栈2为空时，栈1内容全部放到2中，再pop;当栈2不为空，栈2直接pop;</p><h2 id="数据结构，栈和队列的区别"><a href="#数据结构，栈和队列的区别" class="headerlink" title="数据结构，栈和队列的区别"></a>数据结构，栈和队列的区别</h2><p>队列可两端操作，栈只能操作栈顶；栈先进后出，队列先进先出；</p><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="python三目运算符"><a href="#python三目运算符" class="headerlink" title="python三目运算符"></a>python三目运算符</h2><pre><code class="hljs">max = a if a&gt;b else b
</code></pre><h2 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h2><p>文本类型： str<br>数值类型： int, float, complex<br>序列类型： list, tuple, range<br>映射类型： dict<br>集合类型： set, frozenset<br>布尔类型： bool<br>二进制类型： bytes, bytearray, memoryview</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Python有五个标准的数据类型：<br>Numbers（数字）<br>String（字符串）<br>List（列表）<br>Tuple（元组）<br>Dictionary（字典）</p><p>Python3 中有六个标准的数据类型：<br>Number（数字）<br>String（字符串）<br>List（列表）<br>Tuple（元组）<br>–Set（集合）<br>Dictionary（字典）</p><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="get和post区别："><a href="#get和post区别：" class="headerlink" title="get和post区别："></a>get和post区别：</h2><table><thead><tr><th align="center">get</th><th align="center">post</th></tr></thead><tbody><tr><td align="center">获取指定资源</td><td align="center">根据请求体处理指定资源</td></tr><tr><td align="center">参数在URL中，有长度和ASCALL格式限制</td><td align="center">参数在body中，无长度和格式限制</td></tr><tr><td align="center">get请求可缓存</td><td align="center">请求不可缓存</td></tr><tr><td align="center">安全（不破坏服务器资源）幂等（无论请求多少次结果相同）</td><td align="center">不安全，不幂等</td></tr></tbody></table><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p><h2 id="TCP、UDP不同点"><a href="#TCP、UDP不同点" class="headerlink" title="TCP、UDP不同点"></a>TCP、UDP不同点</h2><p>TCP需要建立双方连接，是一对一通信；UDP无需连接，可以一对一、一对多、多对多通信<br>TCP传输是可靠的，UDP不可靠<br>TCP有拥堵控制、流量控制；UDP没有，发送速率不受影响<br>TCP首部可变，UDP首部固定<br>TCP是流式传输，UDP是以数据包的形式发送<br>TCP数据如果超过MSS，会在传输层分片；UDP如果超过MTU会在IP层进行分片</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>双方处于close状态。服务器端开启监听进入LISTEN状态；客户端发送含有SYN标志的报文，进入SYN_SENT状态；服务端收到报文进入SYN_RCVD状态，并发送含有SYN和ACK的报文给客户端；客户端接收到后进入ESTABLISHED状态，并发送ACK报文；服务端接收后也进入ESTABLISHED状态。</p><h2 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h2><p>1.避免历史连接<br>2.同步双方初始序列号</p><h2 id="TCP为什么可靠？"><a href="#TCP为什么可靠？" class="headerlink" title="TCP为什么可靠？"></a>TCP为什么可靠？</h2><p>校验和：检测数据传输是否出错<br>ACK应答：发送端发送信息给接收端，接收端会回应一个包<br>超时重传：在一定时间没有接收到ACK应答会重发数据</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程是资源分配的单位，线程是CPU调度的单位；<br>进程有独立的地址空间，线程只有独立的栈和寄存器<br>线程并发性比进程高，创建、切换快开销小；<br>进程可独立运行，线程需要依存应用程序</p><h2 id="线程同步方式有哪些？"><a href="#线程同步方式有哪些？" class="headerlink" title="线程同步方式有哪些？"></a>线程同步方式有哪些？</h2><p>线程间的同步方式包括互斥锁、信号量、条件变量、读写锁：<br>互斥锁：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。<br>信号量：计数器，允许多个线程同时访问同一个资源。<br>条件变量：通过条件变量通知操作的方式来保持多线程同步。<br>读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据<br>同步：阻塞、非阻塞、IO多路复用、信号驱动<br>异步：异步IO</p><h2 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><p>select: 将已连接的socket放到一个文件描述符集合中，把这个集合复制给内核，内核遍历检查是否有事件发生，标记事件；内核将标记后的整个集合复制给用户，用户遍历检查集合，处理发生的事件</p><p>poll: 区别了用户检测事件和内核检测事件，把要检测的事件和实际发生的事件放在了一个结构体里，弥补了select每次循环要重置fds集合的缺点。此外因为poll文件描述符集合用的是结构体，所以没有了数量限制。</p><p>epoll:</p><ol><li>epoll在内核中使用红黑树追踪所有待检测的socket，每次有新的socket只需加入红黑树，不用整体复制。</li><li>每次返回的只是发生事件的socket个数，将发生事件的socket和事件类型保存在了events中。</li></ol><h2 id="进程间通信方式："><a href="#进程间通信方式：" class="headerlink" title="进程间通信方式："></a>进程间通信方式：</h2><p>管道：匿名，有名；传输数据是单向的，先进先出，一端读一端写。<br>消息队列：保存在内核中的消息链表；<br>共享内存：就是拿出一块虚拟地址空间来，映射到相同的物理内存中。<br>信号量：防止多进程引起的资源混乱，保证任何时刻只有一个进程访问共享资源。<br>信号：对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。<br>socket: 跨网络与不同主机上的进程之间通信。</p><h2 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h2><p>死锁：指多个进程在执行过程中，因争夺资源而造成了互相等待。<br>产生的条件：<br>（1）互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；<br>（2）请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；<br>（3）不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺；<br>（4）环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>防止死锁:按序获得资源.</p><h2 id="乐观锁与悲观锁："><a href="#乐观锁与悲观锁：" class="headerlink" title="乐观锁与悲观锁："></a>乐观锁与悲观锁：</h2><p>悲观锁：多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。<br>乐观锁：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷⻉：只是拷⻉⼀个指针，并没有新开辟⼀个地址，拷⻉的指针和原来的指针指向同⼀块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷⻉的指针的资源就会出现错误。<br>深拷⻉：不仅拷⻉值，还开辟出⼀块新的空间⽤来存放新的值，即使原先的对象被析构掉，释放<br>内存了也不会影响到深拷⻉得到的值。在⾃⼰实现拷⻉赋值的时候，如果有指针变ᰁ的话是需要⾃⼰实现深拷⻉的。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux操作指令"><a href="#Linux操作指令" class="headerlink" title="Linux操作指令"></a>Linux操作指令</h2><p>（查看日志）cat：将多个文件拼接后输出；more：显示文本内容，一次一屏；less：与more类似，可翻页；head;tail;<br>greap:查找文件中的字符串<br>cp:复制； rm：删除文件或目录 mv：移动或重命名<br>wc:统计给定文件中的字数、行数、字节数<br>find path -option :指定目录下查找文件<br>pwd: 查看“当前所在目录”的完整路径<br>mkdir:创建目录<br>ln: 链接文件或目录 -s 软链接 不加 硬链接</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>增：<br>insert：insert [into] &lt;表名&gt; [列名] values &lt;列值&gt;</p><p>删：<br>使用delete删除数据某些数据<br>delete: delete from &lt;表名&gt; [where &lt;删除条件&gt;]　　<br>使用truncate table 删除整个表的数据,删除表的所有行，但表的结构、列、约束、索引等不会被删除；<br>语法：truncate table &lt;表名&gt;</p><p>改：<br>update &lt;表名&gt; set &lt;列名=更新值&gt; [where &lt;更新条件&gt;]</p><p>查：<br>select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达式&gt;] [order by &lt;排序的列名&gt;[asc或desc]]</p><h2 id="关键字执行顺序"><a href="#关键字执行顺序" class="headerlink" title="关键字执行顺序"></a>关键字执行顺序</h2><p>(7) SELECT<br>(8) DISTINCT<select_list><br>(1) FROM<left_table><br>(3)<join_type>JOIN<right_table><br>(2) ON<join_condition><br>(4) WHERE<where_condition><br>(5) GROUP BY<group_by_list><br>(6) HAVING<having_condition><br>(9) ORDER BY<order_by_condition><br>(10) LIMIT<limit_number></limit_number></order_by_condition></having_condition></group_by_list></where_condition></join_condition></right_table></join_type></left_table></select_list></p><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><p>内连接只显示符合连接条件的记录，外连接除了显示符合条件的记录外，还显示表中其他的记录<br>使用JOIN<br>内连接：<br>INERT JOIN：返回两张表的交集<br>外连接：<br>LEFT JOIN:以左表为基准，返回左表加上右表中与左表共同的部分<br>RIGHT JOIN：相反<br>FULL JOIN：全外连接是在结果中除了显示满足连接的条件的行外，还显示了join两侧表中所有满足检索条件的行</p><h2 id="事务的四大特性："><a href="#事务的四大特性：" class="headerlink" title="事务的四大特性："></a>事务的四大特性：</h2><p>原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态。<br>一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。（拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。）<br>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。<br>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？<br>持久性是通过 redo log （重做日志）来保证的；<br>原子性是通过 undo log（回滚日志） 来保证的；<br>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；<br>一致性则是通过持久性+原子性+隔离性来保证；</p><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。<br>不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。<br>幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p><h2 id="隔离级别（从低到高）"><a href="#隔离级别（从低到高）" class="headerlink" title="隔离级别（从低到高）"></a>隔离级别（从低到高）</h2><p>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；<br>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；<br>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；<br>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="为什么选择测试？"><a href="#为什么选择测试？" class="headerlink" title="为什么选择测试？"></a>为什么选择测试？</h2><p>首先，现在的大环境对产品质量的要求越来越高了，测试的需求也会不断增加，测试这一行业的发展前景个人认为是不错的。其次，我喜欢有条例的整理事情并且对技术方面有一定的兴趣，而测试这个岗位，既需要逻辑性的发现问题也需要自主开发一些自动化测试工具，比较符合我的兴趣，能激发我的工作热情。再者是我目前对于开发、代码、算法都有些许了解，我认为我能更快的适应测试的工作。以上就是我选择测试岗的几点原因。</p><h2 id="你对测试的理解？"><a href="#你对测试的理解？" class="headerlink" title="你对测试的理解？"></a>你对测试的理解？</h2><p>首先，测试的目的是发现软件中存在的缺陷；看看是否符合设计要求、技术要求；以及对软件进行验证和质量评估；也就是保证软件的质量。这直接影响着用户的体验，所以软件测试对于项目来说是很重要的。此外，现在不仅仅是通过手工测试来发现定位Bug，也会通过编写脚本、测试工具来完成自动化测试，因此，对于测试人员来说，除了保证产品质量之外，还要有一定的代码能力。这就是我对测试开发的一点理解。</p><h2 id="你认为测试人员需要具备哪些素质。（你有哪些优点围绕这些来说）"><a href="#你认为测试人员需要具备哪些素质。（你有哪些优点围绕这些来说）" class="headerlink" title="你认为测试人员需要具备哪些素质。（你有哪些优点围绕这些来说）"></a>你认为测试人员需要具备哪些素质。（你有哪些优点围绕这些来说）</h2><p>首先要有一定的沟通协调能力，因为测试人员经常会与开发人员接触处理一些问题，需要心平气和地沟通。还需要有一定的耐心，不能放过每一个错误；<br>要有责任感，要尽自己最大的能力，保证产品的质量。<br>要有好奇心，保持一种怀疑的态度，测试人员的任务是找出缺陷，不是证明没有缺陷，所以需要保持怀疑。<br>从技术上来说，要有良好的测试基础理论、必要的计算机知识，了解软件才能更好的发现问题。</p><h2 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h2><p>需求分析 -&gt; 测试计划和测试方案 -&gt; 测试用例设计 -&gt; 测试用例执行 -&gt; 回归测试 -&gt; 生产环境测试 -&gt;评估阶段、测试报告<br>需求评审 -&gt; 测试用例编写 -&gt; 测试用例评审 -&gt; 开发自测 -&gt; 冒烟测试 -&gt; 功能测试 -&gt; 性能测试（包含兼容性测试） -&gt; 上线回归测试</p><h2 id="单元测试、集成测试、系统测试、验收测试、回归测试："><a href="#单元测试、集成测试、系统测试、验收测试、回归测试：" class="headerlink" title="单元测试、集成测试、系统测试、验收测试、回归测试："></a>单元测试、集成测试、系统测试、验收测试、回归测试：</h2><p>单元测试：对程序最小模块单元进行测试。可平行测试。包括：模块接口测试、局部数据结构测试、路径测试、错误处理测试、边界测试。<br>集成测试：对程序模块进行组合递增测试，重点测试模块的接口部分。包括：模块之间数据传输、组合起来功能是否正确、全局数据结构是否被异常修改、单模块缺陷对整体的影响<br>系统测试：对整个软件系统进行测试。包括：功能、性能、兼容性、界面等进行测试。<br>验收测试：向软件购买者展示软件系统，按照用户需求来测。<br>回归测试：指在发生修改之后重新测试先前的测试用例以保证修改的正确性。</p><h2 id="测试方法有什么？"><a href="#测试方法有什么？" class="headerlink" title="测试方法有什么？"></a>测试方法有什么？</h2><p>测试方法主要有两大类，白盒测试和黑盒测试。<br>白盒测试：检查程序的内部结构、逻辑、循环和路径。有语句覆盖、判定覆盖、条件覆盖等等。<br>黑盒测试：检测每个功能是否都能正常使用。等价类、边界值、因果图、判定表、场景法、流程分析法、错误推断法、正交法</p><ul><li>等价类法：对输入集合合理分类，从每个类中取出少数代表性用例。有有效等价类和无效等价类。</li><li>边界值：取等价类中的边界情况，稍高及稍低。</li><li>因果图：利用图解法，考虑输入条件的组合制约关系、输出对输入的依赖关系</li><li>判定表：因果图的最终形式。条件桩：问题所有条件；动作桩：问题所有输出。</li><li>场景法：模拟用户操作场景，测试系统业务流程。有基本流和备选流。</li><li>流程分析法：对系统每个流程进行测试</li><li>错误推断法：利用直觉和经验猜测出错可能类型。</li><li>正交排列法：根据正交性从全面试验挑选部分代表性的点。基于正交表</li></ul><h2 id="黑盒测试分类"><a href="#黑盒测试分类" class="headerlink" title="黑盒测试分类"></a>黑盒测试分类</h2><p>功能测试：</p><ul><li>逻辑功能测试</li><li>界面测试</li><li>易用性测试</li><li>安装测试</li><li>兼容性测试<br>性能测试：</li><li>时间性能（响应时间）</li><li>空间性能（系统资源）</li><li>稳定性测试</li><li>负载测试</li><li>压力测试</li></ul><h2 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h2><p>冒烟测试是在软件开发过程中的一种针对软件版本包的快速基本功能验证策略，是对软件<strong>基本功能进行确认验证的手段</strong>，并非对软件版本包的深入测试。<br>所以冒烟测试的主要目的就是看这个软件是否具备可测性，也叫做可测性测试。</p><h2 id="测试用例考虑方向"><a href="#测试用例考虑方向" class="headerlink" title="测试用例考虑方向"></a>测试用例考虑方向</h2><p>测试用例主要解决的问题是要测什么？怎么测？</p><h2 id="测试用例要素"><a href="#测试用例要素" class="headerlink" title="测试用例要素"></a>测试用例要素</h2><p>测试编号、测试模块、前提条件、测试输入、预期输出、操作步骤、实际结果、标题、级别</p><h2 id="测试结束的标准是什么？"><a href="#测试结束的标准是什么？" class="headerlink" title="测试结束的标准是什么？"></a>测试结束的标准是什么？</h2><p>全部测试用例都被执行完成<br>未修改bug都被确认或置为应有状态，暂缓修改的问题都有详尽的解析<br>测试报告编写完成<br>测试收尾工作结束<br>测试总结完成<br>项目处于试运行或上线阶段<br>在测试计划中定义结束的标准：在一定性能下平稳运行多少天、本版本没有严重bug，普通bug数量在多少个以下，bug修复百分之多少以上；<br>实际测试达到上述要求，由项目、开发、测试经理共同签字，认同测试结束，版本即可发布。</p><h2 id="从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法"><a href="#从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法" class="headerlink" title="从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法"></a>从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法</h2><p>对于抽奖的概率类问题，QA是不可能去抽几十万次甚至上百万次来验证概率问题，这时就要从其他角度来验证其正确性。<br>首先，可以从白盒测试的角度，对底层算法原理和代码实现方面进行验证；<br>其次，可以从自动化测试的角度，使用自动化脚本来模拟抽卡，来验证概率的正确性。</p><h2 id="测试的目的（职责）"><a href="#测试的目的（职责）" class="headerlink" title="测试的目的（职责）"></a>测试的目的（职责）</h2><p>发现软件中存在的缺陷；<br>软件是否符合设计要求；<br>软件是否符合技术要求；<br>对软件进行验证和质量评估；</p><h2 id="测试用例的优先级"><a href="#测试用例的优先级" class="headerlink" title="测试用例的优先级"></a>测试用例的优先级</h2><p>用于标识测试用例的重要性和执行频率，共分为4级，由高至低依次为P0-P3。<br>P0：核心功能测试用例（冒烟测试），确定此版本是否可测的测试用例，此部分测试用例如果fail会阻碍大部分其他测试用例的验证。<br>P1：高优先级测试用例，最常执行以保证功能性是稳定的；基本功能测试，和重要的错误、边界测试<br>P2：中优先级测试用例，更全面地验证功能的各个方面，异常测试，边界、中断、断网、容错、UI等测试用例<br>P3：低优先级测试用例，不常常被执行，性能、压力、兼容性、稳定性、安全、可用性等等。</p><h2 id="bug的严重级别和优先级"><a href="#bug的严重级别和优先级" class="headerlink" title="bug的严重级别和优先级"></a>bug的严重级别和优先级</h2><p>严重级别：<br>Blocker(崩溃)：内存泄漏、用户数据丢失等，需要立即终止当前版本测试；<br>Critiacl(严重)：功能未实现，数值错误等，不影响其他功能测试；<br>Major(一般)：边界条件错误等，不影响使用；<br>Minor(次要)：格式不规范，排版问题等，可进行优化；<br>优先级：<br>Immediate:马上解决<br>Urgent:急需解决，<br>High:高度重视，有时间就要解决<br>Normal:正常处理；计划解决</p><h2 id="如何记录BUG"><a href="#如何记录BUG" class="headerlink" title="如何记录BUG"></a>如何记录BUG</h2><p>BUG摘要：简单描述BUG<br>BUG的具体描述：把测试步骤和具体数据都写出来，尽可能多的提供信息<br>BUG严重程度<br>BUG优先级<br>BUG指派给谁<br>截图附件</p><h2 id="测试结束的标准是什么？-1"><a href="#测试结束的标准是什么？-1" class="headerlink" title="测试结束的标准是什么？"></a>测试结束的标准是什么？</h2><p>缺陷修复率标准：</p><ol><li>一、二级错误修复率应达到100%</li><li>三级错误修复率应达到80%以上</li><li>四级错误修复率应达到60%以上</li></ol><p>覆盖率标准：<br>语句覆盖率最低不能小于80%<br>测试用例执行覆盖率应达到100%<br>测试需求覆盖率应达到100%</p><h2 id="性能测试关注的指标"><a href="#性能测试关注的指标" class="headerlink" title="性能测试关注的指标"></a>性能测试关注的指标</h2><p>系统指标：<br>响应时间：对一个请求做出响应的时间；（平均响应时间、90%响应时间）<br>系统处理能力：<br>HPS：每秒发起的请求次数<br>TPS：每秒处理事务次数<br>QPS：每秒处理查询次数<br>吞吐量：系统在单位时间内处理请求的数量<br>并发用户数：同一时刻与服务器交互的用户数<br>错误率(FR)：一批请求中结果出错的请求所占比例。<br>资源性能指标：<br>CPU利用率<br>内存利用率<br>磁盘吞吐量：单位时间内通过磁盘的数据量<br>网络吞吐量：单位时间内通过网络的数据量</p><h2 id="测试输入1-100，怎么设计测试用例"><a href="#测试输入1-100，怎么设计测试用例" class="headerlink" title="测试输入1-100，怎么设计测试用例"></a>测试输入1-100，怎么设计测试用例</h2><p>先划分等价类：<br>有效等价类：1-100<br>无效等价类：小于1；大于100；小数；特殊字符；字母；中文；空格<br>再取边界值：<br>0，1，2；99，100，101</p><h2 id="自动化测试了解"><a href="#自动化测试了解" class="headerlink" title="自动化测试了解"></a>自动化测试了解</h2><p>避免重复操作、人力难以测试的操作、耗时操作</p><h2 id="程序员、策划对测试人员提交的缺陷修改不及时，怎么办？"><a href="#程序员、策划对测试人员提交的缺陷修改不及时，怎么办？" class="headerlink" title="程序员、策划对测试人员提交的缺陷修改不及时，怎么办？"></a>程序员、策划对测试人员提交的缺陷修改不及时，怎么办？</h2><p>方法一：死缠烂打，效果比较明显。经常去烦他，他受不了就会去看你提交的缺陷。<br>方法二：找自身的原因，是否每次你提交的缺陷描述，人家都能正确的重现问题。有时不是别人不想改，只是看了一下没看懂，不想花时间。<br>方法三：私下与自己配合的人员把关系搞好，有啥问题好沟通，好基友么，有啥都好商量。<br>方法四：向上级汇报。如果你真碰到了那种工作没积极性，不好好配合，也不好沟通的人。没有啥不好意思的，你这样被拖着，只会影响自己的工作。</p><h2 id="测试人员提交的bug被否定，怎么办？"><a href="#测试人员提交的bug被否定，怎么办？" class="headerlink" title="测试人员提交的bug被否定，怎么办？"></a>测试人员提交的bug被否定，怎么办？</h2><p>首先是自我检查，看看有没有描述错误<br>找相关的负责人再沟通下，如果还确认是问题，请看下面<br>多思考下自己提交的是不是真的问题。如果确认是问题，请坚持一会。但不要太久。<br>如果真是问题，那出现的几率是多少？如果真的几率太低的话，就放一放吧，等后面再出现，再让负责人来修改。不要被一个问题卡住</p><h2 id="项目上线前发现新BUG怎么办？"><a href="#项目上线前发现新BUG怎么办？" class="headerlink" title="项目上线前发现新BUG怎么办？"></a>项目上线前发现新BUG怎么办？</h2><p>1.先看这个bug等级，bug影响范围，bug复现难不难<br>2.如果等级低，影响范国很小，把bug信息和复现步骤发给开发修改。和开发沟通这个bug能否在上线前2小时候修改完毕。如果在上线前不能修复，把bug信息发给产品或者项目经理，说bug等级和影响范围，bug不能在上线前修复，这个bug可以留在下一个版本解决或者推迟一下上线时间<br>3.如果等级高，把对应的信息（等级，影响范国广，复现步骤） 发给开发，让开发一定要修复这个bug。<br>4.如果bug等级高，不能在上线前修复，可以和产品沟通一下，把bug对应的等级，影响，复现步骤发给产品或项目经理并说明之前为什么没有发现。看看能不能推迟上线。</p><h2 id="铅笔测试："><a href="#铅笔测试：" class="headerlink" title="铅笔测试："></a>铅笔测试：</h2><p>功能测试<br>1.铅笔的长度和生产要求是否一致<br>2.铅笔的宽度是否和生产要求一致<br>3.铅笔在不同的纸上显色度是否符合要求<br>4.铅笔的笔芯粗细是否符合生产要求<br>5.铅笔是否容易折断<br>6.铅笔的笔芯是否容易断<br>7.铅笔是否容易被铅笔刀削<br>8.铅笔是否容易变形<br>9.铅笔长时间放置后是否还能继续使用<br>10.铅笔被水泡以后是否还能继续使用<br>11.在高温的情况下是否可以写出字<br>12.在低温的情况下是否可以写出字<br>13.铅笔的形状是否符合生产要求<br>14.长时间使用手是否会起茧<br>15.铅笔携带的字遇到水是否会消失</p><p>性能<br>1.铅笔的硬度是否达标<br>2.铅笔从多高的地方摔下去笔芯不会摔断<br>3.震动测试笔在包装时，各面震动，检查是否能应对恶劣的公路、铁路、航空运输。<br>4.多大的力气可以把铅笔折断<br>5.铅笔的笔尖在多大的压力下可以写字<br>6.压力测试:铅笔的笔尖在多大压力下会折断<br>7.铅笔字迹能保留多久。<br>8.笔杆的图案能保持多久不被磨掉</p><p>兼容性<br>1.铅笔是否可以在不同的纸上，地上，石头上，墙上写字，玻璃上，衣服上<br>2.在不同的温度下是否可以写字</p><p>安全性<br>1.铅笔的材料无毒，符合生产要求<br>2.铅笔是否会释放出有毒的气味<br>3.误食笔芯会不会中毒<br>4.当铅笔被扔掉后会不会对环境造成污染</p><p>界面测试<br>1.铅笔的样式符合大众要求<br>2.铅笔的图案合法<br>3.铅笔的logo是否正确<br>4.铅笔的外壳颜色是否符合要求</p><p>易用性<br>1.铅笔写字流畅<br>2.铅笔用铅笔刀削起来容易<br>3.铅笔芯不容易断<br>4.铅笔显色度好<br>5.是否容易携带和存放</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="高压开关柜智能防凝露系统"><a href="#高压开关柜智能防凝露系统" class="headerlink" title="高压开关柜智能防凝露系统"></a>高压开关柜智能防凝露系统</h2><p>这个项目属于工业控制系统；系统是在各个开关柜上方接入送风管道，管道会送入经系统处理过的干净干燥而且温度适宜的空气送入开关柜内，然后又由于空气压力作用，会把柜内潮湿空气和灰尘通过另一个回风管道排除柜体，送至防凝露主机设备，经过过滤网、处理器把灰尘和空气中的水分离出来，在把空气加热送入送风管道内，形成不断循环的闭环系统。控制系统就是控制各个机器的运转像管道内的风阀、风机、又或者是加热器等，也监控系统各个位置的状态。主要控制逻辑在下位机主板实现，上位机是用于可视化监控以及实现手动控制的功能。我做的工作主要是上位机部分，也就是可视化设计，开发平台是QT，语言用的是c++，数据是从数据库读入，实现实时与历史数据的展示。</p><h2 id="基于Linux的轻量级Web服务器"><a href="#基于Linux的轻量级Web服务器" class="headerlink" title="基于Linux的轻量级Web服务器"></a>基于Linux的轻量级Web服务器</h2><p>这个项目是自己用业余时间学习的一个开源项目；实现的功能就是简单的浏览器对服务器主页的访问的功能，同时支持客户端的并发访问。项目使用reactor模式进行设计，由主线程负责监听事件与数据的接收与发送，从线程池中选取一个子线程来处理业务。当监听到有新的连接，主线程会把它加入到epoll中；当监听到新的事件，主线程会调用read函数接收数据，然后子线程对请求进行解析生成对应的响应；由主线程负责发送出去。</p><h2 id="如何提升服务器并发数？"><a href="#如何提升服务器并发数？" class="headerlink" title="如何提升服务器并发数？"></a>如何提升服务器并发数？</h2><p>硬件性能：CPU、内存、磁盘、带宽</p><p>提升操作系统的IO读写能力：零拷贝（提升了 I/O 的吞吐率）、缓存</p><p>数据库缓存：读写分离、缓存</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>传统文件传输过程<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.4vzdy0joj2u0.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><p>mmap+write:使用mmap内存映射+write，直接在内核将数据拷贝给socket缓冲区<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.3jl9hsmxsaw0.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><p>sendfile();<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.7hghr53qvrk0.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><p>真正的零拷贝：sendfile()且支持SG-DMA技术<br>没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/image.w37252o41ds.jpg" srcset="/img/loading.gif" lazyload alt="image"></p><h2 id="项目遇到的问题，遇到困难怎么解决"><a href="#项目遇到的问题，遇到困难怎么解决" class="headerlink" title="项目遇到的问题，遇到困难怎么解决"></a>项目遇到的问题，遇到困难怎么解决</h2><p>我在做项目的时候，在读取数据库数据的过程中，发现数据读取的特别慢，而找出的原因就是读取时间范围太长，数据量太大；那么根据这个原因，就可以找出解决办法：分库分表、用缓存、单独建一张搜索表等等。</p><p>首先，我会先看下这个困点的重要程度，如果不是很重要，就先暂缓下，就比如我们读论文的时候，碰到一些自己不理解的点，可以继续往下读，很多情况是在你继续读的过程中，会对前面不懂的地方有一个新的理解；那如果是很重要的难点，就是当你不解决，就无法继续推进工作的时候，就得优先处理这个困难。</p><p>首先就是要好好分析这个难点，找到根源所在，知道什么地方产生了问题，才能着手处理问题。然后就是研究解决措施了。这里的途径可以有很多，搜索引擎、找人咨询都可以。我通常是会自我钻研一段时间，有了一定的对于这个问题的理解，然后还不能解决的话，就回去向他人寻求帮助。</p><h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><h2 id="凌云光"><a href="#凌云光" class="headerlink" title="凌云光"></a>凌云光</h2><p>围绕机器视觉与光纤光学开展业务，致力成为视觉人工智能与光电信息领域的全球leader<br>2022年上市<br>产业：手机外观检测、成品组装、相机还有光器件、光传输设备<br>为电子制造、智慧交通、光通信等提供解决方案<br>测试工作职责：制定测试计划、编写测试用例、搭建测试环境、开发测试工具等，那么这里的测试，主要对于什么进行测试？</p><p>做测试，日常一天或者是一周的工作如何进行的？<br>有一个新项目时，作为测试，工作如何展开的？</p><h2 id="交通银行-软件测试"><a href="#交通银行-软件测试" class="headerlink" title="交通银行-软件测试"></a>交通银行-软件测试</h2><p>1.负责对接业务部门的测试工作，制定全年测试计划，组织实施对应信息系统的测试工作；<br>2.负责测试环境的业务参数配置和批处理执行工作；审核分析测试需求，参与软件设计评审、测试方案评审，提前开展静态测试；<br>3.收集产品质量需求，参与产品质量需求评审，制定验收标准、产品质量度量目标与指标，制定项目测试计划，确定并跟踪项目目标；<br>4.确定测试策略，组织编写测试大纲和测试案例并开展相关评审工作；准备测试数据，分配测试资源，实施测试；组织编写用户操作手册，配合完成产品、系统的投产上线，协助做好投产后的用户支持工作；<br>5.组织开展项目测试回顾总结，持续开展测试过程改进，建设和维护测试案例等测试资产库；持续跟踪、分析测试相关生产问题，协助完成生产问题的验证；<br>6.关注研究国内外先进测试理论、测试技术和测试工具，规划并组织测试管理平台和自动化测试工具的建设推广，为集团提供测试体验服务。<br>该方向主要招聘部门：测试中心（工作地点：上海）、数据中心（工作地点：上海），总行金融科技相关部门间可以调剂。</p><h2 id="还找了其他哪些公司"><a href="#还找了其他哪些公司" class="headerlink" title="还找了其他哪些公司"></a>还找了其他哪些公司</h2><p>公司的选择，我首先是按照地点，主要是在苏州、南京、上海这里找。<br>工业控制相关的公司、互联网公司，尽量找和自己所学方向相符的；<br>苏州：凌云光、同元软控、达梦、迈为科技、科大讯飞<br>南京：亚控科技、浩鲸科技<br>上海：bilibili、奇安信、电信</p><h2 id="为什么选择苏州？"><a href="#为什么选择苏州？" class="headerlink" title="为什么选择苏州？"></a>为什么选择苏州？</h2><p>家在江苏，所以更偏向在江苏地带发展；<br>苏州作为新一线城市，机会比较多，薪资也不错，是一个适合锻炼闯荡的地方；而且如果合适的话，我和家里人都希望就在苏州安定下来了。</p><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><p>测试人员发展方向：<br>A. 管理岗位：功能测试-&gt; 测试组长-&gt;测试主管-&gt;高级测试主管/测试经理-&gt;项目经理-&gt;制作人<br>B. 技术岗位：功能测试-&gt;自动化测试/性能测试-&gt;测试主管-&gt;高级测试主管-&gt;测试总监/制作人<br>C. 跨部门：功能测试-&gt;动画/美术/程序/策划<br>我了解的测试人员的发展方向有三个,走管理岗,技术岗,或者就专职了,我目前可能更偏向于走技术岗,所以我制定了三步未来计划<br>1.先入行：先学测试理论+测试用例+python+接口测试。接口测试是黑盒测试的一种，也是比较重要比较基础的一种测试，需要首先学会。<br>2.打基础：以写测试框架、测试工具为目标，继续进行学习。加深对计算机网络、web开发、服务端开发的理解。<br>3.进阶：根据前面积累的经验，选择一个主攻方向，做做自动化或是性能测试,安全测试.</p><h2 id="找工作最看好的三个点"><a href="#找工作最看好的三个点" class="headerlink" title="找工作最看好的三个点"></a>找工作最看好的三个点</h2><p>1.工作地点：因为家在江苏，学校在上海，现在找工作更偏向苏南，离家近些也比较熟悉。<br>2.工作环境：在一个团结向上、钻研创新的团队中，更能激发自己的动力<br>3.薪资待遇：给出的薪酬也能反映一个公司的实力水平，如果单位能提供和自己能力水平相适应的薪酬待遇，我认为是一个比较好的就业单位。</p><h2 id="最大的优点和缺点"><a href="#最大的优点和缺点" class="headerlink" title="最大的优点和缺点"></a>最大的优点和缺点</h2><p>优点：我觉得做事比较有条理，我喜欢对事物进行分类，在生活上把各个物品分门别类，在工作上把文件、项目又或者是知识点分类总结；这样能在一定程度上提升自己的工作效率。</p><blockquote><p>①能合理安排时间，比如自己在以前的工作中，每天下班前会提前安排一下第二天的工作，这样就算事情再多也能及时的完成，不至于到处抓瞎，总在救火。<br>②对任何事情会尽心尽力完成，比如给自己制定了减肥的目标减十斤，会将它分成阶段性的计划第一个月减5斤，第二月减5斤，然后根据饮食、运动两个方面来规划每周运动情况及饮食情况，最终完成了这个目标，体现自己的目标感很强，针对目标会全力以赴。<br>③做事有条理性，比如办工作、文件或者家里的收拾仅仅有条等，这样能让自己养成分类管理的好习惯，能提高自己的工作效率。<br>④发现问题会主动的解决。在发现问题后能积极想办法解决，如果无法解决的会及时求助同事或者领导帮来解决的，这里最好举一个实际的例子。</p></blockquote><p>缺点：做事比较急躁，在同时有几件事的时候想要尽快把这些事都完成，当有事没完成的时候，有时会比较焦躁。所以针对这个问题，我通常会制定一个粗略的每日计划，分时段完成各个事情，为每件事定个小目标，有目的的干活能让我更有动力，有充实感，能很大程度上减轻我的焦躁感，不会那么急躁。</p><h2 id="遇到的最大的困难？"><a href="#遇到的最大的困难？" class="headerlink" title="遇到的最大的困难？"></a>遇到的最大的困难？</h2><p>在做智能防凝露系统的项目的时候，后期要求使用电厂专用的通信协议61850来上传系统数据。这个协议与各种高压设备紧密联系，整体复杂度很高，所涉及的知识是之前没有接触过的，总体实现起来难度较大。<br>对于这类全新问题，我会先去搜索基本概念和介绍，背景、用处是什么，有一个基本认知。然后就是深入了解，这里的话首先要了解如何学习，制定相关计划，可以通过论坛、官网、或者是视频学习。然而61850协议在网上的资料很少，只有一些概念的介绍，没有系统教程，没有实际案例，于是我就去找相关书籍和论文，书本对与61850的介绍虽然不充分，但对于深入了解整体框架还是足够的。学习完有了明确了解后，再去找找实际的demo，通过demo运行来了解实际效果。之后就可以制定初步的实施计划，像规约解读、建模、网络通信等部分分工，按计划进行下去，后期再不断修改完善。</p><p>对于这个问题，在完全不了解的情况下，我会先去搜索基本概念和介绍，背景、用处是什么，有一个基本认知。然后就是深入了解，这里的话首先要了解如何学习，制定相关计划，可以通过论坛、官网、或者是视频学习。然而61850协议在网上的资料很少，只有一些概念的介绍，没有系统教程，没有实际案例，那么前面说的学习方法就想不通了。所以在搜寻无果之后，我就去找找有没有相关论文或者是书籍，一些综述性论文还有书籍对于新手学习还是很有帮助的。还好，虽然少，但还是找到了一本介绍61850的书。这里主要还是对协议的整体框架有了更充分的理解，知道每一步该怎么走。接下来我就会去找实例，最好有个demo，看看运行效果如何。我找到了一个关于61850的库，也有相关demo。那么问题就可以简化了，通信手段有了，接下来就需要准备传输的内容，也就是建模。这也是最关键的部分。建模这部分从书里可以知道，是根据标准规约实现的。于是下一步就是与规约的解读。规约内容非常多，完全看完要很久，于是我第一遍粗度，把认为和建模有关联的内容以关键词+概要的形式记录下来，然后根据记录的内容再回头一遍遍细读，不断记录新收获，慢慢理清了建模流程。</p><h2 id="遇到的最大挫折？"><a href="#遇到的最大挫折？" class="headerlink" title="遇到的最大挫折？"></a>遇到的最大挫折？</h2><p>在做智能防凝露系统时，读取数据库数据的过程中，发现数据读取的特别慢，而找出的原因就是读取时间范围太长，数据量太大；在搜索很长时间后，依然没有一个很好的解决办法，最后不得已，只能重新建了一张专门用于读取历史数据的表，造成了冗余。<br>后期我也反思了自己的解决过程。一个是对于数据库的理解不够，当时是我初次接触mysql，因为要直接应用，时间较短，所以准备工作只是通过视频学习了mysql的工程应用，对于理论的研究不够深入；还有第二个因素是对于问题的解决办法没有深入了解，在探明是数据量太大导致的问题后，直接去查询如何通过sql语句来解决，但是实际上，这个问题其实是可以通过设计表结构来解决的。这也是我在后期学习过程中慢慢了解的内容。</p><h2 id="取得的最大成就？"><a href="#取得的最大成就？" class="headerlink" title="取得的最大成就？"></a>取得的最大成就？</h2></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div></div><div>https://haochendaily.com/mian-jing-wen-da.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>laser</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年9月29日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/network-communications-3.html" title="Linux网络通信基础（3）"><span class="hidden-mobile">Linux网络通信基础（3）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.17/Valine.min.js",(function(){var i=Object.assign({appId:"TSl5PlExO22wiwkA3e15kGvM-gzGzoHsz",appKey:"36AERjunsq15rL0xcz3ovKbG",path:"window.location.pathname",placeholder:"尽情吐槽吧~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>