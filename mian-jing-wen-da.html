<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/cell-32x32-next.png"><link rel="icon" href="/img/cell-32x32-next.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="laser"><meta name="keywords" content=""><meta name="description" content="c++struct结构体   - 结构体(struct)：是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。      与class的区别：    - 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。    - class 继承默认是 private 继承，而 struct 继承默认是 publ"><meta property="og:type" content="article"><meta property="og:title" content="haochenBlog"><meta property="og:url" content="https://haochendaily.com/mian-jing-wen-da.html"><meta property="og:site_name" content="haochenBlog"><meta property="og:description" content="c++struct结构体   - 结构体(struct)：是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。      与class的区别：    - 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。    - class 继承默认是 private 继承，而 struct 继承默认是 publ"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-09-17T06:23:42.969Z"><meta property="article:modified_time" content="2022-09-21T06:20:22.550Z"><meta property="article:author" content="laser"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><title>haochenBlog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"haochendaily.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"C"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="haochenBlog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>EASY</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/wallpaper_img/wallhaven-72ywpv_1920x1080.1t8ds73xt2yo.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text=""></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-09-17 14:23" pubdate>2022年9月17日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 71 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none"></h1><div class="markdown-body"><h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h2 id="struct结构体"><a href="#struct结构体" class="headerlink" title="struct结构体"></a>struct结构体</h2><pre><code class="hljs">   - 结构体(struct)：是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。
     与class的区别：
   - 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
   - class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
   - class 可以使用模板，而 struct 不能。
</code></pre><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><pre><code class="hljs">    预处理：将头文件内容复制到源代码中、删除注释、对宏进行替换等
    编译：将源代码转换为汇编代码
    汇编：将汇编代码转换为机器码
    链接：链接目标代码、其他目标代码、启动代码等生成可执行文件。

&gt; 编译能使用gcc/g++，因为在编译阶段g++能自动调用gcc，两者等价；但gcc不能进行库连接，所以链接用g++或gcc -lstdc++。
</code></pre><h2 id="c-特性-封装继承多态"><a href="#c-特性-封装继承多态" class="headerlink" title="c++特性-封装继承多态"></a>c++特性-封装继承多态</h2><pre><code class="hljs">封装：隐藏对象的属性和实现细节，仅仅对外提供接口和方法

继承：让某种类型对象获得另⼀个类型对象的属性和⽅法。实现继承、接口继承

多态：同一事物对不同对象表现出不同的能力，允许将⼦类类型的指针赋值给⽗类类型的指针。重载overload，编译时的多态；覆盖override，运行时的多态
</code></pre><h2 id="c-常用容器"><a href="#c-常用容器" class="headerlink" title="c++常用容器"></a>c++常用容器</h2><pre><code class="hljs">vector、list、deque、set、map等，⽤来存放数据
</code></pre><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单链表判断是否有环，找到入环节点，优化"><a href="#单链表判断是否有环，找到入环节点，优化" class="headerlink" title="单链表判断是否有环，找到入环节点，优化"></a>单链表判断是否有环，找到入环节点，优化</h2><pre><code class="hljs">（1）用set存放以及遍历过的链表
（2）快慢指针
</code></pre><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><pre><code class="hljs">在c++ STL中属于容器适配器，底层实现一般是deque.
栈stack是先进后出，队列queue是先进先出。
</code></pre><h2 id="排序方法的了解"><a href="#排序方法的了解" class="headerlink" title="排序方法的了解"></a>排序方法的了解</h2><pre><code class="hljs">冒泡排序、选择排序、插入排序、希尔排序、快速排序、堆排序、归并排序、基数排序、桶排序、计数排序
</code></pre><h2 id="快排思路"><a href="#快排思路" class="headerlink" title="快排思路"></a>快排思路</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Paritition1</span>(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high) {<br>  <span class="hljs-type">int</span> pivot = A[low];<br>  <span class="hljs-keyword">while</span> (low &lt; high) {<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) {<br>      --high;<br>    }<br>    A[low] = A[high];<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) {<br>      ++low;<br>    }<br>    A[high] = A[low];<br>  }<br>  A[low] = pivot;<br>  <span class="hljs-keyword">return</span> low;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//快排母函数</span></span><br><span class="hljs-function"></span>{<br>  <span class="hljs-keyword">if</span> (low &lt; high) {<br>    <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Paritition1</span>(A, low, high);<br>    <span class="hljs-built_in">QuickSort</span>(A, low, pivot - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">QuickSort</span>(A, pivot + <span class="hljs-number">1</span>, high);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="用两个栈模拟队列："><a href="#用两个栈模拟队列：" class="headerlink" title="用两个栈模拟队列："></a>用两个栈模拟队列：</h2><p>push时直接加入到栈中，pop时，当栈2为空时，栈1内容全部放到2中，再pop;当栈2不为空，栈2直接pop;</p><h2 id="数据结构，栈和队列的区别"><a href="#数据结构，栈和队列的区别" class="headerlink" title="数据结构，栈和队列的区别"></a>数据结构，栈和队列的区别</h2><pre><code class="hljs">队列可两端操作，栈只能操作栈顶；栈先进后出，队列先进先出；
</code></pre><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="python三目运算符"><a href="#python三目运算符" class="headerlink" title="python三目运算符"></a>python三目运算符</h2><pre><code class="hljs">max = a if a&gt;b else b
</code></pre><h2 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h2><pre><code class="hljs">文本：str
数值：int float 
序列：list （list append del）
布尔类型：bool
二进制：bytes
</code></pre><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="get和post区别："><a href="#get和post区别：" class="headerlink" title="get和post区别："></a>get和post区别：</h2><table><thead><tr><th align="center">get</th><th align="center">post</th></tr></thead><tbody><tr><td align="center">获取指定资源</td><td align="center">根据请求体处理指定资源</td></tr><tr><td align="center">参数在URL中，有长度和ASCALL格式限制</td><td align="center">参数在body中，无长度和格式限制</td></tr><tr><td align="center">get请求可缓存</td><td align="center">请求不可缓存</td></tr><tr><td align="center">安全（不破坏服务器资源）幂等（无论请求多少次结果相同）</td><td align="center">不安全，不幂等</td></tr></tbody></table><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><pre><code class="hljs">TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。
</code></pre><h2 id="TCP、UDP不同点"><a href="#TCP、UDP不同点" class="headerlink" title="TCP、UDP不同点"></a>TCP、UDP不同点</h2><pre><code class="hljs">TCP需要建立双方连接，是一对一通信；UDP无需连接，可以一对一、一对多、多对多通信
TCP传输是可靠的，UDP不可靠
TCP有拥堵控制、流量控制；UDP没有，发送速率不受影响
TCP首部可变，UDP首部固定
TCP是流式传输，UDP是以数据包的形式发送
TCP数据如果超过MSS，会在传输层分片；UDP如果超过MTU会在IP层进行分片
</code></pre><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><pre><code class="hljs">双方处于close状态。服务器端开启监听进入LISTEN状态；客户端发送含有SYN标志的报文，进入SYN_SENT状态；服务端收到报文进入SYN_RCVD状态，并发送含有SYN和ACK的报文给客户端；客户端接收到后进入ESTABLISHED状态，并发送ACK报文；服务端接收后也进入ESTABLISHED状态。
</code></pre><h2 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h2><pre><code class="hljs">1.避免历史连接
2.同步双方初始序列号
</code></pre><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><pre><code class="hljs">IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据
同步：阻塞、非阻塞、IO多路复用、信号驱动
异步：异步IO
</code></pre><h2 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><pre><code class="hljs">select: 将已连接的socket放到一个文件描述符集合中，把这个集合复制给内核，内核遍历检查是否有事件发生，标记事件；内核将标记后的整个集合复制给用户，用户遍历检查集合，处理发生的事件

poll: 区别了用户检测事件和内核检测事件，把要检测的事件和实际发生的事件放在了一个结构体里，弥补了select每次循环要重置fds集合的缺点。此外因为poll文件描述符集合用的是结构体，所以没有了数量限制。

epoll:
    1. epoll在内核中使用红黑树追踪所有待检测的socket，每次有新的socket只需加入红黑树，不用整体复制。
    2. 每次返回的只是发生事件的socket个数，将发生事件的socket和事件类型保存在了events中。
</code></pre><h2 id="进程间通信方式："><a href="#进程间通信方式：" class="headerlink" title="进程间通信方式："></a>进程间通信方式：</h2><pre><code class="hljs">管道：传输数据是单向的，先进先出，一端读一端写。
消息队列：保存在内核中的消息链表；
共享内存：就是拿出一块虚拟地址空间来，映射到相同的物理内存中。
信号量：防止多进程引起的资源混乱，保证任何时刻只有一个进程访问共享资源。
信号：对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。
socket: 跨网络与不同主机上的进程之间通信。
</code></pre><h2 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h2><pre><code class="hljs">死锁：两个线程都在等待对方释放锁。
防止死锁:按序获得资源.
</code></pre><h2 id="乐观锁与悲观锁："><a href="#乐观锁与悲观锁：" class="headerlink" title="乐观锁与悲观锁："></a>乐观锁与悲观锁：</h2><pre><code class="hljs">悲观锁：多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。
乐观锁：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。
</code></pre><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux操作指令"><a href="#Linux操作指令" class="headerlink" title="Linux操作指令"></a>Linux操作指令</h2><pre><code class="hljs">cat：将多个文件拼接后输出；more：显示文本内容，一次一屏；less：与more类似，可翻页；head;tail;
greap:查找文件中的字符串
cp:复制； rm：删除文件或目录    mv：移动或重命名
wc:统计给定文件中的字数、行数、字节数
find   path   -option :指定目录下查找文件
pwd: 查看“当前所在目录”的完整路径
mkdir:创建目录
ln: 链接文件或目录 -s 软链接 不加 硬链接
</code></pre><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>关键字执行顺序<br>(7) SELECT<br>(8) DISTINCT<select_list><br>(1) FROM<left_table><br>(3)<join_type>JOIN<right_table><br>(2) ON<join_condition><br>(4) WHERE<where_condition><br>(5) GROUP BY<group_by_list><br>(6) HAVING<having_condition><br>(9) ORDER BY<order_by_condition><br>(10) LIMIT<limit_number></limit_number></order_by_condition></having_condition></group_by_list></where_condition></join_condition></right_table></join_type></left_table></select_list></p><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><pre><code class="hljs">内连接只显示符合连接条件的记录，外连接除了显示符合条件的记录外，还显示表中其他的记录
使用JOIN
内连接：
    INERT JOIN：返回两张表的交集
外连接：
    LEFT JOIN:以左表为基准，返回左表加上右表中与左表共同的部分
    RIGHT JOIN：相反
    FULL JOIN：全外连接是在结果中除了显示满足连接的条件的行外，还显示了join两侧表中所有满足检索条件的行
</code></pre><h2 id="事务的特性："><a href="#事务的特性：" class="headerlink" title="事务的特性："></a>事务的特性：</h2><pre><code class="hljs">原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态。
一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。
持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？
持久性是通过 redo log （重做日志）来保证的；
原子性是通过 undo log（回滚日志） 来保证的；
隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
一致性则是通过持久性+原子性+隔离性来保证；
</code></pre><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><pre><code class="hljs">脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。
不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。
幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。
</code></pre><h2 id="隔离级别（从低到高）"><a href="#隔离级别（从低到高）" class="headerlink" title="隔离级别（从低到高）"></a>隔离级别（从低到高）</h2><pre><code class="hljs">读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；
读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；
可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；
串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="单元测试、集成测试、系统测试、验收测试、回归测试："><a href="#单元测试、集成测试、系统测试、验收测试、回归测试：" class="headerlink" title="单元测试、集成测试、系统测试、验收测试、回归测试："></a>单元测试、集成测试、系统测试、验收测试、回归测试：</h2><pre><code class="hljs">单元测试：对程序最小模块单元进行测试。可平行测试。包括：模块接口测试、局部数据结构测试、路径测试、错误处理测试、边界测试。
集成测试：对程序模块进行组合递增测试，重点测试模块的接口部分。包括：模块之间数据传输、组合起来功能是否正确、全局数据结构是否被异常修改、单模块缺陷对整体的影响
系统测试：对整个软件系统进行测试。包括：功能、性能、兼容性、界面等进行测试。
验收测试：向软件购买者展示软件系统，按照用户需求来测。
回归测试：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。
</code></pre><h2 id="测试方法有什么？"><a href="#测试方法有什么？" class="headerlink" title="测试方法有什么？"></a>测试方法有什么？</h2><pre><code class="hljs">测试方法主要有两大类，白盒测试和黑盒测试。
白盒测试：检查程序的内部结构、逻辑、循环和路径。有语句覆盖、判定覆盖、条件覆盖等等。
黑盒测试：检测每个功能是否都能正常使用。等价类、边界值、因果图、判定表、场景法、流程分析法、错误推断发、正交法
</code></pre><h2 id="黑盒测试分类"><a href="#黑盒测试分类" class="headerlink" title="黑盒测试分类"></a>黑盒测试分类</h2><pre><code class="hljs">功能测试：
    * 逻辑功能测试
    * 界面测试
    * 易用性测试
    * 安装测试
    * 兼容性测试
性能测试：
    * 时间性能（响应时间）
    * 空间性能（系统资源）
    * 稳定性测试
    * 负载测试
    * 压力测试
</code></pre><h2 id="冒烟测试："><a href="#冒烟测试：" class="headerlink" title="冒烟测试："></a>冒烟测试：</h2><pre><code class="hljs">冒烟测试是在软件开发过程中的一种针对软件版本包的快速基本功能验证策略，是对软件**基本功能进行确认验证的手段**，并非对软件版本包的深入测试。
所以冒烟测试的主要目的就是看这个软件是否具备可测性，也叫做可测性测试。
</code></pre><h2 id="测试用例考虑方向："><a href="#测试用例考虑方向：" class="headerlink" title="测试用例考虑方向："></a>测试用例考虑方向：</h2><pre><code class="hljs">测试用例主要解决的问题是要测什么？怎么测？
</code></pre><h2 id="测试用例要素："><a href="#测试用例要素：" class="headerlink" title="测试用例要素："></a>测试用例要素：</h2><pre><code class="hljs">测试编号、测试项目（模块）、前提条件、测试输入、预期输出、操作步骤、实际结果、标题、级别
</code></pre><h2 id="编写测试用例方法"><a href="#编写测试用例方法" class="headerlink" title="编写测试用例方法"></a>编写测试用例方法</h2><pre><code class="hljs">- 等价类法：对输入集合合理分类，从每个类中取出少数代表性用例。有有效等价类和无效等价类。
- 边界值：取等价类中的边界情况，稍高及稍低。
- 因果图：利用图解法，考虑输入条件的组合制约关系、输出对输入的依赖关系
- 判定表：因果图的最终形式。条件桩：问题所有条件；动作桩：问题所有输出。
- 场景法：模拟用户操作场景，测试系统业务流程。有基本流和备选流。
- 流程分析法：对系统每个流程进行测试
- 错误推断法：利用直觉和经验猜测出错可能类型。
- 正交排列法：根据正交性从全面试验挑选部分代表性的点。基于正交表
</code></pre><h2 id="测试结束的标准是什么？"><a href="#测试结束的标准是什么？" class="headerlink" title="测试结束的标准是什么？"></a>测试结束的标准是什么？</h2><pre><code class="hljs">全部测试用例都被执行完成
未修改bug都被确认或置为应有状态，暂缓修改的问题都有详尽的解析
测试报告编写完成
测试收尾工作结束
测试总结完成
项目处于试运行或上线阶段
在测试计划中定义结束的标准：在一定性能下平稳运行多少天、本版本没有严重bug，普通bug数量在多少个以下，bug修复百分之多少以上；
实际测试达到上述要求，由项目、开发、测试经理共同签字，认同测试结束，版本即可发布。
</code></pre><h2 id="从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法"><a href="#从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法" class="headerlink" title="从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法"></a>从测试工程师的角度，详细描述抽奖类功能关于概率方面的测试方法</h2><pre><code class="hljs">对于抽奖的概率类问题，QA是不可能去抽几十万次甚至上百万次来验证概率问题，这时就要从其他角度来验证其正确性。
首先，可以从白盒测试的角度，对底层算法原理和代码实现方面进行验证；
其次，可以从自动化测试的角度，使用自动化脚本来模拟抽卡，来验证概率的正确性。
</code></pre><h2 id="测试的目的"><a href="#测试的目的" class="headerlink" title="测试的目的"></a>测试的目的</h2><pre><code class="hljs">发现软件中存在的缺陷；
软件是否符合设计要求；
软件是否符合技术要求；
对软件进行验证和质量评估；
</code></pre><h2 id="测试用例的优先级"><a href="#测试用例的优先级" class="headerlink" title="测试用例的优先级"></a>测试用例的优先级</h2><pre><code class="hljs">用于标识测试用例的重要性和执行频率，共分为4级，由高至低依次为P0-P3。
P0：核心功能测试用例（冒烟测试），确定此版本是否可测的测试用例，此部分测试用例如果fail会阻碍大部分其他测试用例的验证。
P1：高优先级测试用例，最常执行以保证功能性是稳定的；基本功能测试，和重要的错误、边界测试
P2：中优先级测试用例，更全面地验证功能的各个方面，异常测试，边界、中断、断网、容错、UI等测试用例
P3：低优先级测试用例，不常常被执行，性能、压力、兼容性、稳定性、安全、可用性等等。
</code></pre><h2 id="bug的严重级别和优先级"><a href="#bug的严重级别和优先级" class="headerlink" title="bug的严重级别和优先级"></a>bug的严重级别和优先级</h2><pre><code class="hljs">严重级别：
    Blocker(崩溃)：内存泄漏、用户数据丢失等，需要立即终止当前版本测试；
    Critiacl(严重)：功能未实现，数值错误等，不影响其他功能测试；
    Major(一般)：边界条件错误等，不影响使用；
    Minor(次要)：格式不规范，排版问题等，可进行优化；
优先级：
    Immediate:马上解决
    Urgent:急需解决，
    High:高度重视，有时间就要解决
    Normal:正常处理；计划解决
</code></pre><h2 id="如何记录BUG"><a href="#如何记录BUG" class="headerlink" title="如何记录BUG"></a>如何记录BUG</h2><pre><code class="hljs">BUG摘要：简单描述BUG
BUG的具体描述：把测试步骤和具体数据都写出来，尽可能多的提供信息
BUG严重程度
BUG优先级
BUG指派给谁
截图附件
</code></pre><h2 id="测试人员的职责"><a href="#测试人员的职责" class="headerlink" title="测试人员的职责"></a>测试人员的职责</h2><pre><code class="hljs">我觉得这个问题可以归结为测试的目的：发现BUG、设计要求、技术要求、验证与质量评估
</code></pre><h2 id="测试结束的标准是什么？-1"><a href="#测试结束的标准是什么？-1" class="headerlink" title="测试结束的标准是什么？"></a>测试结束的标准是什么？</h2><pre><code class="hljs">缺陷修复率标准：
1) 一、二级错误修复率应达到100%
2) 三级错误修复率应达到80%以上
3) 四级错误修复率应达到60%以上

覆盖率标准：
语句覆盖率最低不能小于80%
测试用例执行覆盖率应达到100%
测试需求覆盖率应达到100%
</code></pre><h2 id="性能测试关注的指标"><a href="#性能测试关注的指标" class="headerlink" title="性能测试关注的指标"></a>性能测试关注的指标</h2><pre><code class="hljs">系统指标：
    响应时间：对一个请求做出响应的时间；（平均响应时间、90%响应时间）
    系统处理能力：
        HPS：每秒发起的请求次数
        TPS：每秒处理事务次数
        QPS：每秒处理查询次数
    吞吐量：系统在单位时间内处理请求的数量
    并发用户数：同一时刻与服务器交互的用户数
    错误率(FR)：一批请求中结果出错的请求所占比例。
资源性能指标：
    CPU利用率
    内存利用率
    磁盘吞吐量：单位时间内通过磁盘的数据量
    网络吞吐量：单位时间内通过网络的数据量
</code></pre><h2 id="测试输入1-100，怎么设计测试用例"><a href="#测试输入1-100，怎么设计测试用例" class="headerlink" title="测试输入1-100，怎么设计测试用例"></a>测试输入1-100，怎么设计测试用例</h2><pre><code class="hljs">先划分等价类：
    有效等价类：1-100
    无效等价类：小于1；大于100；小数；特殊字符；字母；中文；空格
再取边界值：
    0，1，2；99，100，101
</code></pre><h2 id="自动化测试了解"><a href="#自动化测试了解" class="headerlink" title="自动化测试了解"></a>自动化测试了解</h2><pre><code class="hljs">避免重复操作、人力难以测试的操作、耗时操作
</code></pre><h2 id="程序员、策划对测试人员提交的缺陷修改不及时，怎么办？"><a href="#程序员、策划对测试人员提交的缺陷修改不及时，怎么办？" class="headerlink" title="程序员、策划对测试人员提交的缺陷修改不及时，怎么办？"></a>程序员、策划对测试人员提交的缺陷修改不及时，怎么办？</h2><pre><code class="hljs">方法一：死缠烂打，效果比较明显。经常去烦他，他受不了就会去看你提交的缺陷。
方法二：找自身的原因，是否每次你提交的缺陷描述，人家都能正确的重现问题。有时不是别人不想改，只是看了一下没看懂，不想花时间。
方法三：私下与自己配合的人员把关系搞好，有啥问题好沟通，好基友么，有啥都好商量。
方法四：向上级汇报。如果你真碰到了那种工作没积极性，不好好配合，也不好沟通的人。没有啥不好意思的，你这样被拖着，只会影响自己的工作。
</code></pre><h2 id="测试人员提交的bug被否定，怎么办？"><a href="#测试人员提交的bug被否定，怎么办？" class="headerlink" title="测试人员提交的bug被否定，怎么办？"></a>测试人员提交的bug被否定，怎么办？</h2><pre><code class="hljs">第一次被否定，找相关的负责人再沟通下，如果还确认是问题，请看下面
多思考下自己提交的是不是真的问题。如果确认是问题，请坚持一会。但不要太久，游戏原本就是制定一个规则，但里面有时，真的没有真正的对错。
如果真是问题，那出现的几率是多少？如果真的几率太低的话，就放一放吧，等后面再出现，再让负责人来修改。不要被一个问题卡住
</code></pre><h2 id="铅笔测试："><a href="#铅笔测试：" class="headerlink" title="铅笔测试："></a>铅笔测试：</h2><p>功能测试<br>1.铅笔的长度和生产要求是否一致<br>2.铅笔的宽度是否和生产要求一致<br>3.铅笔在不同的纸上显色度是否符合要求<br>4.铅笔的笔芯粗细是否符合生产要求<br>5.铅笔是否容易折断<br>6.铅笔的笔芯是否容易断<br>7.铅笔是否容易被铅笔刀削<br>8.铅笔是否容易变形<br>9.铅笔长时间放置后是否还能继续使用<br>10.铅笔被水泡以后是否还能继续使用<br>11.在高温的情况下是否可以写出字<br>12.在低温的情况下是否可以写出字<br>13.铅笔的形状是否符合生产要求<br>14.长时间使用手是否会起茧<br>15.铅笔携带的字遇到水是否会消失</p><p>性能<br>1.铅笔的硬度是否达标<br>2.铅笔从多高的地方摔下去笔芯不会摔断<br>3.震动测试笔在包装时，各面震动，检查是否能应对恶劣的公路、铁路、航空运输。<br>4.多大的力气可以把铅笔折断<br>5.铅笔的笔尖在多大的压力下可以写字<br>6.压力测试:铅笔的笔尖在多大压力下会折断<br>7.铅笔字迹能保留多久。<br>8.笔杆的图案能保持多久不被磨掉</p><p>兼容性<br>1.铅笔是否可以在不同的纸上，地上，石头上，墙上写字，玻璃上，衣服上<br>2.在不同的温度下是否可以写字</p><p>安全性<br>1.铅笔的材料无毒，符合生产要求<br>2.铅笔是否会释放出有毒的气味<br>3.误食笔芯会不会中毒<br>4.当铅笔被扔掉后会不会对环境造成污染</p><p>界面测试<br>1.铅笔的样式符合大众要求<br>2.铅笔的图案合法<br>3.铅笔的logo是否正确<br>4.铅笔的外壳颜色是否符合要求</p><p>易用性<br>1.铅笔写字流畅<br>2.铅笔用铅笔刀削起来容易<br>3.铅笔芯不容易断<br>4.铅笔显色度好<br>5.是否容易携带和存放</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="高压开关柜智能防凝露系统"><a href="#高压开关柜智能防凝露系统" class="headerlink" title="高压开关柜智能防凝露系统"></a>高压开关柜智能防凝露系统</h2><p>​ 这个项目属于工业控制系统；系统是在各个开关柜上方接入送风管道，管道会送入经系统处理过的干净干燥而且温度适宜的空气送入开挂柜内，然后又由于空气压力作用，会把柜内潮湿空气和灰尘通过另一个回风管道排除柜体，送至防凝露主机设备，经过过滤网、处理器把灰尘和空气中的水分离出来，在把空气加热送入送风管道内，形成不断循环的闭环系统。控制系统就是控制各个机器的运转像管道内的风阀、风机、又或者是加热器等，也监控系统各个位置的状态。主要控制逻辑在下位机主板实现，上位机是用于可视化监控以及实现手动控制的功能。我做的工作主要是上位机部分，也就是可视化设计，开发平台是QT，语言用的是c++，数据是从数据库读入，实现实时与历史数据的展示。</p><h2 id="基于Linux的轻量级Web服务器"><a href="#基于Linux的轻量级Web服务器" class="headerlink" title="基于Linux的轻量级Web服务器"></a>基于Linux的轻量级Web服务器</h2><p>​ 这个项目是自己用业余时间学习的一个开源项目；实现的功能就是简单的浏览器对服务器主页的访问的功能，同时支持客户端的并发访问。项目使用reactor模式进行设计，由主线程负责监听事件与数据的接收与发送，从线程池中选取一个子线程来处理业务。当监听到有新的连接，主线程会把它加入到epoll中；当监听到新的事件，主线程会调用read函数接收数据，然后子线程对请求进行解析生成对应的响应；由主线程负责发送出去。</p><h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><h2 id="项目遇到的问题，遇到困难怎么解决"><a href="#项目遇到的问题，遇到困难怎么解决" class="headerlink" title="项目遇到的问题，遇到困难怎么解决"></a>项目遇到的问题，遇到困难怎么解决</h2><p>​ 印象最深的问题就是数据库读取问题。在上位机中有个曲线显示，需要有历史数据显示，当需要显示历史半年一年数据的时候，需要耗时一秒多，这明显属于慢查询。</p><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><pre><code class="hljs">测试人员发展方向：
A. 管理岗位：功能测试-&gt; 测试组长-&gt;测试主管-&gt;高级测试主管/测试经理-&gt;项目经理-&gt;制作人
B. 技术岗位：功能测试-&gt;自动化测试/性能测试-&gt;测试主管-&gt;高级测试主管-&gt;测试总监/制作人
C. 跨部门：功能测试-&gt;动画/美术/程序/策划 
我了解的测试人员的发展方向有三个,走管理岗,技术岗,或者就专职了,我目前可能更偏向于走技术岗,所以我制定了三步未来计划
1.先入行：先学测试理论+测试用例+python+接口测试。接口测试是黑盒测试的一种，也是比较重要比较基础的一种测试，需要首先学会。
2.打基础：以写测试框架、测试工具为目标，继续进行学习。加深对计算机网络、web开发、服务端开发的理解。
3.进阶：根据前面积累的经验，选择一个主攻方向，做做自动化或是性能测试,安全测试.
</code></pre></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div></div><div>https://haochendaily.com/mian-jing-wen-da.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>laser</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年9月17日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/network-communications-3.html" title="Linux网络通信基础（3）"><span class="hidden-mobile">Linux网络通信基础（3）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.17/Valine.min.js",(function(){var i=Object.assign({appId:"TSl5PlExO22wiwkA3e15kGvM-gzGzoHsz",appKey:"36AERjunsq15rL0xcz3ovKbG",path:"window.location.pathname",placeholder:"尽情吐槽吧~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>