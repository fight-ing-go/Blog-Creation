<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/cell-32x32-next.png"><link rel="icon" href="/img/cell-32x32-next.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="laser"><meta name="keywords" content=""><meta name="description" content="进程概述进程是正在运行的程序的实例。是操作系统动态执行的基本单元。在传统操作系统中，进程既是基本的分配单元，也是基本的执行单元。 进程间通信方式 同一主机：$$同一主机进程间通信&#x3D;\left{\begin{matrix} Unix进程间通信方式 \ System V进程间通信方式 \ POSIX进程间通信方式\end{matrix}\right.$$$$Unix进程间通信方式&#x3D;\left{\beg"><meta property="og:type" content="article"><meta property="og:title" content="Linux多进程的一些知识点"><meta property="og:url" content="https://easyboy-blog.com/multiprocess-development.html"><meta property="og:site_name" content="home-laser"><meta property="og:description" content="进程概述进程是正在运行的程序的实例。是操作系统动态执行的基本单元。在传统操作系统中，进程既是基本的分配单元，也是基本的执行单元。 进程间通信方式 同一主机：$$同一主机进程间通信&#x3D;\left{\begin{matrix} Unix进程间通信方式 \ System V进程间通信方式 \ POSIX进程间通信方式\end{matrix}\right.$$$$Unix进程间通信方式&#x3D;\left{\beg"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-07-31T14:48:25.769Z"><meta property="article:modified_time" content="2022-07-03T16:00:00.000Z"><meta property="article:author" content="laser"><meta property="article:tag" content="多进程"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><title>Linux多进程的一些知识点 - home-laser</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"easyboy-blog.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="home-laser" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>EASY</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/wallpaper_img/wallhaven-9my82x_1920x1091.5ivtqxlw8ho0.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Linux多进程的一些知识点"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-07-31 22:48" pubdate>2022年7月31日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 57 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Linux多进程的一些知识点</h1><div class="markdown-body"><h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><p>进程是正在运行的程序的实例。是操作系统动态执行的基本单元。在传统操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><ol><li>同一主机：<br>$$<br>同一主机进程间通信=\left{<br>\begin{matrix}<br>Unix进程间通信方式 \<br>System V进程间通信方式 \<br>POSIX进程间通信方式<br>\end{matrix}<br>\right.<br>$$<br>$$<br>Unix进程间通信方式=\left{<br>\begin{matrix}<br>匿名管道 \<br>有名管道 \<br>信号<br>\end{matrix}<br>\right.<br>$$<br>$$<br>System V进程间通信 、<br>POSIX进程间通信 =\left{<br>\begin{matrix}<br>消息队列 \<br>共享内存 \<br>信号量<br>\end{matrix}<br>\right.<br>$$</li><li>不同主机（网络）进程间通信：Socket<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1></li><li>管道是在内核内存中维护的缓冲器，不同操作系统大小不一定相同。</li><li>管道拥有文件的特质：读和写。匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</li><li>一个管道是一个字节流，可以从中读取任意大小的数据块。</li><li>管道传递的数据是顺序的，读出来的顺序和写入时一致。</li><li>管道的数据传递是单向的，一端写入，一端用于读取，属于半双工。</li><li>管道内数据是一次性操作，一旦被读走，就会被删掉来释放空间。</li><li>匿名管道只能在具有公共祖先的进程中使用。（因为拥有相同的文件描述符，指向的管道一致）。</li><li>管道的数据结构是环形的。</li></ol><p>（堵塞）管道<strong>读写</strong>特点：</p><ol><li>如果管道写端的文件描述符都关闭了，且管道内无数据后，再次read将会<strong>返回0</strong>，而不是堵塞。</li><li>如果管道读端的文件描述符都关闭了，这时候向管道写数据，该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。</li><li>如果管道读端的文件描述符没有关闭，且没有从管道读数据，那么在管道写满后再次write会<strong>堵塞</strong>，直到有空位置才能再次写入数据并返回。</li><li>进程启动，若只先开启读端，将会堵塞，直到读端开启。同理，若只开启写段，也会堵塞到读端开启。</li></ol><p><strong>匿名管道（pipe）</strong>：通过一个没有实体的管道，实现具有亲缘关系的进程间通信。</p><p><strong>有名管道（FIFO）</strong>：克服了匿名管道只能用于亲缘关系的进程通信。<br>有名管道提供了一个路径名与之关联，以FIFO文件形式存在于文件系统中，进程间可以访问该路径而彼此通信。</p><p>匿名有名的不同点：</p><ol><li>FIFO在文件系统中作为一个特殊文件存在，但其内容存放于内存中。</li><li>FIFO文件在进程退出后继续保存在文件系统中。</li><li>FIFO有名字，因而不相关的进程可以访问该文件进行通信。</li></ol><h1 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h1><p>kill -l: 查看系统定义的信号列表<br>信号编号-信号名-默认动作-对应事件<br>2:SIGINT：终止进程。&lt;Ctrl+C&gt;，用户终端向正在运行中的由该终端启动的程序发出此信号。<br>3.SIGQUIT：终止进程。&lt;Ctrl+\&gt;,同信号2。<br>9.SIGKILL：终止进程（可以杀死任何进程）。无条件终止进程，该信号不能被忽略，处理和阻塞。<br>11.SIGSEGV：终止进程并产生core文件。指示进程进行了无效内存访问。<br>13.SIGPIPE：终止进程。pipe向一个没有读端的管道写数据。<br>17.SIGCHIL：忽略这个信号。子进程结束时，父进程收到该信号。<br>18.SIGCONT：继续/忽略。如果进程已停止，则使其继续运行。<br>19.SIGSTOP：终止进程。停止进程的执行。该信号不能被忽略，处理和阻塞。<br>SIGKILL和SIGSTOP只能执行默认动作。</p><p>查看信号详细信息：man 7 signal<br>信号的五种默认处理动作：</p><ol><li>Term：终止进程</li><li>Ign：当前进程忽略掉这个信号</li><li>Core：终止进程并生成core文件</li><li>Stop：暂停当前进程</li><li>Cont：继续执行当前被暂停的进程<br>信号的状态：产生、未决（没有被处理的状态）、递达（信号被处理了）</li></ol><p>SIGCHLD信号产生条件：<br>* 子进程终止时<br>* 子进程接收到SIGSTOP信号停止时<br>* 子进程处在停止态，接收到SIGCONT唤醒时<br>产生的SIGCHLD信号会发送给父进程，父进程默认忽略该信号。</p><h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>两个主要信号集：<br>阻塞信号集：阻止信号响应，并不阻止产生。<br>未决信号集：还未产生响应的信号。</p><ol><li>在内核中，所有没被处理的信号存储在一个集合中，信号状态存储在第二个标志位上。标志位为0，信号不是处于未决状态；标志位为1，信号处于未决状态。</li><li>处理未决信号前，需要和阻塞信号机比较。阻塞信号集默认不阻塞任何信号，如果要阻塞，需要调用系统API。</li><li>在处理未决信号前对阻塞信号集的标志位进行查询。若没有设置阻塞，则正常处理信号；若阻塞了，信号就继续处于未决状态，直至阻塞解除。</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre class="language-hljs c"><span class="hljs-comment">// 以下五个函数控制的是用户自定义的信号集sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 清空信号集中的数据，将信号集中的所有的标志位置0</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将信号集中所有的标志位置1</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为1，表示阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为0，表示不阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 判断某个信号是否阻塞</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -set: 需要操作的数据集</span><br><span class="hljs-comment">    -signum: 需要判断哪个信号</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    0: 不阻塞</span><br><span class="hljs-comment">    1: 阻塞</span><br><span class="hljs-comment">    -1: 失败</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">kernel_sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">kernel_sigset_t</span> *oldset)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将自定义信号集中的数据设置到内核中(阻塞,解除阻塞)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -how:</span><br><span class="hljs-comment">        -SIG_BLOCK: 设置阻塞信号, 要设置的位,置1</span><br><span class="hljs-comment">        -SIG_UNBLOCK: 解除阻塞,  要解除的位,置1</span><br><span class="hljs-comment">        example: 内核默认阻塞信号集mask, 设置阻塞mask|set,再解除阻塞mask&amp;~set. 即当设置的信号一样的时候,阻塞和非阻塞的值一样</span><br><span class="hljs-comment">    -set: 用户初始化好的自定义信号集</span><br><span class="hljs-comment">    -oldset: 保存之前的信号集状态,一般为NULL</span><br><span class="hljs-comment">    return: </span><br><span class="hljs-comment">        success: return 0</span><br><span class="hljs-comment">        fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 获取内核中的未决信号集</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 信号捕捉优先使用这个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 信号捕捉</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -signum: 需要捕捉的信号的编号或宏值</span><br><span class="hljs-comment">    -act: 捕捉到信号后的处理动作</span><br><span class="hljs-comment">    -oldact: 上一次信号捕捉的设置,一般为NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction {</span><br><span class="hljs-comment">               void (*sa_handler)(int); //指向的函数指针</span><br><span class="hljs-comment">               void (*sa_sigaction)(int, siginfo_t *, void *); //不常用</span><br><span class="hljs-comment">               sigset_t sa_mask;    //临时阻塞信号集, 信号捕捉过程中,临时阻塞某些信号</span><br><span class="hljs-comment">               int sa_flags;    //0: 表示使用sa_handler处理信号  1: 表示使用sa_sigaction处理信号</span><br><span class="hljs-comment">               void (*sa_restorer)(void); //已无用,使用NULL</span><br><span class="hljs-comment">           };</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"><code class="language-hljs c"><span class="hljs-comment">// 以下五个函数控制的是用户自定义的信号集sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 清空信号集中的数据，将信号集中的所有的标志位置0</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将信号集中所有的标志位置1</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为1，表示阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为0，表示不阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 判断某个信号是否阻塞</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -set: 需要操作的数据集</span><br><span class="hljs-comment">    -signum: 需要判断哪个信号</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    0: 不阻塞</span><br><span class="hljs-comment">    1: 阻塞</span><br><span class="hljs-comment">    -1: 失败</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">kernel_sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">kernel_sigset_t</span> *oldset)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将自定义信号集中的数据设置到内核中(阻塞,解除阻塞)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -how:</span><br><span class="hljs-comment">        -SIG_BLOCK: 设置阻塞信号, 要设置的位,置1</span><br><span class="hljs-comment">        -SIG_UNBLOCK: 解除阻塞,  要解除的位,置1</span><br><span class="hljs-comment">        example: 内核默认阻塞信号集mask, 设置阻塞mask|set,再解除阻塞mask&amp;~set. 即当设置的信号一样的时候,阻塞和非阻塞的值一样</span><br><span class="hljs-comment">    -set: 用户初始化好的自定义信号集</span><br><span class="hljs-comment">    -oldset: 保存之前的信号集状态,一般为NULL</span><br><span class="hljs-comment">    return: </span><br><span class="hljs-comment">        success: return 0</span><br><span class="hljs-comment">        fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 获取内核中的未决信号集</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 信号捕捉优先使用这个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 信号捕捉</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -signum: 需要捕捉的信号的编号或宏值</span><br><span class="hljs-comment">    -act: 捕捉到信号后的处理动作</span><br><span class="hljs-comment">    -oldact: 上一次信号捕捉的设置,一般为NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction {</span><br><span class="hljs-comment">               void (*sa_handler)(int); //指向的函数指针</span><br><span class="hljs-comment">               void (*sa_sigaction)(int, siginfo_t *, void *); //不常用</span><br><span class="hljs-comment">               sigset_t sa_mask;    //临时阻塞信号集, 信号捕捉过程中,临时阻塞某些信号</span><br><span class="hljs-comment">               int sa_flags;    //0: 表示使用sa_handler处理信号  1: 表示使用sa_sigaction处理信号</span><br><span class="hljs-comment">               void (*sa_restorer)(void); //已无用,使用NULL</span><br><span class="hljs-comment">           };</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></span></pre></td></tr></tbody></table></figure><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对<strong>其他所有</strong>共享同一个段的进程可用。<br>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。<br>共享内存和内存映射的区别：</p><ol><li><p>共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)</p></li><li><p>共享内存效果更高</p></li><li><p>内存</p><p>所有的进程操作的是同一块共享内存。<br>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</p></li><li><p>数据安全</p><ul><li>进程突然退出<br>共享内存还存在内存映射区消失</li><li>运行进程的电脑死机，宕机了<br>数据存在在共享内存中，没有了<br>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</li></ul></li><li><p>生命周期</p><ul><li>内存映射区: 进程退出，内存映射区销毁</li><li>共享内存: 进程退出，共享内存还在，标记删除，或者关机</li></ul></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre class="language-hljs c"><span class="hljs-comment">//共享内存相关: 创建共享内存段-&gt;关联-&gt;操作共享内存-&gt;解除关联-&gt;删除关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 创建一个新的共享内存段,或者获取一个既有内存共享段的标识</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -key: 通过Key找到或创建一个共享内存,一般16进制</span><br><span class="hljs-comment">    -size: 共享内存的大小 </span><br><span class="hljs-comment">    -shmflg:</span><br><span class="hljs-comment">        访问权限: rwx</span><br><span class="hljs-comment">        附加属性:</span><br><span class="hljs-comment">            IPC_CREAT: 创建一个新的共享内存段</span><br><span class="hljs-comment">            IPC_EXCL: 判断共享内存是否存在,需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 返回共享内存引用的id, &gt;0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将共享内存段与当前进程进行关联</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID，由shmget获取</span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址,指定NULL,由内核指定</span><br><span class="hljs-comment">    -shmflg: </span><br><span class="hljs-comment">        SHM_RDONLY: 读权限,必须要有该权限</span><br><span class="hljs-comment">        0: 读写权限</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: 返回共享内存的首地址</span><br><span class="hljs-comment">    fail: -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 解除当前进程与共享内存的关联</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 删除共享内存, 共享内存需要删除才会消失,创建共享内存的进程被销毁对共享内存没有影响(可重复删除,因为只是标记)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID</span><br><span class="hljs-comment">    -cmd: </span><br><span class="hljs-comment">        IPC_STAT: 获取共享内存的当前状态</span><br><span class="hljs-comment">        IPC_SET: 设置共享内存状态</span><br><span class="hljs-comment">        IPC_RMID: 标记共享内存被销毁,只是标记,需要与其连接的进程全部销毁</span><br><span class="hljs-comment">    -buf: 需要设置或获取的共享内存的属性信息</span><br><span class="hljs-comment">        IPC_STAT: buf用来存储数据</span><br><span class="hljs-comment">        IPC_SET: buf中需要初始化数据,设置到内核</span><br><span class="hljs-comment">        IPC_RMID: NULL</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 根据指定的路径名和int值,生成一个共享内存key</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -pathname: 指定一个存在的路径</span><br><span class="hljs-comment">    -proj_id: int值,系统使用其中一个字节,8位</span><br><span class="hljs-comment"><code class="language-hljs c"><span class="hljs-comment">//共享内存相关: 创建共享内存段-&gt;关联-&gt;操作共享内存-&gt;解除关联-&gt;删除关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 创建一个新的共享内存段,或者获取一个既有内存共享段的标识</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -key: 通过Key找到或创建一个共享内存,一般16进制</span><br><span class="hljs-comment">    -size: 共享内存的大小 </span><br><span class="hljs-comment">    -shmflg:</span><br><span class="hljs-comment">        访问权限: rwx</span><br><span class="hljs-comment">        附加属性:</span><br><span class="hljs-comment">            IPC_CREAT: 创建一个新的共享内存段</span><br><span class="hljs-comment">            IPC_EXCL: 判断共享内存是否存在,需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 返回共享内存引用的id, &gt;0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将共享内存段与当前进程进行关联</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID，由shmget获取</span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址,指定NULL,由内核指定</span><br><span class="hljs-comment">    -shmflg: </span><br><span class="hljs-comment">        SHM_RDONLY: 读权限,必须要有该权限</span><br><span class="hljs-comment">        0: 读写权限</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: 返回共享内存的首地址</span><br><span class="hljs-comment">    fail: -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 解除当前进程与共享内存的关联</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 删除共享内存, 共享内存需要删除才会消失,创建共享内存的进程被销毁对共享内存没有影响(可重复删除,因为只是标记)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID</span><br><span class="hljs-comment">    -cmd: </span><br><span class="hljs-comment">        IPC_STAT: 获取共享内存的当前状态</span><br><span class="hljs-comment">        IPC_SET: 设置共享内存状态</span><br><span class="hljs-comment">        IPC_RMID: 标记共享内存被销毁,只是标记,需要与其连接的进程全部销毁</span><br><span class="hljs-comment">    -buf: 需要设置或获取的共享内存的属性信息</span><br><span class="hljs-comment">        IPC_STAT: buf用来存储数据</span><br><span class="hljs-comment">        IPC_SET: buf中需要初始化数据,设置到内核</span><br><span class="hljs-comment">        IPC_RMID: NULL</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 根据指定的路径名和int值,生成一个共享内存key</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -pathname: 指定一个存在的路径</span><br><span class="hljs-comment">    -proj_id: int值,系统使用其中一个字节,8位</span><br><span class="hljs-comment">*/</span><br></code></span></pre></td></tr></tbody></table></figure><h1 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程组是一组相关进程的集合。</li><li>进程组由一个或多个共享同一进程组标识符(PGID)的进程组成。</li><li>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID，新进程</li><li>会继承其父进程所属的进程组ID。</li><li>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。</li><li>进程组首进程无需是最后一个离开进程组的成员。<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2></li><li>会话是一组进程组的集合。</li><li>会话首进程是创建该新会话的进程，其进程ID 会成为会话 ID。新进程会继承其父进程的会话ID。</li><li>一个会话中的所有进程共享<strong>单个</strong>控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li><li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li><li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li></ul><p>#守护进程（Daemon 进程）<br>也称精灵进程，是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端且周期性执行某种任务或等待处理某些事件，名字一般以d结尾，如Internet服务器inetd,Web服务器httpd。</p><ul><li>生命周期长，在系统启动的时候就被创建并一直运行至系统关闭。</li><li>后台运行且没有控制终端，确保内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号。<h2 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h2></li></ul><ul><li>执行一个 fork()，之 后父进程退出，子进程继续执行。（*必要）<br>（父进程退出能够不让终端在父进程结束后显示shell提示符；使用fork确保创建的子进程不会成为进程组的首进程）</li><li>子进程调用setsid()开启一个新会话。（*必要）<br>（首先，进程创建新的会话时，会该进程会成为新会话新进程组的首进程，如果用父进程创建，回合原来的进程组会话冲突，因此要用子进程创建。其次，创建新的会话，如果不建立连接的话，会话是没有控制终端的，也就符合的守护进程的要求。）</li><li>清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限。(函数umask(xxx);)</li><li>修改进程的当前工作目录，通常会改为根目录(/)。<br>（主要因为守护进程是要存活到系统结束，如果在其他目录，该目录就无法卸载，如u盘目录。函数chdir();）</li><li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>（原因同上，防止无法卸载某些关联磁盘）</li><li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null并使用dup2()使所有这些描述符指向这个设备。<br>（防止系统调用这些关闭了的文件描述符后出错，重定向到null目录，null目录内的内容会自动被丢弃）</li><li>核心业务逻辑（*必要）</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/" class="category-chain-item">后台开发</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/">#多进程</a> <a href="/tags/Linux/">#Linux</a></div></div><div class="license-box my-3"><div class="license-title"><div>Linux多进程的一些知识点</div><div>https://easyboy-blog.com/multiprocess-development.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>laser</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年7月31日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/website-communication.html" title="浏览器中输入一条URL到页面显示的过程"><span class="hidden-mobile">浏览器中输入一条URL到页面显示的过程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.17/Valine.min.js",(function(){var i=Object.assign({appId:"TSl5PlExO22wiwkA3e15kGvM-gzGzoHsz",appKey:"36AERjunsq15rL0xcz3ovKbG",path:"window.location.pathname",placeholder:"尽情吐槽吧~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>