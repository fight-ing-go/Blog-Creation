<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux多进程的一些知识点</title>
    <link href="/multiprocess-development.html"/>
    <url>/multiprocess-development.html</url>
    
    <content type="html"><![CDATA[<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><p>进程是正在运行的程序的实例。是操作系统动态执行的基本单元。在传统操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><ol><li>同一主机：<br>$$<br>同一主机进程间通信=\left{<br>\begin{matrix}<br> Unix进程间通信方式 \<br> System V进程间通信方式 \<br> POSIX进程间通信方式<br>\end{matrix}<br>\right.<br>$$<br>$$<br>Unix进程间通信方式=\left{<br>\begin{matrix}<br> 匿名管道 \<br> 有名管道 \<br> 信号<br>\end{matrix}<br>\right.<br>$$<br>$$<br>System V进程间通信 、<br> POSIX进程间通信 =\left{<br>\begin{matrix}<br> 消息队列 \<br> 共享内存 \<br> 信号量<br>\end{matrix}<br>\right.<br>$$</li><li>不同主机（网络）进程间通信：Socket<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1></li><li>管道是在内核内存中维护的缓冲器，不同操作系统大小不一定相同。</li><li>管道拥有文件的特质：读和写。匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</li><li>一个管道是一个字节流，可以从中读取任意大小的数据块。</li><li>管道传递的数据是顺序的，读出来的顺序和写入时一致。</li><li>管道的数据传递是单向的，一端写入，一端用于读取，属于半双工。</li><li>管道内数据是一次性操作，一旦被读走，就会被删掉来释放空间。</li><li>匿名管道只能在具有公共祖先的进程中使用。（因为拥有相同的文件描述符，指向的管道一致）。</li><li>管道的数据结构是环形的。</li></ol><p>（堵塞）管道<strong>读写</strong>特点：</p><ol><li>如果管道写端的文件描述符都关闭了，且管道内无数据后，再次read将会<strong>返回0</strong>，而不是堵塞。</li><li>如果管道读端的文件描述符都关闭了，这时候向管道写数据，该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。</li><li>如果管道读端的文件描述符没有关闭，且没有从管道读数据，那么在管道写满后再次write会<strong>堵塞</strong>，直到有空位置才能再次写入数据并返回。</li><li>进程启动，若只先开启读端，将会堵塞，直到读端开启。同理，若只开启写段，也会堵塞到读端开启。</li></ol><p><strong>匿名管道（pipe）</strong>：通过一个没有实体的管道，实现具有亲缘关系的进程间通信。</p><p><strong>有名管道（FIFO）</strong>：克服了匿名管道只能用于亲缘关系的进程通信。<br>有名管道提供了一个路径名与之关联，以FIFO文件形式存在于文件系统中，进程间可以访问该路径而彼此通信。</p><p>匿名有名的不同点：</p><ol><li>FIFO在文件系统中作为一个特殊文件存在，但其内容存放于内存中。</li><li>FIFO文件在进程退出后继续保存在文件系统中。</li><li>FIFO有名字，因而不相关的进程可以访问该文件进行通信。</li></ol><h1 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h1><p>kill -l: 查看系统定义的信号列表<br>信号编号-信号名-默认动作-对应事件<br>2:SIGINT：终止进程。&lt;Ctrl+C&gt;，用户终端向正在运行中的由该终端启动的程序发出此信号。<br>3.SIGQUIT：终止进程。&lt;Ctrl+\&gt;,同信号2。<br>9.SIGKILL：终止进程（可以杀死任何进程）。无条件终止进程，该信号不能被忽略，处理和阻塞。<br>11.SIGSEGV：终止进程并产生core文件。指示进程进行了无效内存访问。<br>13.SIGPIPE：终止进程。pipe向一个没有读端的管道写数据。<br>17.SIGCHIL：忽略这个信号。子进程结束时，父进程收到该信号。<br>18.SIGCONT：继续/忽略。如果进程已停止，则使其继续运行。<br>19.SIGSTOP：终止进程。停止进程的执行。该信号不能被忽略，处理和阻塞。<br>SIGKILL和SIGSTOP只能执行默认动作。</p><p>查看信号详细信息：man 7 signal<br>信号的五种默认处理动作：</p><ol><li>Term：终止进程</li><li>Ign：当前进程忽略掉这个信号</li><li>Core：终止进程并生成core文件</li><li>Stop：暂停当前进程</li><li>Cont：继续执行当前被暂停的进程<br>信号的状态：产生、未决（没有被处理的状态）、递达（信号被处理了）</li></ol><p>SIGCHLD信号产生条件：<br>    * 子进程终止时<br>    * 子进程接收到SIGSTOP信号停止时<br>    * 子进程处在停止态，接收到SIGCONT唤醒时<br>产生的SIGCHLD信号会发送给父进程，父进程默认忽略该信号。</p><h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>两个主要信号集：<br>阻塞信号集：阻止信号响应，并不阻止产生。<br>未决信号集：还未产生响应的信号。</p><ol><li>在内核中，所有没被处理的信号存储在一个集合中，信号状态存储在第二个标志位上。标志位为0，信号不是处于未决状态；标志位为1，信号处于未决状态。</li><li>处理未决信号前，需要和阻塞信号机比较。阻塞信号集默认不阻塞任何信号，如果要阻塞，需要调用系统API。</li><li>在处理未决信号前对阻塞信号集的标志位进行查询。若没有设置阻塞，则正常处理信号；若阻塞了，信号就继续处于未决状态，直至阻塞解除。</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-comment">// 以下五个函数控制的是用户自定义的信号集sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 清空信号集中的数据，将信号集中的所有的标志位置0</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将信号集中所有的标志位置1</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为1，表示阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为0，表示不阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 判断某个信号是否阻塞</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -set: 需要操作的数据集</span><br><span class="hljs-comment">    -signum: 需要判断哪个信号</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    0: 不阻塞</span><br><span class="hljs-comment">    1: 阻塞</span><br><span class="hljs-comment">    -1: 失败</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">kernel_sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">kernel_sigset_t</span> *oldset)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将自定义信号集中的数据设置到内核中(阻塞,解除阻塞)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -how:</span><br><span class="hljs-comment">        -SIG_BLOCK: 设置阻塞信号, 要设置的位,置1</span><br><span class="hljs-comment">        -SIG_UNBLOCK: 解除阻塞,  要解除的位,置1</span><br><span class="hljs-comment">        example: 内核默认阻塞信号集mask, 设置阻塞mask|set,再解除阻塞mask&amp;~set. 即当设置的信号一样的时候,阻塞和非阻塞的值一样</span><br><span class="hljs-comment">    -set: 用户初始化好的自定义信号集</span><br><span class="hljs-comment">    -oldset: 保存之前的信号集状态,一般为NULL</span><br><span class="hljs-comment">    return: </span><br><span class="hljs-comment">        success: return 0</span><br><span class="hljs-comment">        fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 获取内核中的未决信号集</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 信号捕捉优先使用这个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 信号捕捉</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -signum: 需要捕捉的信号的编号或宏值</span><br><span class="hljs-comment">    -act: 捕捉到信号后的处理动作</span><br><span class="hljs-comment">    -oldact: 上一次信号捕捉的设置,一般为NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction {</span><br><span class="hljs-comment">               void (*sa_handler)(int); //指向的函数指针</span><br><span class="hljs-comment">               void (*sa_sigaction)(int, siginfo_t *, void *); //不常用</span><br><span class="hljs-comment">               sigset_t sa_mask;    //临时阻塞信号集, 信号捕捉过程中,临时阻塞某些信号</span><br><span class="hljs-comment">               int sa_flags;    //0: 表示使用sa_handler处理信号  1: 表示使用sa_sigaction处理信号</span><br><span class="hljs-comment">               void (*sa_restorer)(void); //已无用,使用NULL</span><br><span class="hljs-comment">           };</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"><code class="language-hljs c"><span class="hljs-comment">// 以下五个函数控制的是用户自定义的信号集sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 清空信号集中的数据，将信号集中的所有的标志位置0</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将信号集中所有的标志位置1</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为1，表示阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为0，表示不阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 判断某个信号是否阻塞</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -set: 需要操作的数据集</span><br><span class="hljs-comment">    -signum: 需要判断哪个信号</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    0: 不阻塞</span><br><span class="hljs-comment">    1: 阻塞</span><br><span class="hljs-comment">    -1: 失败</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">kernel_sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">kernel_sigset_t</span> *oldset)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将自定义信号集中的数据设置到内核中(阻塞,解除阻塞)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -how:</span><br><span class="hljs-comment">        -SIG_BLOCK: 设置阻塞信号, 要设置的位,置1</span><br><span class="hljs-comment">        -SIG_UNBLOCK: 解除阻塞,  要解除的位,置1</span><br><span class="hljs-comment">        example: 内核默认阻塞信号集mask, 设置阻塞mask|set,再解除阻塞mask&amp;~set. 即当设置的信号一样的时候,阻塞和非阻塞的值一样</span><br><span class="hljs-comment">    -set: 用户初始化好的自定义信号集</span><br><span class="hljs-comment">    -oldset: 保存之前的信号集状态,一般为NULL</span><br><span class="hljs-comment">    return: </span><br><span class="hljs-comment">        success: return 0</span><br><span class="hljs-comment">        fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 获取内核中的未决信号集</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 信号捕捉优先使用这个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 信号捕捉</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -signum: 需要捕捉的信号的编号或宏值</span><br><span class="hljs-comment">    -act: 捕捉到信号后的处理动作</span><br><span class="hljs-comment">    -oldact: 上一次信号捕捉的设置,一般为NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction {</span><br><span class="hljs-comment">               void (*sa_handler)(int); //指向的函数指针</span><br><span class="hljs-comment">               void (*sa_sigaction)(int, siginfo_t *, void *); //不常用</span><br><span class="hljs-comment">               sigset_t sa_mask;    //临时阻塞信号集, 信号捕捉过程中,临时阻塞某些信号</span><br><span class="hljs-comment">               int sa_flags;    //0: 表示使用sa_handler处理信号  1: 表示使用sa_sigaction处理信号</span><br><span class="hljs-comment">               void (*sa_restorer)(void); //已无用,使用NULL</span><br><span class="hljs-comment">           };</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对<strong>其他所有</strong>共享同一个段的进程可用。<br>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。<br>共享内存和内存映射的区别：</p><ol><li><p>共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)</p></li><li><p>共享内存效果更高</p></li><li><p>内存</p><p> 所有的进程操作的是同一块共享内存。<br> 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</p></li><li><p>数据安全</p><ul><li>进程突然退出<br>  共享内存还存在内存映射区消失</li><li>运行进程的电脑死机，宕机了<br>  数据存在在共享内存中，没有了<br>  内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</li></ul></li><li><p>生命周期</p><ul><li>内存映射区: 进程退出，内存映射区销毁</li><li>共享内存: 进程退出，共享内存还在，标记删除，或者关机</li></ul></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-comment">//共享内存相关: 创建共享内存段-&gt;关联-&gt;操作共享内存-&gt;解除关联-&gt;删除关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 创建一个新的共享内存段,或者获取一个既有内存共享段的标识</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -key: 通过Key找到或创建一个共享内存,一般16进制</span><br><span class="hljs-comment">    -size: 共享内存的大小 </span><br><span class="hljs-comment">    -shmflg:</span><br><span class="hljs-comment">        访问权限: rwx</span><br><span class="hljs-comment">        附加属性:</span><br><span class="hljs-comment">            IPC_CREAT: 创建一个新的共享内存段</span><br><span class="hljs-comment">            IPC_EXCL: 判断共享内存是否存在,需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 返回共享内存引用的id, &gt;0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将共享内存段与当前进程进行关联</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID，由shmget获取</span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址,指定NULL,由内核指定</span><br><span class="hljs-comment">    -shmflg: </span><br><span class="hljs-comment">        SHM_RDONLY: 读权限,必须要有该权限</span><br><span class="hljs-comment">        0: 读写权限</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: 返回共享内存的首地址</span><br><span class="hljs-comment">    fail: -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 解除当前进程与共享内存的关联</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 删除共享内存, 共享内存需要删除才会消失,创建共享内存的进程被销毁对共享内存没有影响(可重复删除,因为只是标记)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID</span><br><span class="hljs-comment">    -cmd: </span><br><span class="hljs-comment">        IPC_STAT: 获取共享内存的当前状态</span><br><span class="hljs-comment">        IPC_SET: 设置共享内存状态</span><br><span class="hljs-comment">        IPC_RMID: 标记共享内存被销毁,只是标记,需要与其连接的进程全部销毁</span><br><span class="hljs-comment">    -buf: 需要设置或获取的共享内存的属性信息</span><br><span class="hljs-comment">        IPC_STAT: buf用来存储数据</span><br><span class="hljs-comment">        IPC_SET: buf中需要初始化数据,设置到内核</span><br><span class="hljs-comment">        IPC_RMID: NULL</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 根据指定的路径名和int值,生成一个共享内存key</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -pathname: 指定一个存在的路径</span><br><span class="hljs-comment">    -proj_id: int值,系统使用其中一个字节,8位</span><br><span class="hljs-comment"><code class="language-hljs c"><span class="hljs-comment">//共享内存相关: 创建共享内存段-&gt;关联-&gt;操作共享内存-&gt;解除关联-&gt;删除关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 创建一个新的共享内存段,或者获取一个既有内存共享段的标识</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -key: 通过Key找到或创建一个共享内存,一般16进制</span><br><span class="hljs-comment">    -size: 共享内存的大小 </span><br><span class="hljs-comment">    -shmflg:</span><br><span class="hljs-comment">        访问权限: rwx</span><br><span class="hljs-comment">        附加属性:</span><br><span class="hljs-comment">            IPC_CREAT: 创建一个新的共享内存段</span><br><span class="hljs-comment">            IPC_EXCL: 判断共享内存是否存在,需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 返回共享内存引用的id, &gt;0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将共享内存段与当前进程进行关联</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID，由shmget获取</span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址,指定NULL,由内核指定</span><br><span class="hljs-comment">    -shmflg: </span><br><span class="hljs-comment">        SHM_RDONLY: 读权限,必须要有该权限</span><br><span class="hljs-comment">        0: 读写权限</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: 返回共享内存的首地址</span><br><span class="hljs-comment">    fail: -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 解除当前进程与共享内存的关联</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 删除共享内存, 共享内存需要删除才会消失,创建共享内存的进程被销毁对共享内存没有影响(可重复删除,因为只是标记)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID</span><br><span class="hljs-comment">    -cmd: </span><br><span class="hljs-comment">        IPC_STAT: 获取共享内存的当前状态</span><br><span class="hljs-comment">        IPC_SET: 设置共享内存状态</span><br><span class="hljs-comment">        IPC_RMID: 标记共享内存被销毁,只是标记,需要与其连接的进程全部销毁</span><br><span class="hljs-comment">    -buf: 需要设置或获取的共享内存的属性信息</span><br><span class="hljs-comment">        IPC_STAT: buf用来存储数据</span><br><span class="hljs-comment">        IPC_SET: buf中需要初始化数据,设置到内核</span><br><span class="hljs-comment">        IPC_RMID: NULL</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 根据指定的路径名和int值,生成一个共享内存key</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -pathname: 指定一个存在的路径</span><br><span class="hljs-comment">    -proj_id: int值,系统使用其中一个字节,8位</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><h1 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程组是一组相关进程的集合。</li><li>进程组由一个或多个共享同一进程组标识符(PGID)的进程组成。</li><li>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID，新进程</li><li>会继承其父进程所属的进程组ID。</li><li>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。</li><li>进程组首进程无需是最后一个离开进程组的成员。<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2></li><li>会话是一组进程组的集合。</li><li>会话首进程是创建该新会话的进程，其进程ID 会成为会话 ID。新进程会继承其父进程的会话ID。</li><li>一个会话中的所有进程共享<strong>单个</strong>控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li><li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li><li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li></ul><p>#守护进程（Daemon 进程）<br>也称精灵进程，是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端且周期性执行某种任务或等待处理某些事件，名字一般以d结尾，如Internet服务器inetd,Web服务器httpd。</p><ul><li>生命周期长，在系统启动的时候就被创建并一直运行至系统关闭。</li><li>后台运行且没有控制终端，确保内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号。<h2 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h2></li></ul><ul><li>执行一个 fork()，之 后父进程退出，子进程继续执行。（*必要）<br>（父进程退出能够不让终端在父进程结束后显示shell提示符；使用fork确保创建的子进程不会成为进程组的首进程） </li><li>子进程调用setsid()开启一个新会话。（*必要）<br>（首先，进程创建新的会话时，会该进程会成为新会话新进程组的首进程，如果用父进程创建，回合原来的进程组会话冲突，因此要用子进程创建。其次，创建新的会话，如果不建立连接的话，会话是没有控制终端的，也就符合的守护进程的要求。）</li><li>清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限。(函数umask(xxx);)</li><li>修改进程的当前工作目录，通常会改为根目录(/)。<br>（主要因为守护进程是要存活到系统结束，如果在其他目录，该目录就无法卸载，如u盘目录。函数chdir();）</li><li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>（原因同上，防止无法卸载某些关联磁盘）</li><li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null并使用dup2()使所有这些描述符指向这个设备。<br>（防止系统调用这些关闭了的文件描述符后出错，重定向到null目录，null目录内的内容会自动被丢弃）</li><li>核心业务逻辑（*必要）</li></ul>]]></content>
    
    
    <categories>
      
      <category>后台开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多进程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中输入一条URL到页面显示的过程</title>
    <link href="/website-communication.html"/>
    <url>/website-communication.html</url>
    
    <content type="html"><![CDATA[<p>在浏览器中输入一条URL,然后网页会给出响应，进入你想要的页面。那么浏览器又是如何根据一条URL找到对应的信息的呢？接下来就具体说说消息的传递流程。</p><span id="more"></span>  <h1 id="总体流程图"><a href="#总体流程图" class="headerlink" title="总体流程图"></a>总体流程图</h1><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/URL-Communication/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B-%E7%BD%91%E5%9D%80%E8%BE%93%E5%85%A5.39a91oqu6qy0.jpg" alt="网络通信流程-网址输入"></p><p>首先给出总体的流程图，如上图，实线箭头代表数据流向，虚线箭头代表具体内容。本文将根据这个流程图来展开说明。</p><h1 id="第一步：输入URL"><a href="#第一步：输入URL" class="headerlink" title="第一步：输入URL"></a>第一步：输入URL</h1><p><code>URL</code>就是我们要输入的网址。URL的组成为<code>http://xxxx(webserver)/... </code>，其中<code>“http:”</code>代表访问数据的协议，就是规定数据需要变成什么样的规范，<code>"xxxx"</code>代表的是<code>web</code>服务器，后面的<code>“/...”</code>代表的是对应服务器内的文件路径。<br>所以，当浏览器收到输入的<code>URL</code>时，首先就可以得到我们要访问的web服务器是什么和我们要访问的文件路径，然后就可以根据这些信息生成<code>http</code>消息（发送时为请求报文，接收时为响应报文），这些消息里就包含了我们要访问的内容，同时通过DNS查询到了服务器的IP地址。之后就进入了第二步利用<code>TCP/IP</code>协议传输消息。</p><h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><p>上面是大方向的数据传输过程，文中有提到服务器<code>IP</code>地址查询，这一步又时如何实现的呢。以<code>www.baidu.com</code>为例，这是一个很常见的域名，也就是上面说的代表的是<code>web</code>服务器。那么如何根据域名查询<code>IP</code>呢，这里利用的就是<code>DNS</code>服务器，它保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，浏览器可以根据域名去访问<code>DNS</code>服务器，查询对应的IP是什么，然后再返回给浏览器，实现<code>IP</code>地址查询。</p><p>这里简单谈谈DNS查询流程。要知道域名是分层级的，每层之间用<code>.</code>作间隔，层级越高越靠后，分为：</p><ul><li><p>根 DNS 服务器（.）</p></li><li><p>顶级域 DNS 服务器（.com）</p></li><li><p>权威 DNS 服务器（server.com）</p></li></ul><p>在实际域名中，在最后其实是有个<code>.</code>的，如“<code>www.baidu.com.</code>”。当浏览器去查询<code>ip</code>地址时：</p><ol><li>首先访问的是本地DNS服务器，看看里面有没有缓存要查询的域名对应的IP，有的话直接返回，没有的话本地DNS就会去根域名服务器查询。</li><li>根域名收到请求后，会根据域名告诉本地DNS下一级也就是顶级域服务器的地址，具体来说就是<code>".com"</code>，让它去那里查询。</li><li>顶级域服务器收到请求后，会告诉本地DNS权威服务器的地址。</li><li>本地DNS找到权威服务器的后，权威服务器会查询IP，将其返回给本地DNS</li><li>本地DNS再把IP地址发给浏览器，这样就得到访问域名对应的IP地址了。</li></ol><h1 id="第二步-生成TCP报文"><a href="#第二步-生成TCP报文" class="headerlink" title="第二步 生成TCP报文"></a>第二步 生成TCP报文</h1><p>对于http报文，浏览器会利用socket库来委托协议栈工作，最先的步骤就是生成TCP报文。其中报文中的源端口号和目的端口号，这是明确数据要发送到哪个应用。</p><p>在正式发送数据前，浏览器需要和服务器建立连接，利用的就是TCP协议，需要经过三次握手才能建立通信通路，目的是<strong>保证双方都有发送和接收的能力</strong>，断开连接时需要经历4次挥手。</p><p>当数据较长，超过了<code>MSS</code>长度，TCP会把数据拆解为一块块的数据块-称为”段”。每个被拆解的数据块都会添加TCP的头部信息。</p><blockquote><p>MSS:除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</p></blockquote><p>TCP主要负责可靠的数据传输，报文生成后就进入了TCP/IP的第二步–IP报文</p><h1 id="第三步-生成IP报文"><a href="#第三步-生成IP报文" class="headerlink" title="第三步 生成IP报文"></a>第三步 生成IP报文</h1><p>生成IP报文的过程要明确源<code>IP</code>和目的<code>IP</code>。源<code>IP</code>地址就是客户端输出的 <code>IP</code> 地址。目的<code>IP</code>就是通过 <code>DNS</code> 域名解析得到的 <code>Web</code> 服务器 IP。这里有了一个问题，当客户端有多个网卡，会存在多个IP地址，源<code>IP</code>该怎么选？</p><p>解决办法就是利用<strong>路由表</strong>规则。Linux中可通过<code>route -n</code>查看系统路由表，如下图所示。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/URL-Communication/image.2szp8sjb1sc0.jpg" alt="image"></p><p>路由表规则：把目的IP地址依次和<strong>子网掩码</strong>（<code>Genmask</code>）进行 <strong>与运算</strong>，判断结果和<strong>目标</strong><code>Destination</code>是否一致，一致则源<code>IP</code>就是对应网卡接口的IP地址。否则继续向下查询判断。如果其他所有条目都无法匹配，那么就会选择默认网关，其对应的子网掩码<code>Netmask</code>和<code>Destination</code>都是<code>0.0.0.0</code>。</p><p>IP报文的生成为数据指明了目的地，但两个IP之间的距离可能会很远，那么直接进行端到端的传输是不现实的，需要经历一层层的中转，也就是每次都要指明一个中转站的目的地，这个功能的实现要依赖MAC地址的生成。</p><h1 id="第四步-生成MAC报文"><a href="#第四步-生成MAC报文" class="headerlink" title="第四步 生成MAC报文"></a>第四步 生成MAC报文</h1><blockquote><p>一般在 TCP/IP 通信里，MAC 报头的<strong>协议类型</strong>只使用：<code>0800</code> ： IP 协议和<code>0806</code> ： ARP 协议。</p></blockquote><p>在 MAC 报文里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。<br>发送方MAC地址就是使用的网卡的MAC地址。接收方MAC地址为下一站的MAC地址。那么我们如何知道接收方MAC地址？</p><p>前面第三步中提到过路由表，利用该表，得到了该使用哪个网卡接口，就是其IP地址，也是我们要发送报文的第一个中转站。明确目的地后，就需要获取对应的MAC地址才能准确发送过去，这就利用到了 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p><p><code>ARP协议</code>会在以太网中以广播的形式向每个设备询问这个IP地址是谁的，只有IP的持有者会给出响应返回MAC地址，如此一来就得到了接收方的MAC地址。</p><blockquote><p>操作系统内有一块<code>ARP缓存</code>，当要广播查询时，会先查询缓存，没有的话再继续广播，返回后会将结果放入缓存中。查看缓存<code>arp -a</code></p></blockquote><p>明确了中转目的地后，就开始从物理层面进入了发送数据的第一步–网卡。</p><h1 id="第五步-数据出口-网卡"><a href="#第五步-数据出口-网卡" class="headerlink" title="第五步 数据出口-网卡"></a>第五步 数据出口-网卡</h1><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。准备完成后就会讲网络包从数字信号变为电信号，发送出去，也就是进入了交换机部分。</p><h1 id="第六步-交换机转发"><a href="#第六步-交换机转发" class="headerlink" title="第六步 交换机转发"></a>第六步 交换机转发</h1><p>交换机把电信号变为数字信号，并决定发送给哪个路由器上。<strong>交换机的端口不具有<code> MAC</code> 地址</strong>，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><blockquote><p>交换机的 <code>MAC</code> 地址表主要包含两个信息：设备的 <code>MAC</code> 地址; 该设备连接在交换机的哪个端口上。</p></blockquote><p>如果有记录则直接从对应端口传输。如果没有，则把信号发送给所有端口，因为其报文内<code>MAC</code>地址的存在，只有相应的接收者才会接收包，其他设备会自动忽略。</p><blockquote><p>发送包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 <code>MAC</code> 地址表，下次也就不需要把包发到所有端口了。</p></blockquote><p>至此，数据脱离了子网，开始进入路由器的层层中转。</p><h1 id="第七步-路由器转发"><a href="#第七步-路由器转发" class="headerlink" title="第七步 路由器转发"></a>第七步 路由器转发</h1><p>路由器区别于交换机，拥有MAC地址和IP地址，性质同网卡，因此数据传输过程和网卡一样，目标<code>IP</code>的选址也需要经过路由表进行选择，再由相应的端口作为发送方将以太网包发送出去。</p><p><strong>路由器接收数据：</strong>电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进行错误校验。如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p><strong>路由器查询路由表确定输出端口：</strong>路由器接收完数据后会把MAC头去掉，然后根据目的IP查询路由表获取下一站的路由IP</p><p><strong>路由器发送数据：</strong>判断查询的网关是<code>IP</code>地址还是<code>0.0.0.0</code>，如果是IP，则意味着还需要再次中转。如果为0，代表到达目的地。</p><blockquote><p>路由器内也有ARP缓存，它获取MAC地址的方式也是查表或是广播。</p></blockquote><p>经过路由器的转发，数据终于抵达了终点-服务器。</p><h1 id="第八步-服务器端"><a href="#第八步-服务器端" class="headerlink" title="第八步 服务器端"></a>第八步 服务器端</h1><p>与从客户端发送数据，层层添加报头相反，数据抵达服务器端后，就是对数据报头的层层拆解。匹配MAC地址，下层协议为IP -&gt; 匹配IP地址，得到下层协议为TCP -&gt; 检验序列号，放入缓存，得到端口号，返回响应 -&gt; 发送给HTTP进程 -&gt; 服务器讲所需网页数据封装在 HTTP 响应报文里 -&gt; 数据发送 。</p><p>最后客户端接收到数据后，确认无误后进行TCP四次挥手，与服务器断开连接。</p><p>以上即为浏览器输入网址到网页显示的全部过程。</p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程的一些知识点</title>
    <link href="/multithreaded-development.html"/>
    <url>/multithreaded-development.html</url>
    
    <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><p>线程是允许应用程序并发执行多个任务的一种机制。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol><li>一个进程可以包含多个线程。</li><li>同一程序中所有线程均会独立执行相同程序，且共享同一份全局内存区域。</li><li>进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。</li><li>线程是轻量级的进程（LWP：Light Weight Process），在Linux下线程的本质还是进程。</li></ol><span id="more"></span><h2 id="与进程的区别："><a href="#与进程的区别：" class="headerlink" title="与进程的区别："></a>与进程的区别：</h2><ul><li>进程间的信息难以共享，父子进程并未共享除只读代码段外的内存，需要采用一些通信方式；而线程能够方便快速地共享信息，只需将数据复制到共享（全局或堆）变量中即可。</li><li>进程调用fork()采用写时复制技术，时间开销较大；而线程创建通常比进程快10倍以上，线程间共享虚拟地址空间，无需复制内存，也无需复制页表。<h2 id="线程间地资源共享"><a href="#线程间地资源共享" class="headerlink" title="线程间地资源共享"></a>线程间地资源共享</h2><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Multithreaded_Development/image.1vkki4h1ss5c.jpg" alt="image"></li></ul><p>反应到虚拟内存空间中为：不共享栈空间和.text</p><div align="center"><img src="https://git.poker/fight-ing-go/image_repository/blob/master/202207/Multithreaded_Development/image.6yzd9vnj8jo0.jpg?raw=true" width="20%/"></div> <h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程的主要优势在于，能够通过全局变量来共享信息。然而这也引发了一个新问题：同一个变量被多个线程同时修改或者某个线程读取了正在被其他线程修改的变量。为解决这个问题，就需要用到线程同步。<br>临界区：是指访问某一<strong>共享资源的代码片段</strong>，并且这段代码的执行应为<strong>原子操作</strong>，也就是执行到临界区时一定要执行完整段代码，不能被其他访问该共享资源的线程打断。<br><strong>线程同步</strong>: 即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</p><h2 id="互斥锁（互斥量）"><a href="#互斥锁（互斥量）" class="headerlink" title="互斥锁（互斥量）"></a>互斥锁（互斥量）</h2><p><strong>互斥锁</strong>是实现线程同步的一种方式，保证线程对任意共享资源的原子操作。<br>互斥锁有两种状态:已锁定(locked和未锁定(unlocked)。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。<br>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源(可能由多个相关变量组成)会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议:</p><ul><li>针对共享资源锁定</li><li>互斥量访问共享资源</li><li>对互斥量解锁</li></ul><div align="center"><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Multithreaded_Development/image.5w3i7rc9voo0.jpg" width="30%/"></div> <h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁</strong>：两个或两个以上的线程在执行过程种，因争夺共享资源而造成的一种互相等待的现象。此时若无外力作用，程序将无法执行下去。<br><strong>死锁可能产生的原因</strong>：当超过一个线程加锁同一组互斥量时，就有可能发生死锁。<br><strong>死锁产生的几种场景</strong>：</p><ul><li>忘记释放锁：线程A给临界区上锁后没有释放，当A再次执行到该临界区，会因已被上锁而进入死锁状态。</li><li>重复加锁：线程A给临界区上锁后，再次给该区上锁而进入死锁状态。常见的是线程里有两个子函数，都进行了上锁操作。</li><li>多线程多锁，抢占锁资源：如图所示，当线程A，B都会访问到资源1和2，当A给资源1上锁而B给资源2上锁时，A若想访问资源2需要B先解锁，而B因为资源1的上锁而堵塞，无法给资源2解锁，此时系统就进入了死锁状态。</li></ul><div align="center"><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Multithreaded_Development/image.2zzklhmx1uc0.jpg"></div> <h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在使用互斥锁时，当一个线程A把共享资源锁住时，其他线程均不能访问该资源，但多个线程同时读取一块共享资源是不存在问题的。实际中，对数据的读写操作，读操作的次数是远大于写操作的，这样互斥锁的使用就显得有些不太恰当了。为了提高多线程的读写效率，线程定义了读写锁来实现。<br>读写锁的特点：</p><ul><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作</li><li><strong>写是独占的</strong>，写的优先级高(即当同时申请读锁和写锁时，优先分配写锁)</li></ul><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>线程使用中，设计到了一种生产者消费者模型。该模型有三个部分：生产者-&gt;容器-&gt;消费者。生产者负责生产产品，然后将产品放至容器内，消费者负责消耗产品。这里面的生产者与消费者代表的是线程，容器代表的则是共享资源。</p><p>首先，实现这种模型的基础是要实现线程同步，这里用互斥锁解决（因为这里的生产消费都是写的操作，用读写锁没意义）。但这里面产生了两种情况：容器满了，需要提醒消费者消耗资源，等消腾出空余后再生产；容器空了，需要提醒生产者生产资源，等生产完了再消耗。两种情况代表的问题都一样，拿第一种举例。当本次线程生产后（即线程结束），容器满了，但在消费者并没有消耗产品的情况下再次生产产品，此时就会因容器的溢出而出错。所以我们需要一个线程间的“沟通员”，保持线程同步的同时，在容器满的时候，让生产者停下来，让消费者赶紧去消耗产品，等有空余了，再回归原来的模式，让生产者再次生产。线程中，起这种辅助线程同步的就叫<strong>“条件变量”</strong>。（另一种方式：信号量，可用于线程和进程）</p>]]></content>
    
    
    <categories>
      
      <category>后台开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间序列集体异常检测与DBSCAN实战</title>
    <link href="/collective-anomaly-and-dbscan.html"/>
    <url>/collective-anomaly-and-dbscan.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-异常类型"><a href="#1-异常类型" class="headerlink" title="1.异常类型"></a>1.异常类型</h1><ul><li><p><strong>point outliers（点异常）</strong>：这种异常样本往往以单个点的形式存在，其数值相较于整体样本而言是明显异常的（例如异常大或异常小的全局异常）。</p></li><li><p><strong>contextual outliers（上下文异常）</strong>：contextual outlier的异常体现在某一段时间区间。例如下图的第二幅子图，该异常点相对于整体样本而言并无异常，但如果考虑其相邻时间内的样本，其有明显的异常特性。</p><span id="more"></span>  </li><li><p><strong>collective outliers（集体异常）</strong>：指一段时间序列数据为异常。且该段数据中单独看每个样本点都不是异常的，样本的异常性体现在该段数据整体而言是异常的。<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/1.1p11ki2gci80.jpg" alt="1"></p></li></ul><h1 id="2-集体异常检测"><a href="#2-集体异常检测" class="headerlink" title="2.集体异常检测"></a>2.集体异常检测</h1><p>检测集体（模式）异常的常见做法：</p><ul><li><strong>不和谐分析</strong>：利用滑动窗口将时间序列分割成多个子序列，并计算子序列之间的距离（例如，欧几里德距离）以找到时间序列数据中的不和谐，如矩阵配置文件、HotSAX。 </li><li><strong>子序列聚类</strong>：也将子序列分割应用于时间序列数据，并采用子序列作为每个时间点的特征，其中滑动窗口的大小是特征的数量。然后，采用无监督机器学习方法，例如聚类（例如，Kmeans，PCA）或逐点异常值检测算法来检测模式异常值。<br>其中，基于子序列的方法有三种不同的检测策略：<br>基于模型的方法：每个时间序列被转换为模型参数，然后选择合适的模型距离和聚类算法(通常是传统的聚类算法)，并将其应用于提取的模型参数。<br>基于特征的方法：通常在这种方法中，先从每个时间序列中计算等长特征向量，然后进行欧氏距离测量。<br>基于形状的方法：通常直接处理原始时间序列数据。依据序列间的距离/相似度度量进行聚类<h1 id="3-集体异常检测实战"><a href="#3-集体异常检测实战" class="headerlink" title="3.集体异常检测实战"></a>3.集体异常检测实战</h1>检测策略：基于特征的子序列聚类，PCA提取重要特征，DBSCAN算法实现聚类。<br>检测流程：</li></ul><ol><li>加载原始数据</li><li>为了提高检测效果，对数据进行滤波平滑处理。</li><li>去除数据趋势影响。</li><li>按照实际数据模式，划分子序列，并提取特征。</li><li>特征过滤，PCA降维。</li><li>DBSCAN聚类，检测异常序列。<br>首先加载必要的工具并加载数据。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold   <br><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> NearestNeighbors<br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><span class="hljs-keyword">import</span> plotly.graph_objs <span class="hljs-keyword">as</span> go<br><br><span class="hljs-comment">#加载资源文件数据</span><br>data = pd.read_csv(<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold   <br><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> NearestNeighbors<br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><span class="hljs-keyword">import</span> plotly.graph_objs <span class="hljs-keyword">as</span> go<br><br><span class="hljs-comment">#加载资源文件数据</span><br>data = pd.read_csv(<span class="hljs-string">'./Data.csv'</span>)<br>data.index = pd.to_datetime(data.Datetime)<br></code></pre></td></tr></tbody></table></figure><p>使用低通滤波器滤波。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python">b, a = signal.butter(<span class="hljs-number">10</span>,<span class="hljs-number">0.026</span> , <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>data[<span class="hljs-string">'Hu1_0'</span>] = signal.filtfilt(b, a, data[<span class="hljs-string">'Hu_0'</span>]) <span class="hljs-comment">#data为要过滤的信号</span><br><span class="hljs-comment">#可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">5</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string">'Hu1_0'</span>])<br>plt.plot(data[<span class="hljs-string"><code class="language-hljs python">b, a = signal.butter(<span class="hljs-number">10</span>,<span class="hljs-number">0.026</span> , <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>data[<span class="hljs-string">'Hu1_0'</span>] = signal.filtfilt(b, a, data[<span class="hljs-string">'Hu_0'</span>]) <span class="hljs-comment">#data为要过滤的信号</span><br><span class="hljs-comment">#可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">5</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string">'Hu1_0'</span>])<br>plt.plot(data[<span class="hljs-string">'Hu_0'</span>])<br></code></pre></td></tr></tbody></table></figure><p>结果曲线图如下：<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/2.5ttokbw5tz00.jpg" alt="2">  </p><p>利用时间序列分解，去除曲线趋势。在前期数据分析时找出数据存在两个周期，77min和1day。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 去趋势</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">'Hu1_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期</span><br>data[<span class="hljs-string">"detrend_77"</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.seasonal<br><span class="hljs-comment">#分解1440周期</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">"detrend_77"</span>] , model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 趋势分量</span><br>data[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment">#删除含空值的行，前面分解的序列前端末端含有空值。</span><br>data = data.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#去除趋势</span><br>data[<span class="hljs-string">'detrend_Hu0'</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.trend<br><span class="hljs-comment"># 可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 去趋势</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">'Hu1_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期</span><br>data[<span class="hljs-string">"detrend_77"</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.seasonal<br><span class="hljs-comment">#分解1440周期</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">"detrend_77"</span>] , model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 趋势分量</span><br>data[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment">#删除含空值的行，前面分解的序列前端末端含有空值。</span><br>data = data.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#去除趋势</span><br>data[<span class="hljs-string">'detrend_Hu0'</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.trend<br><span class="hljs-comment"># 可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string">'detrend_Hu0'</span>])<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/3.36x9yqdo7280.jpg" width="60%/"></div>  <p>接下来按照77窗口大小划分子序列，无重复窗口，并提取每个子序列的特征。使用tsfresh工具包，按照API要求，在表中添加id列。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">data[<span class="hljs-string">'id'</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort:按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">76</span> ,min_timeshift = <span class="hljs-number">76</span>,rolling_direction=-<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 特征提取</span><br>df_features = extract_features(df_rolled.drop(<span class="hljs-string">"time"</span>,axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string"><code class="language-hljs python">data[<span class="hljs-string">'id'</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort:按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">76</span> ,min_timeshift = <span class="hljs-number">76</span>,rolling_direction=-<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 特征提取</span><br>df_features = extract_features(df_rolled.drop(<span class="hljs-string">"time"</span>,axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string">"id"</span>)<br></code></pre></td></tr></tbody></table></figure><p>利用方差和相关系数进行特征过滤。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#删除含空值列</span><br>df_features_dropna_All = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 标准化</span><br>scaler1 = StandardScaler()<br>df_features_Standar = pd.DataFrame(scaler1.fit_transform(df_features_dropna_All),index=df_features_dropna_All.index, columns=df_features_dropna_All.columns)<br>df_features_Standar<br><span class="hljs-comment"># 特征过滤 filter方差</span><br>X_fratures_columns = df_features_Standar.columns<br>selector = VarianceThreshold(<span class="hljs-number">0.9</span>)<br>X_features = selector.fit_transform(df_features_Standar)<br>df_features_filter = pd.DataFrame(X_features,index=df_features_Standar.index, columns=X_fratures_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br><span class="hljs-comment"># df_filter.corr()</span><br>corr_features = df_features_filter.corr()<br>threshold = <span class="hljs-number">0.4</span><br>upper_features = corr_features.where(np.triu(np.ones(corr_features.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br>corr_features_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper_features.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper_features[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_features_filter = df_features_filter.drop(corr_features_drop,axis=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#删除含空值列</span><br>df_features_dropna_All = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 标准化</span><br>scaler1 = StandardScaler()<br>df_features_Standar = pd.DataFrame(scaler1.fit_transform(df_features_dropna_All),index=df_features_dropna_All.index, columns=df_features_dropna_All.columns)<br>df_features_Standar<br><span class="hljs-comment"># 特征过滤 filter方差</span><br>X_fratures_columns = df_features_Standar.columns<br>selector = VarianceThreshold(<span class="hljs-number">0.9</span>)<br>X_features = selector.fit_transform(df_features_Standar)<br>df_features_filter = pd.DataFrame(X_features,index=df_features_Standar.index, columns=X_fratures_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br><span class="hljs-comment"># df_filter.corr()</span><br>corr_features = df_features_filter.corr()<br>threshold = <span class="hljs-number">0.4</span><br>upper_features = corr_features.where(np.triu(np.ones(corr_features.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br>corr_features_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper_features.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper_features[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_features_filter = df_features_filter.drop(corr_features_drop,axis=<span class="hljs-number">1</span>)<br>df_features_filter<br></code></pre></td></tr></tbody></table></figure><p>过滤后的特征有14个，再使用PCA特征降维。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># PCA降维,目标维数为7。</span><br>pca = PCA(n_components=<span class="hljs-number">7</span>)<br>pca.fit(df_features_filter)<br><span class="hljs-comment">#获取特征主成分占比</span><br>variance = pca.explained_variance_ratio_ <br>var=np.cumsum(np.<span class="hljs-built_in">round</span>(variance, <span class="hljs-number">3</span>)*<span class="hljs-number">100</span>)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br>plt.ylabel(<span class="hljs-string">'% Variance Explained'</span>)<br>plt.xlabel(<span class="hljs-string">'# of Features'</span>)<br>plt.title(<span class="hljs-string">'PCA Analysis'</span>)<br>plt.ylim(<span class="hljs-number">0</span>,<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># PCA降维,目标维数为7。</span><br>pca = PCA(n_components=<span class="hljs-number">7</span>)<br>pca.fit(df_features_filter)<br><span class="hljs-comment">#获取特征主成分占比</span><br>variance = pca.explained_variance_ratio_ <br>var=np.cumsum(np.<span class="hljs-built_in">round</span>(variance, <span class="hljs-number">3</span>)*<span class="hljs-number">100</span>)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br>plt.ylabel(<span class="hljs-string">'% Variance Explained'</span>)<br>plt.xlabel(<span class="hljs-string">'# of Features'</span>)<br>plt.title(<span class="hljs-string">'PCA Analysis'</span>)<br>plt.ylim(<span class="hljs-number">0</span>,<span class="hljs-number">100.5</span>)<br>plt.plot(var)<br></code></pre></td></tr></tbody></table></figure><p>画出特征主成分占比曲线图。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/4.50ewczun4dc0.jpg" width="60%/"></div>  <p>选择占比最大的三个特征。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">pca = PCA(n_components=<span class="hljs-number">3</span>)<br>pca.fit(df_features_filter)<br>pca_scale = pca.transform(df_features_filter)<br>pca_df = pd.DataFrame(pca_scale, columns=[<span class="hljs-string">'pc1'</span>, <span class="hljs-string">'pc2'</span>, <span class="hljs-string">'pc3'</span>])<br><span class="hljs-built_in"><code class="language-hljs python">pca = PCA(n_components=<span class="hljs-number">3</span>)<br>pca.fit(df_features_filter)<br>pca_scale = pca.transform(df_features_filter)<br>pca_df = pd.DataFrame(pca_scale, columns=[<span class="hljs-string">'pc1'</span>, <span class="hljs-string">'pc2'</span>, <span class="hljs-string">'pc3'</span>])<br><span class="hljs-built_in">print</span>(pca.explained_variance_ratio_)<br>pca_df <br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/4.4a1wi33d3o20.jpg" width="25%/"></div>  <p>查看特征3D图。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(colorscale=<span class="hljs-string">'Greys'</span>, opacity=<span class="hljs-number">0.6</span>, size = <span class="hljs-number">10</span>))<br>layout = go.Layout(margin=<span class="hljs-built_in">dict</span>(l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>),scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number"><code class="language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(colorscale=<span class="hljs-string">'Greys'</span>, opacity=<span class="hljs-number">0.6</span>, size = <span class="hljs-number">10</span>))<br>layout = go.Layout(margin=<span class="hljs-built_in">dict</span>(l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>),scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number">1000</span>)<br>data = [trace]<br>fig = go.Figure(data = data, layout = layout)<br>fig.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/5.3cmrrg0tjgu0.jpg" width="45%/"></div>  <p>DBSCAN需要确定两个参数：epsilon：聚类半径；minPts：聚类点数。其中minPts一般取特征数目的两倍，对应项目中取6。epsilon利用肘形图确定。<br>画出特征的肘形图，即在y轴上，绘制点之间的平均距离，在x轴上绘制数据集中的所有数据点。从图中，取肘部数值约1.4。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>nn = NearestNeighbors(n_neighbors=<span class="hljs-number">6</span>).fit(pca_df)<br>distances, idx = nn.kneighbors(pca_df)<br>distances = np.sort(distances, axis=<span class="hljs-number">0</span>)<br>distances = distances[:,<span class="hljs-number"><code class="language-hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>nn = NearestNeighbors(n_neighbors=<span class="hljs-number">6</span>).fit(pca_df)<br>distances, idx = nn.kneighbors(pca_df)<br>distances = np.sort(distances, axis=<span class="hljs-number">0</span>)<br>distances = distances[:,<span class="hljs-number">1</span>]<br>plt.plot(distances)<br>plt.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/6.3ph5oy7aiym0.jpg" width="60%/"></div>  <p>确定完两个参数后，开始聚类。输出结果为聚类簇数、噪声点数和剪影得分（评价聚类效果，越接近1越好）。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python">db = DBSCAN(eps=<span class="hljs-number">1.4</span>, min_samples=<span class="hljs-number">6</span>).fit(pca_df)<br>labels = db.labels_<span class="hljs-comment"># Number of clusters in labels, ignoring noise if present.</span><br>n_clusters_ = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels)) - (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> labels <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>n_noise_ = <span class="hljs-built_in">list</span>(labels).count(-<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of clusters: %d'</span> % n_clusters_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of noise points: %d'</span> % n_noise_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string"><code class="language-hljs python">db = DBSCAN(eps=<span class="hljs-number">1.4</span>, min_samples=<span class="hljs-number">6</span>).fit(pca_df)<br>labels = db.labels_<span class="hljs-comment"># Number of clusters in labels, ignoring noise if present.</span><br>n_clusters_ = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels)) - (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> labels <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>n_noise_ = <span class="hljs-built_in">list</span>(labels).count(-<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of clusters: %d'</span> % n_clusters_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of noise points: %d'</span> % n_noise_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"Silhouette Coefficient: %0.3f"</span> % metrics.silhouette_score(pca_df, labels))<br></code></pre></td></tr></tbody></table></figure><p>输出结果：<br>Estimated number of clusters: 1<br>Estimated number of noise points: 10<br>Silhouette Coefficient: 0.528<br>将筛选出来的噪声点即异常点反映在3D图上。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>labels = db.labels_<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(color = labels, colorscale=<span class="hljs-string">'Viridis'</span>, size = <span class="hljs-number">10</span>, line = <span class="hljs-built_in">dict</span>(color = <span class="hljs-string">'gray'</span>,width = <span class="hljs-number">5</span>)))<br>layout = go.Layout(scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number">1000</span>)<br>data = [trace]<br>fig = go.Figure(data = data, layout = layout)<br>fig.update_layout(title=<span class="hljs-string">'DBSCAN clusters Derived from PCA'</span>, font=<span class="hljs-built_in">dict</span>(size=<span class="hljs-number"><code class="language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>labels = db.labels_<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(color = labels, colorscale=<span class="hljs-string">'Viridis'</span>, size = <span class="hljs-number">10</span>, line = <span class="hljs-built_in">dict</span>(color = <span class="hljs-string">'gray'</span>,width = <span class="hljs-number">5</span>)))<br>layout = go.Layout(scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number">1000</span>)<br>data = [trace]<br>fig = go.Figure(data = data, layout = layout)<br>fig.update_layout(title=<span class="hljs-string">'DBSCAN clusters Derived from PCA'</span>, font=<span class="hljs-built_in">dict</span>(size=<span class="hljs-number">12</span>,))<br>fig.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/7.6znotbvxhto0.jpg" width="45%/"></div>   <p>将筛选出的异常序列反映到时间序列中。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs python">df_rolled[<span class="hljs-string">'id'</span>] = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(df_rolled)+<span class="hljs-number">1</span>)<br>df_rolled.index = df_rolled.<span class="hljs-built_in">id</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(labels)-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> labels[i]&gt;-<span class="hljs-number">1</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'blue'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'red'</span>)<br>plt.show()<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(df_rolled[<span class="hljs-string"><code class="language-hljs python">df_rolled[<span class="hljs-string">'id'</span>] = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(df_rolled)+<span class="hljs-number">1</span>)<br>df_rolled.index = df_rolled.<span class="hljs-built_in">id</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(labels)-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> labels[i]&gt;-<span class="hljs-number">1</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'blue'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'red'</span>)<br>plt.show()<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(df_rolled[<span class="hljs-string">'detrend_Hu0'</span>])<br>plt.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/8.36lgllzomlk0.jpg" width="60%/"></div>   ]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集体异常</tag>
      
      <tag>子序列聚类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows7环境bat安装mariadb</title>
    <link href="/installing-mariadb-with-bat-in-windows-7-environment.html"/>
    <url>/installing-mariadb-with-bat-in-windows-7-environment.html</url>
    
    <content type="html"><![CDATA[<p>功能实现：编写bat批处理命令，在windows环境下，根据下载的安装包一键安装mariadb。</p><span id="more"></span> <ol><li><p>准备<a href="https://mariadb.org/download/?t=mariadb&amp;o=true&amp;p=mariadb&amp;r=10.5.4&amp;os=windows&amp;cpu=x86&amp;pkg=zip">mariadb安装包</a></p></li><li><p>解压，在解压后的文件中添加data文件夹。(因为最终目标是将所有要安装的东西打个包，实现一键安装，所以一些不需要后续改动的操作就直接手动完成了。当然，也可以使用bat命令解压再添加文件夹，我试过，完全可以的。前置条件是要先安装一个解压软件，windows7没有解压软件，也就是先静默安装360解压，再继续往下走。)</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/1.68rotst9k800.jpg" width="60%/"></div>  </li><li><p>配置环境变量。配置成功后可在环境变量path中查看是否存在。</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs dos">:: 此处将cds设置为bat文件所在绝对路径<br><span class="hljs-built_in">set</span> cds=%~dp0<br><span class="hljs-built_in">set</span> cds<br><span class="hljs-built_in">set</span> mpth=mariadb<br>:: mysql_path为mariadb解压后的路径（此处bat文件和解压文件在同级目录，解压文件名为mariadb）<br><span class="hljs-built_in">set</span> mysql_path=<span class="hljs-variable">%cds%</span><span class="hljs-variable">%mpth%</span><br><span class="hljs-built_in">echo</span>.<br>:: %引用变量<br><span class="hljs-built_in">echo</span> 安装路径：<span class="hljs-variable">%mysql_path%</span><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">pause</span><br><span class="hljs-built_in">echo</span> 配置环境变量<br><span class="hljs-built_in">echo</span>.<br>::setx设置环境变量  setx "变量名" "变量值"<br>setx <span class="hljs-built_in">PATH</span> "<span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin"<br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">ERRORLEVEL</span> <span class="hljs-number">1</span> (<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span> 配置环境变量失败，即将退出<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-keyword">goto</span> END<br>)<br><span class="hljs-built_in">set</span> <span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin<br><span class="hljs-built_in">echo</span> 环境配置成功<br><span class="hljs-built_in">pause</span><br>:END<br><span class="hljs-built_in"><code class="language-hljs dos">:: 此处将cds设置为bat文件所在绝对路径<br><span class="hljs-built_in">set</span> cds=%~dp0<br><span class="hljs-built_in">set</span> cds<br><span class="hljs-built_in">set</span> mpth=mariadb<br>:: mysql_path为mariadb解压后的路径（此处bat文件和解压文件在同级目录，解压文件名为mariadb）<br><span class="hljs-built_in">set</span> mysql_path=<span class="hljs-variable">%cds%</span><span class="hljs-variable">%mpth%</span><br><span class="hljs-built_in">echo</span>.<br>:: %引用变量<br><span class="hljs-built_in">echo</span> 安装路径：<span class="hljs-variable">%mysql_path%</span><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">pause</span><br><span class="hljs-built_in">echo</span> 配置环境变量<br><span class="hljs-built_in">echo</span>.<br>::setx设置环境变量  setx "变量名" "变量值"<br>setx <span class="hljs-built_in">PATH</span> "<span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin"<br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">ERRORLEVEL</span> <span class="hljs-number">1</span> (<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span> 配置环境变量失败，即将退出<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-keyword">goto</span> END<br>)<br><span class="hljs-built_in">set</span> <span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin<br><span class="hljs-built_in">echo</span> 环境配置成功<br><span class="hljs-built_in">pause</span><br>:END<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>mariadb安装与注册服务。(注意：第二条注册服务命令为<strong>mysqld</strong>别搞错了，血的教训)。注册成功会有success提示。</p><figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs fortran">mysql_install_db.exe<br><span class="hljs-keyword">pause</span><br>:: 在前面安装后会在创建的<span class="hljs-keyword">data</span>文件夹中存在my.ini文件，mariadb为创建服务的名称<br>mysqld -install mariadb --<span class="hljs-keyword">default</span>-<span class="hljs-keyword">file</span>=”my.ini文件的路径“<br><span class="hljs-keyword"><code class="language-hljs fortran">mysql_install_db.exe<br><span class="hljs-keyword">pause</span><br>:: 在前面安装后会在创建的<span class="hljs-keyword">data</span>文件夹中存在my.ini文件，mariadb为创建服务的名称<br>mysqld -install mariadb --<span class="hljs-keyword">default</span>-<span class="hljs-keyword">file</span>=”my.ini文件的路径“<br><span class="hljs-keyword">pause</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>注册表修改。在注册服务后，查看服务中的可执行文件路径，会发现执行路径是默认的c盘内的Program Files内的mysqld执行程序，如果你就装在相应路径里，可以不用修改。如果不一致，则需要改成对应的执行程序的路径，也就是一开始解压的文件bin目录里的mysqld程序。(注册表的路径都是一样的，不同的是最后的命名为前面创建服务时的命名，要修改的仅有ImagePath的值)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><span class="hljs-built_in">echo</span> 修改注册表<br><br>::reg add 注册表路径 /v 值名 /t 要修改的数值类型 /d 想要输入的数据 /f<br><br>reg add <span class="hljs-string">"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\mariadb"</span> /v ImagePath /t REG_EXPAND_SZ /d <span class="hljs-string">"\"C:\XFTP\mariadb\bin\mysqld\" --defaults-file=C:\XFTP\mariadb\data mariadb"</span> /f<br><br><span class="hljs-built_in"><code class="language-hljs bash"><span class="hljs-built_in">echo</span> 修改注册表<br><br>::reg add 注册表路径 /v 值名 /t 要修改的数值类型 /d 想要输入的数据 /f<br><br>reg add <span class="hljs-string">"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\mariadb"</span> /v ImagePath /t REG_EXPAND_SZ /d <span class="hljs-string">"\"C:\XFTP\mariadb\bin\mysqld\" --defaults-file=C:\XFTP\mariadb\data mariadb"</span> /f<br><br><span class="hljs-built_in">echo</span> 修改注册表完成<br>pause<br></code></pre></td></tr></tbody></table></figure></li><li><p>启动mariadb服务，并登录进入。默认无密码，直接回车就可进入。</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in"><code class="language-hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mariadb<br>mariadb -uroot -p<br></code></pre></td></tr></tbody></table></figure></li><li><p>数据库备份与恢复。（这部分为初始化数据库，先从模板中导出数据，再应用到其他新建的数据库中，还未完成）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装与环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mariadb</tag>
      
      <tag>bat批处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间序列特征工程</title>
    <link href="/characteristic-engineering-of-time-series.html"/>
    <url>/characteristic-engineering-of-time-series.html</url>
    
    <content type="html"><![CDATA[<p>完成数据清洗之后，需要提取有意义的样本特征输入模型中训练，目的是为了更高效的利用算法。提取特征的步骤叫特征工程，分为三步：特征提取、特征预处理、特征降维。下面将针对时序序列的特征工程进行讲述。</p><span id="more"></span><h1 id="1-特征提取"><a href="#1-特征提取" class="headerlink" title="1. 特征提取"></a>1. 特征提取</h1><p>提取时间序列的特征可以从三方面着手。</p><h2 id="1-1-从时间中提取特征"><a href="#1-1-从时间中提取特征" class="headerlink" title="1.1 从时间中提取特征"></a>1.1 从时间中提取特征</h2><p>每条样本数据对应的时间数据包含很多信息，可以从中发现时间上的一些规律特征。<br>提取时间特征可以对时间进行拆解，如2022.04.23 15:08:03，可以将其中年月日时分秒分别拆解为一列，或者以某个时间点为起点，计算经过的时间，如一天中的第几分钟，一年中的第几天或第几周等等。对于受季节、节假日影响的数据，也可以判断是否月初、月末、周末、公共假期、营业时间等等。<br><strong>举例程序实现：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre class=" language-hljs python">df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal"><code class="language-hljs python">df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>)<br>df<br></code></pre></td></tr></tbody></table></figure><p>结果如下图所示：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/时间特征.407xag8uznw0.jpg"></div> <h2 id="1-2-从时序规律中提取特征"><a href="#1-2-从时序规律中提取特征" class="headerlink" title="1.2 从时序规律中提取特征"></a>1.2 从时序规律中提取特征</h2><p>在数据清洗后的数据分析中，通常会分析时间序列的一些特性，如周期性、时间序列分解、历史数据，可以把这些分析出来的数据用作特征。<br>**举例程序实现： **</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string">"Hu0_resid"</span>] = decompose_result.resid<br>df<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%97%B6%E5%BA%8F%E8%A7%84%E5%BE%8B%E7%89%B9%E5%BE%81.5n1vvk2y3d40.jpg" alt="时序规律特征"></p><h2 id="1-3-从统计窗口提取特征"><a href="#1-3-从统计窗口提取特征" class="headerlink" title="1.3 从统计窗口提取特征"></a>1.3 从统计窗口提取特征</h2><p>要想提取时间序列的统计特征，需要按固定时间长度把一条时间序列划分为n多条子序列，然后对这些子序列分别构造统计特征。<br>**举例程序实现： **</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># sum() 值的总和</span><br><span class="hljs-comment"># mean() 均值</span><br><span class="hljs-comment"># median() 值的算术中值</span><br><span class="hljs-comment"># min() 最小值</span><br><span class="hljs-comment"># max() 最大</span><br><span class="hljs-comment"># std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment"># var() 无偏方差</span><br><span class="hljs-comment"># cov() 无偏协方差（二元）</span><br><span class="hljs-comment"># corr() 相关（二进制）</span><br><span class="hljs-comment"># variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment"># polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment"># df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment"># 一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># sum() 值的总和</span><br><span class="hljs-comment"># mean() 均值</span><br><span class="hljs-comment"># median() 值的算术中值</span><br><span class="hljs-comment"># min() 最小值</span><br><span class="hljs-comment"># max() 最大</span><br><span class="hljs-comment"># std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment"># var() 无偏方差</span><br><span class="hljs-comment"># cov() 无偏协方差（二元）</span><br><span class="hljs-comment"># corr() 相关（二进制）</span><br><span class="hljs-comment"># variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment"># polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment"># df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment"># 一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_diff_std"</span>] = roll_data_diff.std()<br>df<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E7%BB%9F%E8%AE%A1%E7%89%B9%E5%BE%81.6ahmg2mw8s00.jpg" alt="统计特征"></p><h1 id="2-特征预处理"><a href="#2-特征预处理" class="headerlink" title="2. 特征预处理"></a>2. 特征预处理</h1><p>特征预处理是对提取出来的特征无量纲化，目的是让特征处于同等地位，避免特征之间差异太大而影响模型学习效果。常用的处理手段有两种：归一化和标准化。归一化是将原数据映射到[m,n]（通常为[0,1]）内，但当数据异常点较多时，容易影响归一化结果，适合小样本。标准化是将数据变换为均值为0，标准差为1的范围内。而平均值和标准差受异常值影响较小，能克服归一化的缺点。此处使用标准化进行举例。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment"><code class="language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br>df_Standar = pd.DataFrame(scaler.fit_transform(df),index=df.index, columns=df.columns)<br>df_Standar<br></code></pre></td></tr></tbody></table></figure><h1 id="3-特征降维"><a href="#3-特征降维" class="headerlink" title="3. 特征降维"></a>3. 特征降维</h1><p>特征降维指的是对提取出来的特征进行过滤筛选，减少特征维度。目的是为了降低学习任务的难度和减轻维度灾难问题。<br>通常，从两个方面考虑来选择特征：</p><ol><li>特征是否发散<br>如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li><li>特征与目标的相关性<br>与目标相关性高的特征，应当优先选择。<br>区别：特征与特征之间相关性高的，应当优先去除掉其中一个特征，因为它们是替代品。<br>特征选择方法有：Filter过滤法、Wrapper包装法和Embedded嵌入法。其中第二三种方法都适合于有监督学习，需要与目标值关联进行特征选择。因为原数据是为异常检测，没有标签，属于无监督学习，这里仅举例过滤法。<br>通过筛选小方差和强相关特征来达到过滤特征的目的。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br>df_filter<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number">1</span>)<br>df_filter<br></code></pre></td></tr></tbody></table></figure><h1 id="4-Tsfresh特征提取工具"><a href="#4-Tsfresh特征提取工具" class="headerlink" title="4. Tsfresh特征提取工具"></a>4. Tsfresh特征提取工具</h1>最后讲一个用于时间序列特征提取的工具<a href="https://tsfresh.readthedocs.io/en/latest/index.html">tsfresh</a><br>工具介绍就不讲了，直接说一下用法。对于一条长时间序列，要想利用tsfresh工具提取特征，还需要先将其化为一个个子窗口序列。该工具包内就包含这个功能。原表结构为：<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8E%9F%E8%A1%A8%E7%BB%93%E6%9E%84.119hmuad0jy8.jpg" alt="滚动窗口原表结构"></li></ol><p>其中id,time列是在原表的基础上后加上的，目的是为了方便使用API接口函数。id代表组别，time代表时间顺序。然后使用API转换为窗口子序列。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number">1</span>)<br>df_rolled<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/tsfresh%E7%AA%97%E5%8F%A3%E5%BA%8F%E5%88%97.4f2dy005fr40.jpg" alt="tsfresh窗口序列"><br>转化后的id是原id与原时间的组合，也为后面特征提取中的组别。（1，1）代表1号组别的第一个时间点组成的子序列，（1，43316）代表1号组别第43316个点组成的子序列。然后再进行特征提取.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string">"id"</span>)<br>df_features<br></code></pre></td></tr></tbody></table></figure><p>以上即为tsfresh特征提取的步骤，其内置的特征过滤函数因需要目标值而不适用我的数据，所以后续特征降维仍使用上述过滤法进行选择。</p><blockquote><p>参考网站：<br><a href="https://cloud.tencent.com/developer/article/1536537">特征工程系列：时间特征构造以及时间序列特征构造</a><br><a href="https://www.heywhale.com/mw/project/5d86eced8499bc002c108cc8">特征工程理论与代码实现特征工程理论与代码实现</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>时间序列</tag>
      
      <tag>特征工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7安装QT及环境配置</title>
    <link href="/centos7-an-zhuang-qt-ji-huan-jing-pei-zhi.html"/>
    <url>/centos7-an-zhuang-qt-ji-huan-jing-pei-zhi.html</url>
    
    <content type="html"><![CDATA[<ol><li><p>正常下载安装QT</p></li><li><p>打开QT，打开工具-&gt;选项-&gt;Kits，手动添加一个kit(不懂为啥自动检测出来的都不好使，我就全部都手动添加了)，名称和自动的一样就好。</p><span id="more"></span>  <div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/10.4dpjrrcig4g0.jpg" width="60%/"></div>  </li><li><p>首先设置QT versions,手动添加qmake，路劲就是你安装QT的地方，和自动检测出来的一样，设置完点击Apply。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/1.5d7pkq3aynw0.jpg" width="60%/"></div> </li><li><p>然后是添加编译器，这个比较麻烦，需要安装gcc，下面具体说一下操作步骤。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/2.1zgz8yzam9a8.jpg" width="60%/"></div></li></ol><ul><li><p>回到centos界面，打开终端，执行命令 gcc -v，查看是否已经安装gcc,我这里已经安装过了，用的yum自动给我下的，centos7下载的就是这个4.8.5版本的,但这个版本有问题，不支持c++11，所以还需要换更高些的版本。（没下载的话别用yum下，要么自己找高版本下，要么看我后面）</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/3.uxn6sxffcn4.jpg" width="60%/"></div> </li><li><p>gcc升级这步骤浪费了我很多时间，但搞完回头一看，其实步骤很简单。首先一定要看看有没有网，ping一下看看，虚拟机联网百度一下，这里有个问题是试过百度方法后依然不行，service network start命令无法启动，然后看到了一个大佬的评论，设置一下IP地址就好了，命令是：dhclient ens33，这里的ens33是自己网卡名字，前面设置联网的过程应该有看到过，自己更改就可以了。有网之后分别执行下面三条命令：</p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs mipsasm">sudo yum <span class="hljs-keyword">install </span>centos-release-<span class="hljs-keyword">scl</span><br><span class="hljs-keyword"></span>sudo yum <span class="hljs-keyword">install </span>devtoolset<span class="hljs-number">-8</span>-gcc*<br><span class="hljs-keyword">scl </span>enable devtoolset<span class="hljs-number">-8</span> <span class="hljs-keyword"><code class="language-hljs mipsasm">sudo yum <span class="hljs-keyword">install </span>centos-release-<span class="hljs-keyword">scl</span><br><span class="hljs-keyword"></span>sudo yum <span class="hljs-keyword">install </span>devtoolset<span class="hljs-number">-8</span>-gcc*<br><span class="hljs-keyword">scl </span>enable devtoolset<span class="hljs-number">-8</span> <span class="hljs-keyword">bash</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>这里可以自己选择版本，利用centos-release-scl工具，让你不需要重写编译gcc，能同时保留多个版本的gcc，你需要哪个版本enable一下。执行完后再看一下版本是否更新了。用这个工具缺点是重新启动需要再次enable，可以设置开机自启动，我还没设置，因为QT里不需要，设置一下路径就Ok了。开机启动命令是“ echo “source /opt/rh/devtoolset-9/enable” &gt;&gt; /etc/profile ”，我还没试，不懂行不行。</p></blockquote></li><li><p>查看gcc的路径</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/4.7c8mgb783300.jpg" width="60%/"></div></li></ul><ol start="5"><li>打开QT里的编译器设置，手动添加gcc,路径就是你前面查找的，具体就是下面两张图。设置完后点应用。<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/5.4l9lse48f7c0.jpg" width="60%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/6.2p6xnaktsni0.jpg" width="60%/"></div></li><li>回到kit，设置一下compiler和QT version，然后点击Apply。<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/7.72ch9al9tvc0.jpg" width="60%/"></div></li><li>这时候可以打开一个例子试试，build一下，发现还是有问题，报错“ cannot find -lGL”；<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/8.3wp797r848m0.jpg" width="60%/"></div>原因在于QT寻找的libGL路径和centos自带的libGL路径不一致，且名称有点区别，所以需要加一个软链接。输入命令：locate libGL ，查看系统libGL的路径和名称，这里选第一个libGL.so.1。<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/9.7jiqgedk3000.jpg" width="60%/"></div>创建链接：# ln -s /usr/lib64/libGL.so.1 /usr/lib/libGL.so 需要root权限，可使用sudo su命令进入root。创建成功后再次build，发现成功啦。</li></ol><p>这就是centos7安装QT的全过程了。因为第一次用linux系统，安装个QT就浪费我两天，不停试错，心累，于是搞好后赶忙在这记录一下，留待备用。</p><p>备注：这里还有一个问题是：设置好的kit会有警告：the abi of selected debugger does not match the toolchain abi，是关于debugger的，这是因为自带的gdb版本低了，换个高些的版本就ok了。</p>]]></content>
    
    
    <categories>
      
      <category>安装与环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序数据异常检测流程与项目实战</title>
    <link href="/anomaly-detection-process.html"/>
    <url>/anomaly-detection-process.html</url>
    
    <content type="html"><![CDATA[<p>本文主要内容为对时序数据异常检测流程进行简单介绍，然后通过项目实战进行详细解释。全文内容根据个人实际经验所得。</p><h1 id="1-总体流程介绍"><a href="#1-总体流程介绍" class="headerlink" title="1.总体流程介绍"></a>1.总体流程介绍</h1><p>针对项目中传感器数据异常检测，经调研后，个人初步总结工程上实现异常检测的流程。流程框图如下图所示：<br> <span id="more"></span>  </p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Anomaly_detection_process.6l6blsl243s0.jpg" alt="Anomaly_detection_process"></p><p>总体步骤有五步：  </p><ol><li>数据清洗：对数据做初步处理，方便后续的数据分析。包括时间戳的转换（因为是时序数据，需要对时间列做专门处理）、数据重采样（修改时间频率）、缺失值处理、异常值处理、数据平滑处理</li><li>探索性数据分析EDA：通过作图、制表、方程拟合、计算特征量等手段探索数据的结构和规律的一种数据分析方法。主要是利用各种方式自由探索数据分布、数据相关性等。分析后决定检测哪种类型的异常。</li><li>特征提取/相关性分析：对于单维序列，因为缺乏可用特征，需要进行特征提取，以便后续训练模型，时序序列中比较重要的特征是周比环比。对于多维序列，需要先进行相关性分析，剔除相关性强的数据。要根据检测的异常类型，实施特征提取方案。</li><li>训练模型：对数据分析后选择合适的算法进行建模，用提取出的特征或若相关数据进行模型训练。</li><li>异常检测：利用训练好的模型检测实际数据。单维常用算法有LSTM + Vae，通过预测的方式检测异常；多维可利用孤立森林、SVM、kmeans等。</li></ol><h1 id="2-项目实战"><a href="#2-项目实战" class="headerlink" title="2.项目实战"></a>2.项目实战</h1><p>利用工具：jupyter notebook; 语言：python</p><h2 id="2-1-数据清洗"><a href="#2-1-数据清洗" class="headerlink" title="2.1 数据清洗"></a>2.1 数据清洗</h2><p>实现目标：提取csv文件数据，处理缺失值、异常值、数据平滑化，完成数据清洗。<br>首先加载必要库:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_pacf<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_pacf<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br></code></pre></td></tr></tbody></table></figure><p>提取csv文件,利用pd.read_csv()函数可完整提取表中全部内容，函数有很多参数可以选择，实现众多功能</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#读取表格数据</span><br>data1 = pd.read_csv(<span class="hljs-string">'./data/componet.csv'</span>)<br>data2 = pd.read_csv(<span class="hljs-string">'./data/tehu.csv'</span>)<br>data1 <span class="hljs-comment"><code class="language-hljs python"><span class="hljs-comment">#读取表格数据</span><br>data1 = pd.read_csv(<span class="hljs-string">'./data/componet.csv'</span>)<br>data2 = pd.read_csv(<span class="hljs-string">'./data/tehu.csv'</span>)<br>data1 <span class="hljs-comment">#展示data1中数据</span><br></code></pre></td></tr></tbody></table></figure><p>表格数据如图所示：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet.4mjopka34v80.jpg" width="60%/"></div>  <p>查询表中是否有缺失值，使用.isnull()查询，返回含有缺失值的行。我的数据没有缺失值，表为空，就不展示了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 查看缺失值</span><br>pivot_data[pivot_data.isnull().T.<span class="hljs-built_in"><code class="language-hljs python"><span class="hljs-comment"># 查看缺失值</span><br>pivot_data[pivot_data.isnull().T.<span class="hljs-built_in">any</span>()]<br></code></pre></td></tr></tbody></table></figure><p>将data1中时间列数据设置为索引，方便查询，也方便可视化</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python">data1.index = pd.to_datetime(data1.Datetime) <span class="hljs-comment"><code class="language-hljs python">data1.index = pd.to_datetime(data1.Datetime) <span class="hljs-comment">#设置时间列为索引</span><br>data1<br></code></pre></td></tr></tbody></table></figure><p>设置完后数据：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_index.78rh4tnfar00.jpg" width="60%/"></div>  <p>先对未处理的数据进行可视化，看看数据形态：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#可视化</span><br><span class="hljs-comment">#设置x轴显示格式，设置x轴显示范围，freq代表间隔频率，tmp_data1.index[0]代表起始时间,tmp_data1.index[-1]代表结束时间</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    t_disc = tmp_data1[c_disc]<br>    plt.figure(figsize=(<span class="hljs-number">120</span>,<span class="hljs-number">10</span>))<br>    plt.title(c_disc)    <br>    plt.ylabel(c_disc)    <br>    plt.gca().xaxis.set_major_formatter(mdate.DateFormatter(<span class="hljs-string">'%Y-%m-%d'</span>))<br>    plt.xticks(pd.date_range(tmp_data1.index[<span class="hljs-number">0</span>],tmp_data1.index[-<span class="hljs-number">1</span>],freq=<span class="hljs-string">'D'</span>),rotation=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#可视化</span><br><span class="hljs-comment">#设置x轴显示格式，设置x轴显示范围，freq代表间隔频率，tmp_data1.index[0]代表起始时间,tmp_data1.index[-1]代表结束时间</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    t_disc = tmp_data1[c_disc]<br>    plt.figure(figsize=(<span class="hljs-number">120</span>,<span class="hljs-number">10</span>))<br>    plt.title(c_disc)    <br>    plt.ylabel(c_disc)    <br>    plt.gca().xaxis.set_major_formatter(mdate.DateFormatter(<span class="hljs-string">'%Y-%m-%d'</span>))<br>    plt.xticks(pd.date_range(tmp_data1.index[<span class="hljs-number">0</span>],tmp_data1.index[-<span class="hljs-number">1</span>],freq=<span class="hljs-string">'D'</span>),rotation=<span class="hljs-number">45</span>) <br>    plt.plot(t_disc)<br></code></pre></td></tr></tbody></table></figure><p>其中一个曲线示意图：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_plot.4833uxky2zg0.jpg" width="100%/"></div> <p>可以看出，数据有明显的异常点，要么很大，要么很小。为了后面的数据分析与模型训练，我们所以需要对这些明显的异常点进行简单处理。处理方式为使用箱型图，筛选出异常点，然后用前值进行替换。 在此之前，我们先对时间索引进行处理。在这里，我的数据采样间隔大致为2s，但并不固定。因此，在尽可能不影响原数据的情况下，将重采样间隔设置为2S，只做规范时间频率使用。使用resample()函数处理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#重采样 </span><br>tmp_data1 = data1.resample(<span class="hljs-string">'2S'</span>).mean() <span class="hljs-comment"><code class="language-hljs python"><span class="hljs-comment">#重采样 </span><br>tmp_data1 = data1.resample(<span class="hljs-string">'2S'</span>).mean() <span class="hljs-comment">#时间间隔取2S，mean()取平均值,用tmp_data1接收转换后的表，不改变原表内容</span><br>tmp_data1<br></code></pre></td></tr></tbody></table></figure><p>重采样后的数据：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_resample.tfaifs2cgrk.jpg" width="100%/"></div>  <p>可以看出，数据时间间隔已变为2S等距，且值也有所变化，因为非等距时间间隔，不可避免地出现了缺失值。因此下一步对缺失值进行<strong>填补</strong>。填补策略为：对短时间缺失数据填补，长时间缺失数据删除。填补使用缺失点前7个历史数据的均值填补，以是否连续缺失十个点判断是否是长时间缺失数据。这里自己写了个填补函数用于实现上面的功能。（对于几百万的数据量，填补时间很长，有一两小时）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nmeans_fill_missing</span>(<span class="hljs-params">fill_col, df , window=<span class="hljs-number">7</span>, time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 对表格中的某一列的缺失值进行填补，使用邻近历史数据的均值填补，对于大范围缺失点，不进行填补，可对均值窗口、缺失时间范围进行设置</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        window: 插值窗口大小</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        count = <span class="hljs-number">0</span><br>        i=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            <span class="hljs-comment"># count += 1</span><br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    i += time_range<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        i +=<span class="hljs-number">1</span><br>                    count = i   <br>                <span class="hljs-keyword">else</span>:  <br>                    <span class="hljs-keyword">if</span> i - count &lt;= window:         <span class="hljs-comment">#判断当前位置是否有足够历史数据进行插值</span><br>                        <span class="hljs-keyword">if</span> i+window&gt;=<span class="hljs-built_in">len</span>(df):       <span class="hljs-comment">#如果已经到了表格末尾，后续数据不够进行填补，直接略过剩下的点。该策略仅针对数据量足够大的情况</span><br>                            <span class="hljs-keyword">break</span><br>                        train_value_list = []   <span class="hljs-comment">#用于当历史数据不够的情况存放窗口内的点，如 [1,2,3,current:NAN,5,6,7]  此时历史数据不够，则取从1开始的7个点，掠过略过空值</span><br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(window):<br>                            train_value = np.isnan(df[fill_col].iloc[j+count]) <br>                            <span class="hljs-keyword">if</span> train_value == <span class="hljs-literal">False</span>:<br>                                train_value_list.append(df[fill_col].iloc[j+count])<br>                        df[fill_col].iloc[i] = np.array(train_value_list).mean()<br>                    <span class="hljs-keyword">else</span>:<br>                        df[fill_col].iloc[i] = df[fill_col][i - window:i].mean()  <span class="hljs-comment">#如果窗口大小满足，取前window内的均值填补</span><br>            i +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> df<br><br><span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">islong_missing</span>(<span class="hljs-params">fill_col, df , range_window=<span class="hljs-number">10</span>, row_index=<span class="hljs-number">0</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        判断当前空值点是否是长间隔</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表  </span><br><span class="hljs-string">        window:插值窗口大小</span><br><span class="hljs-string">        range_window: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        fill_col: 选择插值的列,可填名字.也可填index</span><br><span class="hljs-string">        row_index: 开始判断的起始索引</span><br><span class="hljs-string">        '''</span><br><br>        islonginterval = <span class="hljs-literal">True</span>    <span class="hljs-comment">#判断当前空值是否属于长时间范围内的空值，是的话就跳过，不进行插值填补</span><br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 判断逻辑：判断后续十个时间点是否为空，当存在一个非空点，即跳出循环，且islonginterval为false</span><br>        <span class="hljs-keyword">while</span> row_index+count&lt;<span class="hljs-built_in">len</span>(df) <span class="hljs-keyword">and</span> islonginterval==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> count&lt;=range_window:<br>            islonginterval = np.isnan(df[fill_col].iloc[row_index+count])<br>            count +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> islonginterval<br><br><span class="hljs-comment">#对两列分别填补</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    tmp_data1 = nmeans_fill_missing(c_disc, tmp_data1, window=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nmeans_fill_missing</span>(<span class="hljs-params">fill_col, df , window=<span class="hljs-number">7</span>, time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 对表格中的某一列的缺失值进行填补，使用邻近历史数据的均值填补，对于大范围缺失点，不进行填补，可对均值窗口、缺失时间范围进行设置</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        window: 插值窗口大小</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        count = <span class="hljs-number">0</span><br>        i=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            <span class="hljs-comment"># count += 1</span><br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    i += time_range<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        i +=<span class="hljs-number">1</span><br>                    count = i   <br>                <span class="hljs-keyword">else</span>:  <br>                    <span class="hljs-keyword">if</span> i - count &lt;= window:         <span class="hljs-comment">#判断当前位置是否有足够历史数据进行插值</span><br>                        <span class="hljs-keyword">if</span> i+window&gt;=<span class="hljs-built_in">len</span>(df):       <span class="hljs-comment">#如果已经到了表格末尾，后续数据不够进行填补，直接略过剩下的点。该策略仅针对数据量足够大的情况</span><br>                            <span class="hljs-keyword">break</span><br>                        train_value_list = []   <span class="hljs-comment">#用于当历史数据不够的情况存放窗口内的点，如 [1,2,3,current:NAN,5,6,7]  此时历史数据不够，则取从1开始的7个点，掠过略过空值</span><br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(window):<br>                            train_value = np.isnan(df[fill_col].iloc[j+count]) <br>                            <span class="hljs-keyword">if</span> train_value == <span class="hljs-literal">False</span>:<br>                                train_value_list.append(df[fill_col].iloc[j+count])<br>                        df[fill_col].iloc[i] = np.array(train_value_list).mean()<br>                    <span class="hljs-keyword">else</span>:<br>                        df[fill_col].iloc[i] = df[fill_col][i - window:i].mean()  <span class="hljs-comment">#如果窗口大小满足，取前window内的均值填补</span><br>            i +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> df<br><br><span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">islong_missing</span>(<span class="hljs-params">fill_col, df , range_window=<span class="hljs-number">10</span>, row_index=<span class="hljs-number">0</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        判断当前空值点是否是长间隔</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表  </span><br><span class="hljs-string">        window:插值窗口大小</span><br><span class="hljs-string">        range_window: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        fill_col: 选择插值的列,可填名字.也可填index</span><br><span class="hljs-string">        row_index: 开始判断的起始索引</span><br><span class="hljs-string">        '''</span><br><br>        islonginterval = <span class="hljs-literal">True</span>    <span class="hljs-comment">#判断当前空值是否属于长时间范围内的空值，是的话就跳过，不进行插值填补</span><br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 判断逻辑：判断后续十个时间点是否为空，当存在一个非空点，即跳出循环，且islonginterval为false</span><br>        <span class="hljs-keyword">while</span> row_index+count&lt;<span class="hljs-built_in">len</span>(df) <span class="hljs-keyword">and</span> islonginterval==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> count&lt;=range_window:<br>            islonginterval = np.isnan(df[fill_col].iloc[row_index+count])<br>            count +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> islonginterval<br><br><span class="hljs-comment">#对两列分别填补</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    tmp_data1 = nmeans_fill_missing(c_disc, tmp_data1, window=<span class="hljs-number">7</span>)<br>tmp_data1<br></code></pre></td></tr></tbody></table></figure><p>为了检验填补效果，又写了个子函数，用来获取每次检测到的长间隔时间端的开始时间和结束时间对于的行数。根据返回的结果，查询对应的时间信息，判断是否满足填补策略</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_long_missing</span>(<span class="hljs-params">fill_col, df , time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 获取长间隔断点的点信息，返回dot_list数组，每两个为一对时间段</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        i=<span class="hljs-number">0</span><br>        dot_list = []<br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    dot_list.append(i)<br>                    i += (time_range-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        i +=<span class="hljs-number">1</span><br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        <br>                    dot_list.append(i)   <br>            i +=<span class="hljs-number">1</span><br>        <span class="hljs-keyword"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_long_missing</span>(<span class="hljs-params">fill_col, df , time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 获取长间隔断点的点信息，返回dot_list数组，每两个为一对时间段</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        i=<span class="hljs-number">0</span><br>        dot_list = []<br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    dot_list.append(i)<br>                    i += (time_range-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        i +=<span class="hljs-number">1</span><br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        <br>                    dot_list.append(i)   <br>            i +=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dot_list<br></code></pre></td></tr></tbody></table></figure><p>然后删除缺失值并导出。使用reset_index()是为了让时间索引一起导出来。这里用的导出方法缺点是索引需要自己手动加上去。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#删除缺失值</span><br>tmp_data1 = tmp_data1.dropna(axis = <span class="hljs-number">0</span>, how = <span class="hljs-string">'all'</span>,inplace = <span class="hljs-literal">False</span>)<br><span class="hljs-comment">#避免之后重新填补，导出经插值，删除空值后的表</span><br>path = os.path.abspath(<span class="hljs-string">r'./data/l1_tehu'</span>)  <span class="hljs-comment"># 文件夹路径</span><br>new_file_name = <span class="hljs-string">'tmp_data1_insert.csv'</span><br>tmp_data1.reset_index().to_csv(path + <span class="hljs-string">'/'</span> + new_file_name, mode=<span class="hljs-string">'a'</span>, encoding=<span class="hljs-string">'gbk'</span>, header=<span class="hljs-literal">False</span>, index=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment">#删除缺失值</span><br>tmp_data1 = tmp_data1.dropna(axis = <span class="hljs-number">0</span>, how = <span class="hljs-string">'all'</span>,inplace = <span class="hljs-literal">False</span>)<br><span class="hljs-comment">#避免之后重新填补，导出经插值，删除空值后的表</span><br>path = os.path.abspath(<span class="hljs-string">r'./data/l1_tehu'</span>)  <span class="hljs-comment"># 文件夹路径</span><br>new_file_name = <span class="hljs-string">'tmp_data1_insert.csv'</span><br>tmp_data1.reset_index().to_csv(path + <span class="hljs-string">'/'</span> + new_file_name, mode=<span class="hljs-string">'a'</span>, encoding=<span class="hljs-string">'gbk'</span>, header=<span class="hljs-literal">False</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></tbody></table></figure><p>下面对前面的<strong>异常值</strong>进行处理。这里只选取其中一个片段进行示范。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python">twoday_data = tmp_data1[<span class="hljs-string">'2021-11-01 18:58:30'</span>: <span class="hljs-string">'2021-11-03 11:35:00'</span>]<br>twoday_data.describe()  <span class="hljs-comment"><code class="language-hljs python">twoday_data = tmp_data1[<span class="hljs-string">'2021-11-01 18:58:30'</span>: <span class="hljs-string">'2021-11-03 11:35:00'</span>]<br>twoday_data.describe()  <span class="hljs-comment">#描述表的一些信息</span><br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_twoday_describe.3qyix6pukji0.jpg" width="40%/"></div>  <p>画出箱线图，可以看出存在的一些异常点：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp0_Te'</span>])<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp1_Te'</span>])<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number"><code class="language-hljs python">plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp0_Te'</span>])<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp1_Te'</span>])<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_twoday_boxplot.705wl11k1jo0.jpg" width="60%/"></div>  <p>然后利用四分位，删除异常值并用前值进行填补。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 超过了上四分位2倍四分位距或下四分位2倍距离都算异常值，用上一个值填充</span><br>a = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.75</span>)<br>b = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.25</span>)<br>c = twoday_data[<span class="hljs-string">'Comp0_Te'</span>]<br>c[(c&gt;=(a-b)*<span class="hljs-number">2</span>+a)|(c&lt;=b-(a-b)*<span class="hljs-number">2</span>)]=np.nan<br>c.fillna(method=<span class="hljs-string">'pad'</span>,inplace=<span class="hljs-literal">True</span>)<br>twoday_data[<span class="hljs-string">'Comp0_Te'</span>] = c<br><span class="hljs-built_in">print</span>(twoday_data[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 超过了上四分位2倍四分位距或下四分位2倍距离都算异常值，用上一个值填充</span><br>a = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.75</span>)<br>b = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.25</span>)<br>c = twoday_data[<span class="hljs-string">'Comp0_Te'</span>]<br>c[(c&gt;=(a-b)*<span class="hljs-number">2</span>+a)|(c&lt;=b-(a-b)*<span class="hljs-number">2</span>)]=np.nan<br>c.fillna(method=<span class="hljs-string">'pad'</span>,inplace=<span class="hljs-literal">True</span>)<br>twoday_data[<span class="hljs-string">'Comp0_Te'</span>] = c<br><span class="hljs-built_in">print</span>(twoday_data[<span class="hljs-string">'Comp0_Te'</span>].describe())<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_twoday_boxplot_new.44m969zxzbg0.jpg" width="60%/"></div>  <p>异常值处理完后，还有数据平滑处理。平滑处理在第二张表中演示。下面处理第二张表的数据。同样的操作，先将时间列设为索引，展示data2中数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python">data2.index = pd.to_datetime(data2.Datetime) <span class="hljs-comment"><code class="language-hljs python">data2.index = pd.to_datetime(data2.Datetime) <span class="hljs-comment">#设置时间列为索引</span><br>data2<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/L1_id_data.6dh59h41kq40.jpg" width="40%/"></div>   <p>表中有个ID列，表示各个传感器的型号，做数据分析时，可以将ID列提取出来，作为列索引，方便观察。因此，先对表格进行<strong>透视</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#数据透视</span><br><span class="hljs-comment">#tmp_data2用来拷贝data2数据变为二重索引表，原表数据保留 </span><br>tmp_data2=data2   <br>tmp_data2[<span class="hljs-string">'L1_id'</span>] = tmp_data2[<span class="hljs-string">'L1_id'</span>].astype(<span class="hljs-built_in">str</span>)<br>tmp_data2=data2.pivot_table(index=<span class="hljs-string">'Datetime'</span>,columns=<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment">#数据透视</span><br><span class="hljs-comment">#tmp_data2用来拷贝data2数据变为二重索引表，原表数据保留 </span><br>tmp_data2=data2   <br>tmp_data2[<span class="hljs-string">'L1_id'</span>] = tmp_data2[<span class="hljs-string">'L1_id'</span>].astype(<span class="hljs-built_in">str</span>)<br>tmp_data2=data2.pivot_table(index=<span class="hljs-string">'Datetime'</span>,columns=<span class="hljs-string">'L1_id'</span>)<br>tmp_data2<br></code></pre></td></tr></tbody></table></figure><p>透视结果如下所示：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/L1_id_pivot.2ab6wthn3ack.jpg" width="100%/"></div>  <p>表格的列变成了二重索引，为了方便后续引用，将其变为一重索引。需要注意的是，这种变换需要数据类型都为string型，如果不是，需要提前转换。当然，还有一种手动方法，变为二重索引后导出表，将原列索引删除，自己再加上索引就好。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#改为一重列索引表，用one_class_data2表示</span><br>one_class_data2 =tmp_data2.copy(deep=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#拷贝表格</span><br>one_class_data2.columns = [<span class="hljs-string">"_"</span>.join(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> one_class_data2.columns.ravel()]  <span class="hljs-comment">#将原来的二重索引的列名进行拼接</span><br><span class="hljs-comment"><code class="language-hljs python"><span class="hljs-comment">#改为一重列索引表，用one_class_data2表示</span><br>one_class_data2 =tmp_data2.copy(deep=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#拷贝表格</span><br>one_class_data2.columns = [<span class="hljs-string">"_"</span>.join(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> one_class_data2.columns.ravel()]  <span class="hljs-comment">#将原来的二重索引的列名进行拼接</span><br><span class="hljs-comment"># one_class_data2.columns = tmp_data2.columns.droplevel(0)  #这个方法是直接将外围第二重索引去掉，只取第一重列索引。</span><br>one_class_data2<br></code></pre></td></tr></tbody></table></figure><p>结果如下：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/L1_id_oneclass.59gip30dtvk0.jpg" width="100%/"></div>  <p>可以看到，列已经变为一重，列名为二重列名拼接而成。后续步骤与第一张表一样，这里不再做解释。最后再对其进行<strong>平滑处理</strong>。平滑方式选用传统的<em>巴特沃斯</em> 低通滤波器。对于参数wn的确定，首先采样频率定为1=采样长度/采样时间（其实采样频率可以自己定，其他的频率以采样频率为基准进行计算即可，结果都一样）。截止频率需要根据实际的来，我的数据中最大的频率差不多以77个点为一个周期，所以稍微扩大下范围后计算截止频率 = 1/60（采样频率为1，那么采样时间即为周期T=1）。根据公式wn = 2*截止频率/采样频率 = 0.033。以两天的数据量为例。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 低通滤波器-巴特沃斯</span><br><span class="hljs-comment"># wn=2*截至频率/采样频率   如果一天采样10个点，采样频率为10，截止频率为想要滤除的频率上限或下限</span><br><span class="hljs-comment"># pivot_data为透视后清理完的表</span><br>twoday_data = pivot_data[<span class="hljs-string">'2022-01-26 00:00:00'</span>:<span class="hljs-string">'2022-01-28 00:00:00'</span>]<br>b, a = signal.butter(<span class="hljs-number">10</span>, <span class="hljs-number">0.033</span>, <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>twoday_data[<span class="hljs-string">'Te_0_filter'</span>] = signal.filtfilt(b, a, twoday_data[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 低通滤波器-巴特沃斯</span><br><span class="hljs-comment"># wn=2*截至频率/采样频率   如果一天采样10个点，采样频率为10，截止频率为想要滤除的频率上限或下限</span><br><span class="hljs-comment"># pivot_data为透视后清理完的表</span><br>twoday_data = pivot_data[<span class="hljs-string">'2022-01-26 00:00:00'</span>:<span class="hljs-string">'2022-01-28 00:00:00'</span>]<br>b, a = signal.butter(<span class="hljs-number">10</span>, <span class="hljs-number">0.033</span>, <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>twoday_data[<span class="hljs-string">'Te_0_filter'</span>] = signal.filtfilt(b, a, twoday_data[<span class="hljs-string">'Te_0'</span>])<br></code></pre></td></tr></tbody></table></figure><p>滤波结果如下：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/butter.6leaq5g4j7s0.jpg" width="50%/"></div>  <h2 id="2-2-探索性数据分析EDA"><a href="#2-2-探索性数据分析EDA" class="headerlink" title="2.2 探索性数据分析EDA"></a>2.2 探索性数据分析EDA</h2><p>首先进行相关性分析。这里以表data2为例。分析的数据取较完整地一个月的时间片段，重采样为1min适当减小数据量。（记得导入表后先设置时间索引）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">Month_data2 = data2[<span class="hljs-string">'2022-01-25 13:12:30'</span>:<span class="hljs-string">'2022-02-24 15:13:00'</span>]<br><span class="hljs-comment"># 重采样一分钟(一个月数据)</span><br>Month_data2_1T = Month_data2.resample(<span class="hljs-string">'T'</span>).mean()<br>Month_data2_1T=Month_data2_1T.<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">#保留两位小数。</span><br><span class="hljs-comment"><code class="language-hljs python">Month_data2 = data2[<span class="hljs-string">'2022-01-25 13:12:30'</span>:<span class="hljs-string">'2022-02-24 15:13:00'</span>]<br><span class="hljs-comment"># 重采样一分钟(一个月数据)</span><br>Month_data2_1T = Month_data2.resample(<span class="hljs-string">'T'</span>).mean()<br>Month_data2_1T=Month_data2_1T.<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">#保留两位小数。</span><br><span class="hljs-comment"># 相关系数</span><br>Month_data2_1T.corr()<br></code></pre></td></tr></tbody></table></figure><p>这里仅展示部分结果图：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_corr.5gurkritpvs0.jpg" width="50%/"></div>  <p>可以看到，每个变量间的相关程度都很高，不利用互相作为特征值。<br>对数据的自相关性和偏相关性进行分析。自相关：描述的是一组时间序列和它前面间隔n个时刻的一组时间序列之前的相关性。偏自相关：描述的是一组时间序列和它前面间隔n个时刻的一组时间序列之前的偏相关性。这里的偏相关性可以从本质上理解为去除了样本之间的干涉，也就是更早时刻的相关性影响。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 自相关，偏自相关，列出每一列的相关图</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    fig = plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">121</span>)<br>    ax1.set_xlabel(c)<br>    ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>    ax2.set_xlabel(c)<br>    plot_acf(Month_data2_1T[c],lags=<span class="hljs-number">50</span>,ax = ax1)<br>    plot_pacf(Month_data2_1T[c],lags=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># 自相关，偏自相关，列出每一列的相关图</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    fig = plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">121</span>)<br>    ax1.set_xlabel(c)<br>    ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>    ax2.set_xlabel(c)<br>    plot_acf(Month_data2_1T[c],lags=<span class="hljs-number">50</span>,ax = ax1)<br>    plot_pacf(Month_data2_1T[c],lags=<span class="hljs-number">50</span>,ax = ax2)<br>    plt.tight_layout()<br></code></pre></td></tr></tbody></table></figure><p>同样的，展示部分结果图。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_acf.3xqf5jmk4f80.jpg" width="60%/"></div>  <p>研究自相关、偏相关可用于判断是否适合使用时间预测方法,也可用于查看周期（下面会有演示）。该图可应用于LSTM算法，作为参数选择的依据。具体使用方法有待明确。<br>查看温湿度的统计分布。这里仅仅是查看下数据分布，目前没有对于其分析的一些想法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 管道温湿度统计分布图</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col: <br>    plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">3</span>))<br>    sns.distplot(Month_data2_1T[c], bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in"><code class="language-hljs python"><span class="hljs-comment"># 管道温湿度统计分布图</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col: <br>    plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">3</span>))<br>    sns.distplot(Month_data2_1T[c], bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in">len</span>(Month_data2_1T[c]))))<br></code></pre></td></tr></tbody></table></figure><p>展示部分结果图。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_distplot.462fv8dw1b00.jpg" width="60%/"></div>  <p>数据平稳性判断，使用单位根检验法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_stationarity</span>(<span class="hljs-params">y, lags_plots=<span class="hljs-number">48</span>, figsize=(<span class="hljs-params"><span class="hljs-number">22</span>,<span class="hljs-number">8</span></span>)</span>):<br>    <span class="hljs-string">"Use Series as parameter"</span><br>    <span class="hljs-comment"># Creating plots of the DF</span><br>    y = pd.Series(y)<br>    fig = plt.figure()<br><br>    ax1 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br>    ax2 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>))<br>    ax3 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    ax4 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br><br>    y.plot(ax=ax1, figsize=figsize)<br>    ax1.set_title(<span class="hljs-string">'Nums Variation'</span>)<br>    plot_acf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax2);<br>    plot_pacf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax3);<br>    sns.distplot(y, bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in">len</span>(y))), ax=ax4)<br>    ax4.set_title(<span class="hljs-string">'Distribution Chart'</span>)<br><br>    plt.tight_layout()<br>    <span class="hljs-comment"># plt.show()</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Results of Dickey-Fuller Test:'</span>)<br>    <span class="hljs-comment">#  regression：{c”，“ct”，“ctt”，“n”}要包含在回归中的常数和趋势顺序。</span><br>    <span class="hljs-comment"># “c”：仅限常量（默认值）。</span><br>    <span class="hljs-comment"># “ct”：恒定和趋势。</span><br>    <span class="hljs-comment"># “ctt”：常数、线性和二次趋势。</span><br>    <span class="hljs-comment"># n：没有常数，没有趋势。</span><br><br>    <span class="hljs-comment"># ADF的结果主要看以下两个方面：</span><br>    <span class="hljs-comment"># Test Statistic的值如果比Critical Value (5%)小则满足稳定性需求.</span><br>    <span class="hljs-comment"># p-value越低（理论上需要低于0.05）证明序列越稳定。</span><br>    adfinput = adfuller(y,regression = <span class="hljs-string">'c'</span>)  <span class="hljs-comment">#单位根检验</span><br>    adftest = pd.Series(adfinput[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], index=[<span class="hljs-string">'Test Statistic'</span>,<span class="hljs-string">'p-value'</span>,<span class="hljs-string">'Lags Used'</span>,<span class="hljs-string">'Number of Observations Used'</span>])<br>    adftest = <span class="hljs-built_in">round</span>(adftest,<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> adfinput[<span class="hljs-number">4</span>].items():<br>        adftest[<span class="hljs-string">"Critical Value (%s)"</span>%key] = value.<span class="hljs-built_in">round</span>(<span class="hljs-number">4</span>)<br>        <br>    <span class="hljs-built_in">print</span>(adftest)<br>    <br>    <span class="hljs-keyword">if</span> adftest[<span class="hljs-number">0</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) &lt; adftest[<span class="hljs-number">5</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'\nThe Test Statistics is lower than the Critical Value of 5%.\nThe serie seems to be stationary'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nThe Test Statistics is higher than the Critical Value of 5%.\nThe serie isn't stationary"</span>)<br><br><span class="hljs-comment"># 检验平稳性</span><br>check_stationarity(Month_data2_1T[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_stationarity</span>(<span class="hljs-params">y, lags_plots=<span class="hljs-number">48</span>, figsize=(<span class="hljs-params"><span class="hljs-number">22</span>,<span class="hljs-number">8</span></span>)</span>):<br>    <span class="hljs-string">"Use Series as parameter"</span><br>    <span class="hljs-comment"># Creating plots of the DF</span><br>    y = pd.Series(y)<br>    fig = plt.figure()<br><br>    ax1 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br>    ax2 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>))<br>    ax3 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    ax4 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br><br>    y.plot(ax=ax1, figsize=figsize)<br>    ax1.set_title(<span class="hljs-string">'Nums Variation'</span>)<br>    plot_acf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax2);<br>    plot_pacf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax3);<br>    sns.distplot(y, bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in">len</span>(y))), ax=ax4)<br>    ax4.set_title(<span class="hljs-string">'Distribution Chart'</span>)<br><br>    plt.tight_layout()<br>    <span class="hljs-comment"># plt.show()</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Results of Dickey-Fuller Test:'</span>)<br>    <span class="hljs-comment">#  regression：{c”，“ct”，“ctt”，“n”}要包含在回归中的常数和趋势顺序。</span><br>    <span class="hljs-comment"># “c”：仅限常量（默认值）。</span><br>    <span class="hljs-comment"># “ct”：恒定和趋势。</span><br>    <span class="hljs-comment"># “ctt”：常数、线性和二次趋势。</span><br>    <span class="hljs-comment"># n：没有常数，没有趋势。</span><br><br>    <span class="hljs-comment"># ADF的结果主要看以下两个方面：</span><br>    <span class="hljs-comment"># Test Statistic的值如果比Critical Value (5%)小则满足稳定性需求.</span><br>    <span class="hljs-comment"># p-value越低（理论上需要低于0.05）证明序列越稳定。</span><br>    adfinput = adfuller(y,regression = <span class="hljs-string">'c'</span>)  <span class="hljs-comment">#单位根检验</span><br>    adftest = pd.Series(adfinput[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], index=[<span class="hljs-string">'Test Statistic'</span>,<span class="hljs-string">'p-value'</span>,<span class="hljs-string">'Lags Used'</span>,<span class="hljs-string">'Number of Observations Used'</span>])<br>    adftest = <span class="hljs-built_in">round</span>(adftest,<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> adfinput[<span class="hljs-number">4</span>].items():<br>        adftest[<span class="hljs-string">"Critical Value (%s)"</span>%key] = value.<span class="hljs-built_in">round</span>(<span class="hljs-number">4</span>)<br>        <br>    <span class="hljs-built_in">print</span>(adftest)<br>    <br>    <span class="hljs-keyword">if</span> adftest[<span class="hljs-number">0</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) &lt; adftest[<span class="hljs-number">5</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'\nThe Test Statistics is lower than the Critical Value of 5%.\nThe serie seems to be stationary'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nThe Test Statistics is higher than the Critical Value of 5%.\nThe serie isn't stationary"</span>)<br><br><span class="hljs-comment"># 检验平稳性</span><br>check_stationarity(Month_data2_1T[<span class="hljs-string">'Te_0'</span>])<br></code></pre></td></tr></tbody></table></figure><blockquote><p>输出结果为：<br>Results of Dickey-Fuller Test:<br>Test Statistic                    -1.4583<br>p-value                            0.5540<br>Lags Used                         55.0000<br>Number of Observations Used    43266.0000<br>Critical Value (1%)               -3.4305<br>Critical Value (5%)               -2.8616<br>Critical Value (10%)              -2.5668<br>dtype: float64<br>The Test Statistics is higher than the Critical Value of 5%.<br>The serie isn’t stationary  </p></blockquote><p>判断平稳性两个标准：Test Statistic小于Critical Value (5%)　或是p-value小于0.05。平稳性是多数统计学模型的必要条件之一。可见原数据并不是平稳序列。<br>对于非平稳序列，可使用一阶差分使其平稳化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#序列平稳化，一阶差分</span><br>Month_data2_1T[<span class="hljs-string">'Te_0_diff'</span>] = Month_data2_1T[<span class="hljs-string">'Te_0'</span>].diff(<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#序列平稳化，一阶差分</span><br>Month_data2_1T[<span class="hljs-string">'Te_0_diff'</span>] = Month_data2_1T[<span class="hljs-string">'Te_0'</span>].diff(<span class="hljs-number">1</span>)<br></code></pre></td></tr></tbody></table></figure><p>其稳定性结果为：</p><blockquote><p>Results of Dickey-Fuller Test:<br>Test Statistic                   -51.9122<br>p-value                            0.0000<br>Lags Used                         54.0000<br>Number of Observations Used    43267.0000<br>Critical Value (1%)               -3.4305<br>Critical Value (5%)               -2.8616<br>Critical Value (10%)              -2.5668<br>dtype: float64<br>The Test Statistics is lower than the Critical Value of 5%.<br>The serie seems to be stationary</p></blockquote><p>可见一阶差分可以有效是原序列平稳。后期可利用差分序列进行异常检测训练。<br>时间序列分解：所谓分解就是将时序数据分离成不同的成分，分解为：长期趋势Trend、季节性Seasonality和随机残差Residuals。分解序列后可针对每个子序列分别建模处理，如建模趋势后，在原数据中减去趋势的干扰。又或者当作特征值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 管道温湿度时序序列分解：趋势+季节性+残差</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    <span class="hljs-comment">#用加性模型，周期1440为1440min，分解数据时间频率为1min，一天为1440min。这里将一天设为周期，那么分解出的季节性数据以1天为周期</span><br>    decompose_result = seasonal_decompose(Month_data2_1T[c], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br>    fig = plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">411</span>)<br>    ax2 = fig.add_subplot(<span class="hljs-number">412</span>)<br>    ax3 = fig.add_subplot(<span class="hljs-number">413</span>)<br>    ax4 = fig.add_subplot(<span class="hljs-number">414</span>)<br>    ax1.set_xlabel(c)<br>    ax1.set_ylabel(<span class="hljs-string">'init'</span>)<br>    ax2.set_xlabel(c)<br>    ax2.set_ylabel(<span class="hljs-string">'trend'</span>)<br>    ax3.set_xlabel(c)<br>    ax3.set_ylabel(<span class="hljs-string">'seasonal'</span>)<br>    ax4.set_xlabel(c)<br>    ax4.set_ylabel(<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 管道温湿度时序序列分解：趋势+季节性+残差</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    <span class="hljs-comment">#用加性模型，周期1440为1440min，分解数据时间频率为1min，一天为1440min。这里将一天设为周期，那么分解出的季节性数据以1天为周期</span><br>    decompose_result = seasonal_decompose(Month_data2_1T[c], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br>    fig = plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">411</span>)<br>    ax2 = fig.add_subplot(<span class="hljs-number">412</span>)<br>    ax3 = fig.add_subplot(<span class="hljs-number">413</span>)<br>    ax4 = fig.add_subplot(<span class="hljs-number">414</span>)<br>    ax1.set_xlabel(c)<br>    ax1.set_ylabel(<span class="hljs-string">'init'</span>)<br>    ax2.set_xlabel(c)<br>    ax2.set_ylabel(<span class="hljs-string">'trend'</span>)<br>    ax3.set_xlabel(c)<br>    ax3.set_ylabel(<span class="hljs-string">'seasonal'</span>)<br>    ax4.set_xlabel(c)<br>    ax4.set_ylabel(<span class="hljs-string">'resid'</span>)<br>    ax1.plot(Month_data2_1T[c])<br>    ax2.plot(decompose_result.trend)<br>    ax3.plot(decompose_result.seasonal)<br>    ax4.plot(decompose_result.resid)<br>    plt.tight_layout()<br></code></pre></td></tr></tbody></table></figure><p>部分结果如下：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_decompose.7bi8h01gdf40.jpg" width="80%/"></div><p>接下来进行周期性检验。首先使用FFT查看频谱图：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">define_fft</span>(<span class="hljs-params">data, fs = <span class="hljs-number">1</span>, show_pic=<span class="hljs-literal">False</span></span>): <br>    <span class="hljs-string">""" </span><br><span class="hljs-string">    # Parameters  </span><br><span class="hljs-string"></span><br><span class="hljs-string">    data: 检测数据，dataframe类型 </span><br><span class="hljs-string">    show_pic: 是否展示图片 </span><br><span class="hljs-string">    fs: 采样频率，采样时长除以采样点数 = 采样频率</span><br><span class="hljs-string">    """</span> <br>    n = data.shape[<span class="hljs-number">0</span>]<br>    x = data.values<br>    yy = fft(x)<br>    fre = fftfreq(n, <span class="hljs-number">1</span>/fs)<span class="hljs-comment">#求频率横坐标</span><br>    indices = np.where(fre &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">#筛选大于零的频率</span><br>    w_pos = <span class="hljs-number">2</span>*<span class="hljs-built_in">abs</span>(yy[indices])/n<span class="hljs-comment">#计算幅度值</span><br>    F_pos = fre[indices]<br><br>    result_fft = pd.DataFrame(columns=[<span class="hljs-string">'freq'</span>, <span class="hljs-string">'spec'</span>, <span class="hljs-string">'T'</span>]) <br>    result_fft[<span class="hljs-string">'freq'</span>] = F_pos <br>    result_fft[<span class="hljs-string">'spec'</span>] = w_pos <br>    result_fft[<span class="hljs-string">'T'</span>] = <span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span><br>    <span class="hljs-comment"># 按照频率强弱程度降序排列 </span><br>    result_fft = result_fft.sort_values(by=<span class="hljs-string">'spec'</span>, ascending=<span class="hljs-literal">False</span>) <br>    <span class="hljs-built_in">print</span>(result_fft.head(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">if</span> show_pic :<br>        <span class="hljs-comment"># 频率转换为周期 </span><br>        plt.plot(<span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span>, w_pos)<br>        plt.show()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>define_fft(Month_data2_1T[<span class="hljs-string">'Te_0'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">define_fft</span>(<span class="hljs-params">data, fs = <span class="hljs-number">1</span>, show_pic=<span class="hljs-literal">False</span></span>): <br>    <span class="hljs-string">""" </span><br><span class="hljs-string">    # Parameters  </span><br><span class="hljs-string"></span><br><span class="hljs-string">    data: 检测数据，dataframe类型 </span><br><span class="hljs-string">    show_pic: 是否展示图片 </span><br><span class="hljs-string">    fs: 采样频率，采样时长除以采样点数 = 采样频率</span><br><span class="hljs-string">    """</span> <br>    n = data.shape[<span class="hljs-number">0</span>]<br>    x = data.values<br>    yy = fft(x)<br>    fre = fftfreq(n, <span class="hljs-number">1</span>/fs)<span class="hljs-comment">#求频率横坐标</span><br>    indices = np.where(fre &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">#筛选大于零的频率</span><br>    w_pos = <span class="hljs-number">2</span>*<span class="hljs-built_in">abs</span>(yy[indices])/n<span class="hljs-comment">#计算幅度值</span><br>    F_pos = fre[indices]<br><br>    result_fft = pd.DataFrame(columns=[<span class="hljs-string">'freq'</span>, <span class="hljs-string">'spec'</span>, <span class="hljs-string">'T'</span>]) <br>    result_fft[<span class="hljs-string">'freq'</span>] = F_pos <br>    result_fft[<span class="hljs-string">'spec'</span>] = w_pos <br>    result_fft[<span class="hljs-string">'T'</span>] = <span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span><br>    <span class="hljs-comment"># 按照频率强弱程度降序排列 </span><br>    result_fft = result_fft.sort_values(by=<span class="hljs-string">'spec'</span>, ascending=<span class="hljs-literal">False</span>) <br>    <span class="hljs-built_in">print</span>(result_fft.head(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">if</span> show_pic :<br>        <span class="hljs-comment"># 频率转换为周期 </span><br>        plt.plot(<span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span>, w_pos)<br>        plt.show()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>define_fft(Month_data2_1T[<span class="hljs-string">'Te_0'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data_1T_periodogram.bx0uzqbkjcw.jpg" width="40%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data_1T_residperiod.4rqdgw1afwu0.jpg" width="30%/"></div>  <p>查看左侧频谱图，可以发现图是有问题的。在周期最大的三个点，也即频率最小的三个点处出现了很大的峰值，低频成分上翘，这明显不对。考虑原因可能有二。  </p><ol><li>原数据存在直流偏移的影响。<br>  解决办法：减去直流量，试减去平均值  </li><li>原数据中趋势的存在干扰了频谱分析。当信号中有明显的趋势项而未消除时，进行相关性分析和功率谱密度分析时会出现畸变，造成低频成分上翘甚至淹没主频成分。<br>  解决办法：去趋势。</li></ol><p>对原数据减去平均值后进行FFT分析，发现频谱图的形状并没有变化，改试方案2。去趋势的方法在网上有许多，这里使用了两种办法：多项式拟合去趋势和时序序列分解。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 多项式拟合去趋势,使用滤波后的数据</span><br>n = Month_data2_1T[<span class="hljs-string">'Te_0_filter'</span>].shape[<span class="hljs-number">0</span>]<br>x=np.linspace(<span class="hljs-number">1</span>, n, n)<br>y = Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>].values<br>z1 = np.polyfit(x, y, <span class="hljs-number">10</span>)              <span class="hljs-comment"># 曲线拟合，返回值为多项式的各项系数，10为阶数，具体数据选取看曲线拟合程度，可进行可视化查看</span><br>p1 = np.poly1d(z1)                    <span class="hljs-comment"># 返回值为多项式的表达式，也就是函数式子</span><br><span class="hljs-comment"># print(p1)</span><br>y_pred = p1(x)                        <span class="hljs-comment"># 根据函数的多项式表达式，求解 y,即趋势</span><br>Month_data_1T[<span class="hljs-string">'x'</span>]=Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>]-y_pred<br>define_fft(Month_data_1T[<span class="hljs-string">'x'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment"># 多项式拟合去趋势,使用滤波后的数据</span><br>n = Month_data2_1T[<span class="hljs-string">'Te_0_filter'</span>].shape[<span class="hljs-number">0</span>]<br>x=np.linspace(<span class="hljs-number">1</span>, n, n)<br>y = Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>].values<br>z1 = np.polyfit(x, y, <span class="hljs-number">10</span>)              <span class="hljs-comment"># 曲线拟合，返回值为多项式的各项系数，10为阶数，具体数据选取看曲线拟合程度，可进行可视化查看</span><br>p1 = np.poly1d(z1)                    <span class="hljs-comment"># 返回值为多项式的表达式，也就是函数式子</span><br><span class="hljs-comment"># print(p1)</span><br>y_pred = p1(x)                        <span class="hljs-comment"># 根据函数的多项式表达式，求解 y,即趋势</span><br>Month_data_1T[<span class="hljs-string">'x'</span>]=Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>]-y_pred<br>define_fft(Month_data_1T[<span class="hljs-string">'x'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure><p>下图为原数据曲线图、趋势图、原数据去趋势图和FFT图。可以看出，用拟合法去趋势后，FFT图尾端翘起现象几乎没有了，但仍有小尾巴残留。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/polyfit.1wq4d6hwhjq8.jpg" width="80%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/polyfit_detrend.2eofsy7hwrwg.jpg" width="80%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/ployfit_FFT.4u82p09d7n60.jpg" width="50%/">    </div>  <p>接下来是由时序序列分解法。该方法上面讲过了，操作步骤一致，只是在分解趋势适合，分解了两次，使用77周期分解以此，发现还有周期现象，又使用1440周期对分解出的趋势分解了一次，对用原数据减去二次趋势，再求FFT，结果如图。第一张为去趋势后的图，第二张为FFT结果图。可以看出，该方法去趋势效果更好。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/twice_detrend.7jhgdh1lahw0.jpg" width="80%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/twice_detrend_FFT.ekqba34lveo.jpg" width="40%/">    </div>  <p>根据频谱图结果，列出最大的三个能量谱的点依次为1天，0.5天，77min。可能的周期也是这三个点。再根据这三个点看自相关图，分别列出滞后点为1000和10000的相关图。如图所示。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/acf_1000.hy1dzybmthk.jpg" width="80%/"></div>  对于自相关图，当序列存在周期时，会在周期出出现一个高峰。从图中可以看出，曲线分别以约77和1440为周期处出现高峰。再结合实际，77min大致为系统运行一个周期，1440min为系统运行一天。由此可见，数据约以77min和1440min为周期。<h2 id="2-3-特征工程"><a href="#2-3-特征工程" class="headerlink" title="2.3 特征工程"></a>2.3 特征工程</h2><h3 id="2-3-1-特征提取"><a href="#2-3-1-特征提取" class="headerlink" title="2.3.1 特征提取"></a>2.3.1 特征提取</h3><ol><li><strong>从时间中提取特征</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#仅取第一列Hu_0数据</span><br>df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment">#仅取第一列Hu_0数据</span><br>df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>)<br>df<br></code></pre></td></tr></tbody></table></figure>结果如下图所示：<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/时间特征.407xag8uznw0.jpg"></div> </li><li><strong>从时序规律中提取特征</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string">"Hu0_resid"</span>] = decompose_result.resid<br>df<br></code></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%97%B6%E5%BA%8F%E8%A7%84%E5%BE%8B%E7%89%B9%E5%BE%81.5n1vvk2y3d40.jpg" alt="时序规律特征"></li><li><strong>从统计窗口提取特征</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#sum() 值的总和</span><br><span class="hljs-comment">#mean() 均值</span><br><span class="hljs-comment">#median() 值的算术中值</span><br><span class="hljs-comment">#min() 最小值</span><br><span class="hljs-comment">#max() 最大</span><br><span class="hljs-comment">#std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment">#var() 无偏方差</span><br><span class="hljs-comment">#cov() 无偏协方差（二元）</span><br><span class="hljs-comment">#corr() 相关（二进制）</span><br><span class="hljs-comment">#variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment">#polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment">#df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment">#一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment">#sum() 值的总和</span><br><span class="hljs-comment">#mean() 均值</span><br><span class="hljs-comment">#median() 值的算术中值</span><br><span class="hljs-comment">#min() 最小值</span><br><span class="hljs-comment">#max() 最大</span><br><span class="hljs-comment">#std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment">#var() 无偏方差</span><br><span class="hljs-comment">#cov() 无偏协方差（二元）</span><br><span class="hljs-comment">#corr() 相关（二进制）</span><br><span class="hljs-comment">#variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment">#polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment">#df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment">#一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_diff_std"</span>] = roll_data_diff.std()<br>df<br></code></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E7%BB%9F%E8%AE%A1%E7%89%B9%E5%BE%81.6ahmg2mw8s00.jpg" alt="统计特征"></li><li><strong>利用tsfresh工具提取特征</strong><br>先将原序列转换为n个窗口子序列。原表one_data结构为：<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8E%9F%E8%A1%A8%E7%BB%93%E6%9E%84.119hmuad0jy8.jpg" alt="滚动窗口原表结构"><br>其中id,time列是在原表的基础上后加上的，目的是为了方便使用API接口函数。id代表组别，time代表时间顺序。然后使用API转换为窗口子序列。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number">1</span>)<br>df_rolled<br></code></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/tsfresh%E7%AA%97%E5%8F%A3%E5%BA%8F%E5%88%97.4f2dy005fr40.jpg" alt="tsfresh窗口序列"><br>转化后的id是原id与原时间的组合，也为后面特征提取中的组别。（1，1）代表1号组别的第一个时间点组成的子序列，（1，43316）代表1号组别第43316个点组成的子序列。然后再进行特征提取.</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string">"id"</span>)<br>df_features<br></code></pre></td></tr></tbody></table></figure><h3 id="2-3-2-特征预处理"><a href="#2-3-2-特征预处理" class="headerlink" title="2.3.2 特征预处理"></a>2.3.2 特征预处理</h3><p>首先处理表中的空值，因为前面窗口大小选为7，所以需要把表df（前面没有划分子窗口的表）的前六行删去，与df_features表的大小保持一致。df_features表中存在大量的空值，需要先将含空值的列删去。然后将df_features的索引设为df的索引，之后会利用concat函数将两表合并。又df表中，因为提取时序规律的特征中，头和尾存在许多空值，需要将其删除，然后取删除后的时间区段，选取df_features表的对应时间段。最后使用concat函数合并两表。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#删除前6行</span><br>df = df.iloc[<span class="hljs-number">6</span>:,:]<br><span class="hljs-comment"># 删除有空值的列</span><br>df_features = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#设置索引</span><br>df_features.index = df.index<br><span class="hljs-comment">#删除空值行，此时查看表可以得到时间段</span><br>df = df.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#合并两表</span><br>df_concat = pd.concat([df,df_features[<span class="hljs-string">'2022-01-26 13:12:00'</span>:<span class="hljs-string">'2022-02-24 03:13:00'</span>]] , axis = <span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#删除前6行</span><br>df = df.iloc[<span class="hljs-number">6</span>:,:]<br><span class="hljs-comment"># 删除有空值的列</span><br>df_features = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#设置索引</span><br>df_features.index = df.index<br><span class="hljs-comment">#删除空值行，此时查看表可以得到时间段</span><br>df = df.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#合并两表</span><br>df_concat = pd.concat([df,df_features[<span class="hljs-string">'2022-01-26 13:12:00'</span>:<span class="hljs-string">'2022-02-24 03:13:00'</span>]] , axis = <span class="hljs-number">1</span>)<br>df_concat<br></code></pre></td></tr></tbody></table></figure><p>然后需要对特征无量纲化。使用标准化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment"><code class="language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br>df_Standar = pd.DataFrame(scaler.fit_transform(df_concat),index=df_concat.index, columns=df_concat.columns)<br>df_Standar<br></code></pre></td></tr></tbody></table></figure><h3 id="2-3-3-特征降维"><a href="#2-3-3-特征降维" class="headerlink" title="2.3.3 特征降维"></a>2.3.3 特征降维</h3><p>使用过滤法，利用方差和相关系数过滤特征。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br>df_filter<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number">1</span>)<br>df_filter<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时序数据</tag>
      
      <tag>异常处理</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c/c++编译流程</title>
    <link href="/compilation-process.html"/>
    <url>/compilation-process.html</url>
    
    <content type="html"><![CDATA[<p>c/c++程序从源代码到二进制程序的编译一般依靠编译工具GCC(GNU Compiler Collection)实现，具体流程分为4步：</p><ol><li>预处理(Preprocessing)</li><li>编译(Compilation)</li><li>汇编(Assemble)</li><li>链接(Linking)   <span id="more"></span></li></ol><h1 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h1><p>对.c或.h或.cpp文件进行预处理，使用预处理器将头文件内容复制到源代码中、删除注释、对宏进行替换等。处理后的文件后缀为.i，实际为完整的源代码，此时文件大小会大许多。gcc命令为:<br><code>gcc -E test.c -o test.i</code><br>-o是指定输出文件名。  </p><h1 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h1><p>将预处理文件转换为汇编语言的形式即汇编代码，处理后的文件后缀为.s。编译完后文件已经变得很小了。gcc命令为：<br><code>gcc -S test.i -o test.s</code></p><h1 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3.汇编"></a>3.汇编</h1><p>对汇编代码进一步翻译为机器码，形成目标代码，处理后文件后缀为.o。gcc命令为：<br><code>gcc -c test.s -o test.o</code></p><h1 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h1><p>使用链接器将目标代码与其他目标代码、库代码、启动代码等链接起来生成可执行程序，处理后文件后缀为.out(windows下为.exe)。gcc命令为：<br><code>gcc test.o -o test</code><br>gcc工作流程示意图： </p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Compilation_process_img/gcc-compilation-process.33xk22nfohu0.webp" width="60%/"></div><p>注：直接编译为可执行程序的命令为：<code> gcc &lt;文件名&gt; -o &lt;生成的文件名&gt;</code><br>　　gcc命令对于c代码，g++命令对应c++代码。  </p><p>存在误区：</p><ul><li>并不是gcc只能编c，g++只能编c++，两者都可以。后缀为.c的gcc会认作c程序，g++会认作c++；而后缀为.cpp的，两者都会认为是c++程序。g++在编译阶段能调用gcc，而gcc不能自动和c++程序使用的库联结，所以需要g++完成链接，为了统一编译/链接都用了g++。  </li><li>gcc和g++都会定义_cplusplus宏，这个宏只标志编译器将代码按c还是c++语法解释。</li><li>编译能使用gcc/g++，因为在编译阶段g++能自动调用gcc，两者等价；但gcc不能进行库连接，所以链接用g++或gcc -lstdc++。</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习笔记</title>
    <link href="/machine-learning-notes.html"/>
    <url>/machine-learning-notes.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">机器学习三要素：数据、算法、模型简单来说，机器学习就是利用已有的数据通过选择的算法训练模型，用以预测分析。</code></pre><h1 id="1-机器学习算法分类"><a href="#1-机器学习算法分类" class="headerlink" title="1 机器学习算法分类"></a>1 机器学习算法分类</h1><ul><li><strong>监督学习</strong>：输入的数据有标签。<br>对于离散数据，标签用于分类，可以归结为分类问题。<br>对于连续数据标签，归结为回归问题。</li><li><strong>无监督学习</strong>：输入数据无标签。</li></ul> <span id="more"></span><h1 id="2-开发流程"><a href="#2-开发流程" class="headerlink" title="2 开发流程"></a>2 开发流程</h1><ol><li>收集数据。要考虑到后续分析所需要的数据，选取重要特征、足够多的数据等。</li><li>准备数据。实际中，收集到的数据可能存在很多问题，需要进行数据清洗。然后再将其划分为训练集(占比较大)和测试集。</li><li>选择模型。根据实际情况，选择合适的模型。监督学习模型和无监督学习模型。</li><li>训练。使用训练集数据对选择的模型进行训练，需要反复测试。</li><li>评估。对训练出的模型，用测试集进行测试，检验其性能好坏。评估指标主要有：准确率、召回率、F值。</li><li>参数调整。主要是调整参数对模型进行改进。</li><li>预测。将模型应用于实际，对相关问题进行预测。</li></ol><h1 id="3-学习工具"><a href="#3-学习工具" class="headerlink" title="3 学习工具"></a>3 学习工具</h1><ol><li>机器学习库：sklearn。Python的机器学习工具，包含许多机器学习算法的实现。</li><li>数据集：scikit-learn、kaggle、UCI</li><li>开发工具：pycharm、vscode、Jupyter notebook(网页版可视化)</li></ol><h1 id="4-特征工程"><a href="#4-特征工程" class="headerlink" title="4 特征工程"></a>4 特征工程</h1><p>  在使用模型进行训练前，需要对原始数据展开特征工程，目的是为了更高效的利用算法，能影响机器学习的效果。<br>  包含三个步骤：特征提取、特征预处理、特征降维。</p><h2 id="4-1-特征提取"><a href="#4-1-特征提取" class="headerlink" title="4.1 特征提取"></a>4.1 特征提取</h2><pre><code class="hljs">从原本的数据集中提取出适合机器学习的数据。  主要是为了解决三个问题:  </code></pre><ul><li>原始数据特征中的强相关性造成的冗余信息。  </li><li>原始数据十分稀疏.</li><li>原始数据维度较大。<blockquote><p>API: sklearn.feature_extraction</p></blockquote></li></ul><h2 id="4-2-特征预处理"><a href="#4-2-特征预处理" class="headerlink" title="4.2 特征预处理"></a>4.2 特征预处理</h2><p>  对特征无量纲化，目的是让特征处于同等地位。常见方法有：归一化和标准化。</p><h3 id="4-2-1-归一化"><a href="#4-2-1-归一化" class="headerlink" title="4.2.1 归一化"></a>4.2.1 归一化</h3><p>  将原始数据映射到[0，1]之间。公式为：<br>  $x’=\frac {x-min}{max-min}$　　　$x’’=x’*(mx-mi)+mi$<br>  其中，ｘ’’为最终结果，max为一列中的最大值，min为一列中的最小值。mx,mi为指定映射的区间，通常mx=1,mi=0<br>  缺点：当数据存在较多异常点是，会影响归一化结果。该方法鲁棒性差，只适合精确小数据场景。  </p><blockquote><p>API: sklearn.preprocessing.MinMaxScaler(feature_range=(0,1)…)</p></blockquote><h3 id="4-2-2-标准化"><a href="#4-2-2-标准化" class="headerlink" title="4.2.2 标准化"></a>4.2.2 标准化</h3><p>  将数据变换为均值为0，标准差为1的范围内。公式为:<br>  $x’=\frac{x-\overline x}{\sigma}$<br>  作用于每一列，$\overline x$ 为平均值，$\sigma$ 为标准差<br>  平均值和标准差受异常值影响较小，标准化方法能一定程度上克服异常点带来的干扰。适用于样本数量大的情况。</p><blockquote><p>API: sklearn.preprocessing.StandardScaler()  </p></blockquote><h2 id="4-3-特征降维"><a href="#4-3-特征降维" class="headerlink" title="4.3 特征降维"></a>4.3 特征降维</h2><p>  减少相关性较强的特征，得到一组不相关的主变量。常见方法有：特征选择和主成分分析。  </p><h3 id="4-3-1-特征选择"><a href="#4-3-1-特征选择" class="headerlink" title="4.3.1 特征选择"></a>4.3.1 特征选择</h3><p>  在原有的冗余特征中找出主要特征。</p><ul><li>Filter(过滤式): <ul><li>方差选择法：过滤低方差特征<blockquote><p>API: sklearn.feature_selection.VarianceThreshold(threshold = 0.0)  </p></blockquote></li><li>相关系数： 过滤相关程度高的特征,常用有皮尔逊相关系数。对于相关性程度高的特征：<ol><li>选取其中一个</li><li>加权求和</li><li>主成分分析<blockquote><p>API: scipy.stats.pearsonr</p></blockquote></li></ol></li></ul></li><li>Embedded(嵌入式)：<ul><li>决策树</li><li>正则化 <h3 id="4-3-2-主成分分析-PCA"><a href="#4-3-2-主成分分析-PCA" class="headerlink" title="4.3.2 主成分分析(PCA)"></a>4.3.2 主成分分析(PCA)</h3>将n维特征映射到k维上，实现特征降维，减少复杂度。一般用于回归分析或聚类。<blockquote><p>API: sklearn.decomposition.PCA(n_components=None)  </p></blockquote><h1 id="5-模型选择与调优"><a href="#5-模型选择与调优" class="headerlink" title="5. 模型选择与调优"></a>5. 模型选择与调优</h1><p>一般来说，模型调优有3个方向：选择更好的算法，调优模型参数，改进数据。这里简单说下模型参数调优。<br>模型参数调优有两步：交叉验证(cross validation)和超参数搜索-网格搜索(Grid Search)。</p></li></ul></li><li>交叉验证：对于训练集数据，再次将其划分为训练集和验证集，用以评估模型预测准确性，让模型更加准确可信。限制模型过拟合、欠拟合等问题。</li><li>超参数搜索-网格搜索:对于算法中需要自定义的参数，叫超参数。对模型预设几种超参数组合，同时训练，选出最优参数组合。<blockquote><p>API: sklearn.model_selection.GridSearchCV  (同时进行交叉验证和网格搜索)</p></blockquote></li></ul><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><p>机器学习实战流程：</p><ol><li>导入数据</li><li>划分数据集</li><li>特征工程</li><li>模型训练与调优</li><li>模型评估</li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
