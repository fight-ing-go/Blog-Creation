<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux网络通信基础（2）</title>
    <link href="/network-communications-2.html"/>
    <url>/network-communications-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><blockquote><p>OSI (0pen System Interconnection）参考模型，即开放式系统互联。参考模型是国际标准化组织(ISO）制定的一个<strong>用于计算机或通信系统间互联的标准体系</strong>。它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。</p></blockquote><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.30iywjhxoso0.jpg" alt="image"></p><ol><li><strong>物理层:<strong>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是</strong>传输比特流</strong>(就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。（比特流-&gt;高低电平-&gt;比特流）</li><li><strong>数据链路层:<strong>建立逻辑连接、进行</strong>硬件地址寻址</strong>、差错校验等功能。定义了如何<strong>让格式化数据以帧为单位进行传输</strong>，以及如何控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地址访问介质。(传输时，先是发送端从网络层（IP地址寻址）到数据链路层（MAC寻址），IP地址是确定到哪个区域，MAC是具体哪个设备)</li><li><strong>网络层:<strong>进行</strong>逻辑地址寻址</strong>(IP地址)，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>**传输层:**定义了一些传输数据的协议和端口号（WWW端口80等)，如:TCP、UDP。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>**会话层:**通过传输层（端口号:传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求。（保存连接信息，不需要重复进行IP寻址等操作）</li><li>**表示层:**数据的表示、安全、压缩。主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西(如图片、声音等)。</li><li>**应用层:**网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真)提供网络服务。</li></ol><h2 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><blockquote><p>现在Internet(因特网）使用的主流协议族是TCP/IP协议族，它是一个分层、多协议的通信体系。TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p></blockquote><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.48vygkw2asa0.jpg" alt="image"></p><ol><li>**应用层:**应用层是TCP/IP协议的第一层，是直接为应用进程提供服务的。<br>(1)对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了SMTP协议、万维网应用使用了HTTP协议、远程登录服务应用使用了有TELNET协议。<br>(2）应用层还能加密、解密、格式化数据。<br>(3)应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。</li><li>**传输层:**作为TCP/IP协议的第二层，传输层在整个TCP/IP协议中起到了中流砥柱的作用。且在传输层中，TCP和UDP也同样起到了中流砥柱的作用。</li><li>**网络层:**网络层在TCP/IP协议中的位于第三层。在TCP/IP协议中网络层可以进行网络连接的建立和终止以及IP地址的寻找等功能。</li><li>**网络接口层:**在TCP/IP协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供—条准确无误的线路。</li></ol><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><blockquote><p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。<strong>它的三要素是:语法、语义、时序</strong>。协议最终体现为在网络上传输的数据包的格式。<br>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。</p></blockquote><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p><strong>应用层常见的协议有：</strong>FTP协议(File Transfer Protocol文件传输协议)、HTTP协议(Hyper Text TransferProtocol超文本传输协议)、NFS (Network File System网络文件系统)。<br>**传输层常见协议有:**TCP协议(Transmission Control Protocol传输控制协议)、UDP协议(User DatagramProtocol 用户数据报协议)。<br>**网络层常见协议有:**IP协议(Internet Protocol因特网互联协议）、ICMP协议(Internet Control MessageProtocol因特网控制报文协议)、IGMP协议(Internet Group Management Protocol因特网组管理协议)。<br>**网络接口层常见协议有:**ARP协议(Address Resolution Protocol地址解析协议)、RARP协议(ReverseAddress Resolution Protocol反向地址解析协议)。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP数据包的结构如下图。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.3td2pwxt8dg0.jpg" alt="image"></p><p>按顺序为：<br><strong>源端口号：</strong>发送方的端口号<br><strong>目的端口号：</strong>接收方的端口号<br><strong>长度：</strong>要发送的UDP数据报的长度，最小值为8（仅有首部）<br><strong>校验和：</strong>检验UDP数据报中是否有发送错误，有就丢弃<br><strong>数据：</strong>如果有的话，就是实际发送的数据包</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP数据包的结构如下图。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.54mqaowxcu40.jpg" alt="image"></p><p>按顺序为：<br><strong>源端口号：</strong>发送方的端口号<br><strong>目的端口号：</strong>接收方的端口号<br><strong>序列号：</strong>本报文段的数据的第一个字节的序号<br><strong>确认序号：</strong>期望收到对方下一个报文段的第一个数据字节的序号<br><strong>首部长度（数据偏移）：</strong>TCP报文端的数据起始处距离TCP报文段的起始处有多远，即首部长度。单位为32位，即以4字节为计算单位，0001-&gt;4字节<br><strong>保留：</strong>占6位，保留以后使用，置0<br><strong>紧急URG：</strong>置1，表明紧急指针字段有效，它告诉系统此报文有紧急数据，应尽快传送</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP数据包的结构如下图。<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.64852rkjs6o0.jpg" alt="image"></p><p>**版本:**IP协议的版本。通信双方使用过的IP协议的版本必须一致，目前最广泛使用的IP协议版本号为4(即IPv4)<br>**首部长度:**单位是32位（4字节)<br>**服务类型:**一般不适用，取值为0<br>**总长度:**指首部加上数据的总长度，单位为字节<br>**标识(identification):**IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段<br>**标志(flag) :**目前只有两位有意义。<br>标志字段中的最低位记为MF。MF= 1即表示后面′还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。<br>标志字段中间的一位记为DF，意思是”不能分片”，只有当DF=0时才允许分片<br><strong>片偏移︰</strong>指出较长的分组在分片后,其片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以8字节为偏移单位。<br>**生存时间:**TTL，表明是数据报在网络中的寿命，即为“跳数限制””，由发出数据报的源点设置这个字段。路由器在转发数据之前就把TTL值减—，当TTL值减为零时，就丢弃这个数据报。<br>**协议:**指出此数据报携带的数据时使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程，常用的ICMP(1)，IGMP(2)，TCP(6)，UDP(17)，IPv6 (41)<br>**首部校验和:**只校验数据报的首部，不包括数据部分。<br>**源地址:**发送方IP地址<br>**目的地址:**接收方IP地址</p><h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>以太网数据包的结构如下图。<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.35nzeiey6n20.jpg" alt="image"></p><p>类型:0x800表示IP、0x806表示ARP、0x835表示RARP</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP数据报的结构如下图:<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.119s9rsspmkw.jpg" alt="image"></p><p>**硬件类型:**1表示MAC地址<br>**协议类型:**0x800表示IP地址<br>**硬件地址长度:**6<br>**协议地址长度:**4<br>**操作:**1表示ARP请求，2表示ARP应答，3表示 RARP请求，4表示 RARP应答</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装实现的。应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息(有时还包括尾部信息)，以实现该层的功能，这个过程就称为封装。如下图所示。<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.5tm763m2j7k0.jpg" alt="image"></p><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>所谓socket(套接字)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。套接字上联应用进程，下联网络协议栈。<br>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的API，<strong>socket是由IP地址和端口结合的</strong>，提供向应用层进程传送数据包的机制。<br>在Linux环境下，socket用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的<strong>伪文件</strong>，可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了<strong>统一接口</strong>，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而<strong>套接字多应用于网络进程间数据的传递</strong>。</p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>字节序，顾名思义宁节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。<br>目的是规范信息单元（如比特、字节、字）的传送顺序。<br>字节序分为<strong>大端字节序(Big-Endian)和小端字节序(Little-Endian)<strong>。大端字节序是指一个整数的最高位字节(23<del>31 bit)存储在内存的低地址处，低位字节(0</del>7 bit)存储在内存的高地址处;小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。<br>为避免收发方字节序不一致，</strong>发送端总是把要发送的数据转换成大端字节序数据后再发送</strong>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换)。<br>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数: htons、htonl;从网络字节序到主机字节序的转换函数: ntohs、ntohl。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs c">h - host主机，主机字节序<br>to -转换成什么<br>n- network网络字节序<br>s - <span class="hljs-type">short</span><br><span class="hljs-number">1</span>- <span class="hljs-type">long</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">//转换端口</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<span class="hljs-comment">//主机字节序–网络字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span> ;<span class="hljs-comment">//网络字节序–主机字节序</span><br><br><span class="hljs-comment">//转IP</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">hton1</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span> ;<span class="hljs-comment">//主机字节序–网络字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntoh1</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> net1ong)</span>;<span class="hljs-comment"><code class="language-hljs c">h - host主机，主机字节序<br>to -转换成什么<br>n- network网络字节序<br>s - <span class="hljs-type">short</span><br><span class="hljs-number">1</span>- <span class="hljs-type">long</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">//转换端口</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<span class="hljs-comment">//主机字节序–网络字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span> ;<span class="hljs-comment">//网络字节序–主机字节序</span><br><br><span class="hljs-comment">//转IP</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">hton1</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span> ;<span class="hljs-comment">//主机字节序–网络字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntoh1</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> net1ong)</span>;<span class="hljs-comment">//网络字节序–主机字节序</span><br></code></pre></td></tr></tbody></table></figure><h2 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h2><blockquote><p>socket地址其实是一个结构体，封装端口号和IP等信息。  </p></blockquote><h3 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h3><p>socket网络编程接口中，表示socket地址的是结构体sockaddr：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> {</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>};<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> {</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>};<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">sa_fami1y_t</span>;<br></code></pre></td></tr></tbody></table></figure><p>其中sa_family_t是地址族类型，比如当接口为IPv4时，对应变量值为AF_INET。常见协议族和地址族如下图。（协议族和对应地址族的值是一样的，所以经常会混用）<br><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.1pvv2b5pbi3k.jpg" alt="image"></p><p>sa_data成员用于存放socket地址值。比如IPv4地址值有2位端口号和4位IP地址，剩下8位为空。不同的协议族的地址值具有不同的含义和长度，如下所示:</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.50a67ttz4z40.jpg" alt="image"></p><p>但是当socket地址为IPv6时，sa_data的空间已经不够了，所以Linux新建了通用的socket，如下所示。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> _<span class="hljs-title">storage</span>{</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __ss_align;<br>    <span class="hljs-type">char</span> __ss_padding[ <span class="hljs-number">128</span> - <span class="hljs-keyword">sizeof</span>(__ss_align) ];<br>};<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> _<span class="hljs-title">storage</span>{</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __ss_align;<br>    <span class="hljs-type">char</span> __ss_padding[ <span class="hljs-number">128</span> - <span class="hljs-keyword">sizeof</span>(__ss_align) ];<br>};<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">sa_family_t</span>;<br><br></code></pre></td></tr></tbody></table></figure><h3 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h3><p>实际开发中，并不会去直接使用上述通用socket地址，而是使用专用的sockaddr_in和sockaddr_in6，然后再将其指针转为（sockaddr *）类型传递给相关函数，其的是类似（void *）的作用。</p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.54pe05a6goc0.jpg" alt="image" style="zoom:80%;"><p><strong>所有socket编程接口使用的地址参数类型都是sockaddr，所有专用socket地址在使用时都需要强转为通用sockaddr类型。</strong></p><h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// p:点分十进制的IP字符串,n:表示network，网络字节序的整数</span><br><span class="hljs-comment">//讲表示IP的点分十进制的字符串转换为网络字节序的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af，<span class="hljs-type">const</span> <span class="hljs-type">char</span> *src，<span class="hljs-type">void</span> *dst)</span> ;<br>af:地址族:AF_INET AF_INET6<br>src:需要转换的点分十进制的IP字符串<br>    dst:转换后的结果保存在这个里面<br><span class="hljs-comment">//将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af，<span class="hljs-type">const</span> <span class="hljs-type">void</span> *src，<span class="hljs-type">char</span> *dst，<span class="hljs-type"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// p:点分十进制的IP字符串,n:表示network，网络字节序的整数</span><br><span class="hljs-comment">//讲表示IP的点分十进制的字符串转换为网络字节序的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af，<span class="hljs-type">const</span> <span class="hljs-type">char</span> *src，<span class="hljs-type">void</span> *dst)</span> ;<br>af:地址族:AF_INET AF_INET6<br>src:需要转换的点分十进制的IP字符串<br>    dst:转换后的结果保存在这个里面<br><span class="hljs-comment">//将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af，<span class="hljs-type">const</span> <span class="hljs-type">void</span> *src，<span class="hljs-type">char</span> *dst，<span class="hljs-type">socklen_t</span> size)</span>;<br>    af:地址族:AF_INET AF_INET6<br>    src:要转换的ip的整数的地址<br>    dst:转换成IP地址字符串保存的地方<br>    size:第三个参数的大小（数组的大小)<br>    返回值:返回转换后的数据的地址<字符串>，和dst是一样的<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络基础（3）</title>
    <link href="/network-communications-3.html"/>
    <url>/network-communications-3.html</url>
    
    <content type="html"><![CDATA[<h1 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h1><p>UPD和TCP之间的差异：</p><table><thead><tr><th align="center"></th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否创建连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠</td><td align="center">可靠的</td></tr><tr><td align="center">连接的对象个数</td><td align="center">一对一、一对多、多对一、多对多</td><td align="center">支持一对一</td></tr><tr><td align="center">传输的方式</td><td align="center">面向数据报</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">8个字节</td><td align="center">最少20个字节</td></tr><tr><td align="center">适用场景</td><td align="center">实时应用（视频会议，直播)</td><td align="center">可靠性高的应用(文件传输)</td></tr></tbody></table><p>TCP的通信流程图：</p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.3qrqc9556i00.jpg" alt="image" style="zoom:80%;"><h2 id="服务器端通信流程"><a href="#服务器端通信流程" class="headerlink" title="服务器端通信流程"></a>服务器端通信流程</h2><p>1．创建一个用于监听的套接字 – socket()<br>    -监听:监听有客户端的连接<br>    -套接字:其实就是一个文件描述符(sockfd),sockfd会监听指向的伪文件（伪文件有读、写两个缓冲区）<br>2．将这个监听文件描述符和本地服务器的IP和端口绑定 – bind()<br>    -客户端连接服务器的时候使用的就是这个IP和端口<br>3．设置监听，监听的socket开始工作 – listen()<br>    -sockfd会监听指向的读缓冲区是否有内容，即客户端是否有发送数据过来<br>4．阻塞等待 – accept()<br>    -当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的新的套接字,这个socket区别于前面只用于监听的socket，是用来和客户端通信的<br>5．通信<br>    -接收数据 – recv()<br>    -发送数据 – send()<br>6．通信结束，断开连接 – close()</p><h2 id="客户端通信流程"><a href="#客户端通信流程" class="headerlink" title="客户端通信流程"></a>客户端通信流程</h2><p>1．创建一个用于通信的套接字 – socket()<br>2．连接服务器，需要指定连接的服务器的IP和端口 – connect()<br>3．连接成功了，客户端可以直接和服务器通信<br>-接收数据 – recv()<br>-发送数据 – send()<br>4．通信结束，断开连接 – close()</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span><span class="hljs-comment">//包含了这个头文件，上面两个就可以省略</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain，<span class="hljs-type">int</span> type，<span class="hljs-type">int</span> protoco1)</span>;<br>    -功能:创建一个套接字<br>    -参数:<br>        - domain:协议族<br>            AF_INET : ipv4AF_INET6 : ipv6<br>            AF_UNIX，AF_LOCAL:本地套接字通信（进程间通信)<br>        - type:通信过程中使用的协议类型<br>        SOCK_STREAM :流式协议soCK_DGRAM:报式协议<br>        - protoco1 :具体的一个协议。一般写<span class="hljs-number">0</span><br>            - SOCK_STREAM:流式协议默认使用TCP<br>            - SOCK_DGRAM∶报式协议默认使用UDp-返回值:<br>    -成功:返回文件描述符，操作的就是内核缓冲区。<br>    -失败:<span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr，<span class="hljs-type">socklen_t</span> addrlen)</span>;<br>    -功能:绑定，将fd和本地的IP＋端口进行绑定<br>    -参数:<br>        - sockfd :通过socket函数得到的文件描述符<br>        - addr :需要绑定的socket地址，这个地址封装了ip和端口号的信息<br>        - addrlen :第二个参数结构体占的内存大小<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">int</span> backlog)</span>;<br>    -功能:监听这个socket上的连接<br>    -参数:<br>        - sockfd :通过socket()函数得到的文件描述符<br>        - backlog :未连接的和已经连接的和的最大值，可在/proc/sys/net/core/somaxconn下查看系统设置的最大值，不能超过这个值<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-keyword">struct</span> sockaddr *addr ，<span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>    -功能:接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接<br>    -参数:<br>        - sockfd :用于监听的文件描述符<br>        - addr :传出参数，记录了连接成功后客户端的地址信息（ip, port)<br>        - addr len :指定第二个参数的对应的内存大小<br>    -返回值:<br>        -成功:用于通信的文件描述符<br>        - <span class="hljs-number">-1</span> :失败<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr，<span class="hljs-type">socklen_t</span> addrlen)</span>;<br>-功能:客户端连接服务器<br>-参数:<br>    - sockfd :用于通信的文件描述符<br>    - addr :客户端要连接的服务器的地址信息<br>    - addrlen :第二个参数的内存大小<br>-返回值:<br>成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd，<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf，<span class="hljs-type">size_t</span> count)</span>;<span class="hljs-comment">//写数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd， <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<span class="hljs-comment"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span><span class="hljs-comment">//包含了这个头文件，上面两个就可以省略</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain，<span class="hljs-type">int</span> type，<span class="hljs-type">int</span> protoco1)</span>;<br>    -功能:创建一个套接字<br>    -参数:<br>        - domain:协议族<br>            AF_INET : ipv4AF_INET6 : ipv6<br>            AF_UNIX，AF_LOCAL:本地套接字通信（进程间通信)<br>        - type:通信过程中使用的协议类型<br>        SOCK_STREAM :流式协议soCK_DGRAM:报式协议<br>        - protoco1 :具体的一个协议。一般写<span class="hljs-number">0</span><br>            - SOCK_STREAM:流式协议默认使用TCP<br>            - SOCK_DGRAM∶报式协议默认使用UDp-返回值:<br>    -成功:返回文件描述符，操作的就是内核缓冲区。<br>    -失败:<span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr，<span class="hljs-type">socklen_t</span> addrlen)</span>;<br>    -功能:绑定，将fd和本地的IP＋端口进行绑定<br>    -参数:<br>        - sockfd :通过socket函数得到的文件描述符<br>        - addr :需要绑定的socket地址，这个地址封装了ip和端口号的信息<br>        - addrlen :第二个参数结构体占的内存大小<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">int</span> backlog)</span>;<br>    -功能:监听这个socket上的连接<br>    -参数:<br>        - sockfd :通过socket()函数得到的文件描述符<br>        - backlog :未连接的和已经连接的和的最大值，可在/proc/sys/net/core/somaxconn下查看系统设置的最大值，不能超过这个值<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-keyword">struct</span> sockaddr *addr ，<span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>    -功能:接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接<br>    -参数:<br>        - sockfd :用于监听的文件描述符<br>        - addr :传出参数，记录了连接成功后客户端的地址信息（ip, port)<br>        - addr len :指定第二个参数的对应的内存大小<br>    -返回值:<br>        -成功:用于通信的文件描述符<br>        - <span class="hljs-number">-1</span> :失败<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr，<span class="hljs-type">socklen_t</span> addrlen)</span>;<br>-功能:客户端连接服务器<br>-参数:<br>    - sockfd :用于通信的文件描述符<br>    - addr :客户端要连接的服务器的地址信息<br>    - addrlen :第二个参数的内存大小<br>-返回值:<br>成功<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd，<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf，<span class="hljs-type">size_t</span> count)</span>;<span class="hljs-comment">//写数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd， <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<span class="hljs-comment">//读数据</span><br>        <br></code></pre></td></tr></tbody></table></figure><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP是一种<strong>面向连接的单播协议</strong>，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的”连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如IP地址、端口号等。<br>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。<br>其中，三次握手是为了保证通信连接的建立。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.54mqaowxcu40.jpg" alt="image"></p><p>**16位源/目的端口号:**告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序(目的端口)的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号。<br>**32位序号 :**一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN (Initial Sequence Number，初始序号值)。那么在该传输方向上(从A到B)，后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP 报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN +1025。另外一个传输方向(从B到A)的TCP报文段的序号值也具有相同的含义。<br><strong>32位确认号:<strong>用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的</strong>序号值＋标志位长度(SYN，FIN)+数据长度</strong>。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同样携带自己的序号和对A发送来的报文段的确认序号。<br>**4位头部长度:**标识该TCP头部有多少个32 bit(4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。<br><strong>6位标志位包含如下几项:</strong></p><ul><li>URG标志，表示紧急指针(urgent pointer）是否有效。</li><li>ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。</li><li>PSH标志，表示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间(如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中)。</li><li>RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。</li><li>SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</li><li>FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</li></ul><p>**16位窗口大小(window size):**是TCP流星控制的一个手段。这里说的窗口，指的是接收通告窗口(Receiver Window，RWND)。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。<br>**16位校验和（TCP checksum):**由发送端填充，接收端对TCP报文段执行CRC算法以校验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的—个重要保障。<br>**16位紧急指针:**是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</p><p><strong>三次握手原理：</strong><br>TCP是在客户端和服务器之间建立一条连接的。那么如何确保这条连接是可靠的？这就需要服务器和客户端都能保证双方的收发是没问题的，实现手段靠的就是三次握手原则。<br>这里以四位收发标志位代表收发功能的确定，0表示不确定，1表示确定。前两位表示客户端收发，后两位表示服务器收发。字母C代表客户端，S代表服务器。<br>三次握手通信流程如下：</p><ol><li>客户端向服务器端发送建立连接的请求，此时可确定客户端发的功能，标志位为C-0100。  </li><li>服务器端收到连接请求，确定了客户端的发的功能，自己的收的功能。标志位为S-0110。  </li><li>服务器又向客户端发送应答和建立连接请求的消息，确定了自己的发的功能。标志位为S-0111。</li><li>客户端收到了服务器发送的消息，确定了自己收的功能，和服务器收发的功能。标志位C-1111。</li><li>最后客户端向服务器发送应答消息，服务器接收后确定自己发的功能。标志位S-1111。</li></ol><p>这样，经过三次消息的发送应答，服务器和客户端都确定的双发的收发功能，能够建立可靠连接。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.6mzi7aovung0.jpg" alt="image"></p><p>上图是三次握手的时序图。</p><p>第一次握手,发送客户端TCP报文（客户端进入SYN_SENT状态）:</p><ol><li>客户端将SYN标志位置为1</li><li>生成一个随机的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小)，如J(100)表示发送的数据大小为100，这里表示方法只用来方便阅读识别，实际通信并没有括号</li></ol><p>第二次握手，收到客户端报文后发送服务器端TCP报文（服务器进入SYN_RCVD状态）:</p><ol><li>服务器端接收客户端的连接:ACK=1</li><li>服务器会回发一个确认序号:ack=客户端的序号＋数据长度(接收到的数据量)＋SYN/FIN(按一个字节算)</li><li>服务器端会向客户端发起连接请求:SYN=1</li><li>服务器会生成一个随机序号: seq = K</li></ol><p>第三次握手，收到服务器端报文后发送客户端TCP报文（客户端进入ESTABLISHED状态，服务器进入ESTABLISHED状态）:</p><ol><li>客户端应答服务器的连接请求:ACK=1</li><li>客户端回复收到了服务器端的数据: ack=服务端的序号＋数据长度＋SYN/FIN(按一个字节算）</li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>同三次握手，当TCP通信双发断开连接时，需要通过四次挥手实现断开连接。  发送过FIN信号的一方在断开连接前不能发只能收。</p><p>通信时序图如下：</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.5ks8mv38ykk.jpg" alt="image"></p><p>为什么断开连接时，不像建立连接那样把ACK和FIN放一起发？</p><p>首先要知道，发送过FIN信号的一方在断开连接前不能发只能收。比如当客户端单方面要结束通信时，发送了FIN信号，然后它就不能再发数据了。但是此时服务器如果还有数据要发送给客户端，就不能发FIN信号，只能先给客户端一个ACK响应，然后继续发数据，当发完了再发送FIN信号告知客户端结束通信。这就是为什么要把ACK和FIN分开发送的原因。</p><p>在最后进入TIME_WAIT状态，通常这个状态会持续一段时间：2msl，这又是为什么？</p><p>首先解释一下MSL (Maximum Segment Lifetime):官方建议：2分钟,TCP中实际是30s。<br>通俗的讲，在客户端最后接收到服务器发来的FIN信号后需要再给服务器一个应答，然而服务器是不一定能收到这个应答的。如果收不到服务器会再次发送FIN信号，但客户端要是给完应答直接关了通道的话，就收不到了，这就导致服务器端的连接关不掉。为了防止这个意外的发送，就让TIME_WAIT状态持续2msl，来保证服务器丢失ACK应答后能再次发送ACK，确保双方通道都能关闭。</p><blockquote><p><strong>半连接：</strong>当TCP链接中A向B发送FIN请求关闭，另一端B回应ACK之后(A端进入FIN_WAIT_2状态)，并没有立即发送FIN给A，A方处于半连接状态(半开关)，此时A可以接收B发送的数据，但是A已经不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /socket.h&gt;</span></span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">int</span> how)</span> ;<br> sockfd:需要关闭`socket`的描述符<br> how:允许为`shutdown`操作选择以下几种方式:<br> SHUT_RD(O):关闭`sockfd`上的读功能，此选项将不允许`sockfd`进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。<br> SHUT_wR(<span class="hljs-number">1</span>):关闭`sockfd`的写功能，此选项将不允许`sockfd`进行写操作。进程不能在对此套接字发出写操作。<br> SHUT_RDNR(<span class="hljs-number"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /socket.h&gt;</span></span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd，<span class="hljs-type">int</span> how)</span> ;<br> sockfd:需要关闭`socket`的描述符<br> how:允许为`shutdown`操作选择以下几种方式:<br> SHUT_RD(O):关闭`sockfd`上的读功能，此选项将不允许`sockfd`进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。<br> SHUT_wR(<span class="hljs-number">1</span>):关闭`sockfd`的写功能，此选项将不允许`sockfd`进行写操作。进程不能在对此套接字发出写操作。<br> SHUT_RDNR(<span class="hljs-number">2</span>):关闭`sockfd`的读写功能。相当于调用`shutdown`两次:首先是以`SHUT_RD` ,然后是`SHUT_WR`。<br></code></pre></td></tr></tbody></table></figure><p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:<br>1.如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用close，套接字将被释放。<br>⒉在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但如果一个进程close(sfd)将不会影响到其它进程。</p><p><strong>端口复用：</strong>当设置socket与端口绑定时，其他socket就无法再使用这个端口了。但这引出了一个问题，当通信双发一端如服务器还没来得及断开连接就突然关掉了，这时候服务器TCP的通信状态就会变成TIME_WAIT状态，端口仍然占用着，直到过去2msl时间才会彻底关闭socket解除端口占用。为了解决这个问题就利用了端口复用技术。</p><p>端口复用就是让端口不止能连接到一个socket，这样即使一方突然关掉，也能重新使用该端口。对应Linux系统的API接口为<code>setsockopt</code>。</p></blockquote><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><blockquote><p>滑动窗口(Sliding window)是一种流量控制技术。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包(称窗口尺寸)。  </p></blockquote><p>TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报。<br>滑动窗口是TCP中实现诸如ACK确认、流量控制、拥塞控制的承载结构。</p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Network-foundation/image.6r3zm71zzug0.jpg" alt="image" style="zoom:80%;"><p>上图为TCP通信收发数据的一次流程图。<br>其中mss : Maximum segment size(一条数据的最大的数据量)；win:滑动窗口</p><ol><li>客户端向服务器发起连接，客户端的滑动窗口是4096，一次发送的最大数据量是1460</li><li>服务器接收连接，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024</li><li>第三次握手应答</li><li>4-9客户端连续给服务器发送了6k的数据，每次发送1k，到第九步时服务器的缓冲区满了，需要处理</li><li>第10次，服务器告诉客户端:发送的6k数据已经接收到，存储在缓冲区中，缓冲区数据已经处理了2k,可用窗口大小是2k</li><li>第11次，服务器告诉客户端:发送的6k数据已经接收到，存储在缓冲区中，缓冲区数据已经处理了4k,可用窗口大小是4</li><li>第12次，客户端给服务器发送了1k的数据</li><li>第13次，客户端主动请求和服务器断开连接，并且给服务器发送了1k的数据</li><li>第14次，服务器回复ACK 8194，a:同意断开连接的请求b:告诉客户端已经接受到方才发的2k的数据c:滑动窗口2k</li><li>第15、16次，通知客户端滑动窗口的大小</li><li>第17次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</li><li>第18次，第四次回收,客户端同意了服务器端的断开请求</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络通信基础（1）</title>
    <link href="/network-communications-1.html"/>
    <url>/network-communications-1.html</url>
    
    <content type="html"><![CDATA[<h1 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C/S结构"></a>C/S结构</h1><blockquote><p><strong>服务器-客户机</strong>，即Client - Server (C/S）结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。客户机是因特网上访问别人信息的机器，服务器则是提供信息供人访问的计算机。<br>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务器，这就对服务器的硬件处理数据能力提出了很高的要求。</p></blockquote><p><strong>优点：</strong></p><ol><li>能充分发挥客户端PC的处理能力，很多工作可以在客户端<strong>处理后再提交</strong>给服务器，所以C/S结构客户端<strong>响应速度快</strong>;</li><li>操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求;</li><li>C/S结构的管理信息系统具有较强的事务处理能力，能<strong>实现复杂的业务流程</strong>;</li><li><strong>安全性较高</strong>，C/S一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强，<strong>一般高度机密的信息系统采用C/S结构适宜</strong>。</li></ol><p><strong>缺点：</strong></p><ol><li>客户端需要安装专用的客户端软件。首先涉及到<strong>安装的工作量</strong>，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，<strong>其维护和升级成本非常高</strong>;</li><li>对客户端的操作系统一般也会有限制，<strong>不能够跨平台</strong>。</li></ol><h1 id="B-x2F-S结构"><a href="#B-x2F-S结构" class="headerlink" title="B/S结构"></a>B/S结构</h1><blockquote><p>B/S结构(BrowserlServer，<strong>浏览器/服务器模式</strong>)，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的<strong>核心部分</strong>集中到服务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如Firefox或 Internet Explorer，服务器安装SQLServer、Oracle、MySQL等数据库。浏览器通过Web Server同数据库进行数据交互。</p></blockquote><p><strong>优点</strong></p><p>总体成本低、维护方便、分布性强、开发简单，可以不用安装任何专门的软件就能实现在任何地方进行操作，<strong>客户端零维护</strong>，系统的<strong>扩展非常容易</strong>，只要有一台能上网的电脑就能使用。</p><p><strong>缺点</strong></p><ol><li><strong>通信开销大</strong>、系统和数据的<strong>安全性较难保障</strong>;</li><li>个性特点明显降低，无法实现具有个性化的功能要求;</li><li>协议一般是固定的: http/https（无法传输数据量大的文件）</li><li>客户端服务器端的交互是请求-响应模式，通常动态刷新页面，<strong>响应速度明显降低</strong>。</li></ol><h1 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h1><blockquote><p>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网络接口卡NIC。其拥有MAC地址，属于OSI模型的第2层，它使得用户可以通过电缆或无线相互连接。每一个网卡都有一个被称为MAC地址的<strong>独一无二</strong>的48位串行号。网卡的主要功能:1.数据的封装与解封装(数据解析)；2链路管理；3.数据编码与译码。</p></blockquote><p>MAC地址(Media Access Control Address)，也称为局域网地址、以太网地址、物理地址或硬件地址，它是一个用来<strong>确认网络设备位置</strong>的位址，由网络设备制造商<strong>生产时烧录</strong>在网卡中。在OSI模型中，第三层网络层负责IP地址，第二层<strong>数据链路层负责MAC位址</strong>。MAC地址用于在网络中唯一标识一个网卡，一台设备，若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。MAC地址的长度为48位(6个字节)，通常表示为12个16进制数，如:00-16-EA-AE-3C-40就是一个MAC地址，其中前3个字节，16进制数00-16-EA代表网络硬件制造商的编号，它由IEEE(电气与电子工程师协会）分配，而后3个字节，16进制数AE-3C-40代表该制造商所制造的某个网络产品(如网卡)的系列号。只要不更改自己的MAC地址，MAC地址在世界是唯一的。</p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><blockquote><p>IP协议是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。IP协议实际上是一套由软件程序组成的协议软件，它<strong>把各种不同”帧”统一转换成”IP数据报”格式</strong>，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有”开放性”的特点。IP协议也可以叫做”因特网协议””。<br>IP地址(Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。IP地址是IP协议提供的一种统一的地址格式，<strong>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</strong>。<br>IP地址是一个32位的二进制数，通常被分割为4个”8位二进制数”(也就是4个字节)。IP地址通常用”点分十进制”表示成(a.b.c.d)的形式，其中,a,b,c,d都是0~255之间的十进制整数。例:点分十进IP地址(100.4.5.6)，实际上是32位二进制数(01100100.00000100.00000101.00000110)。</p></blockquote><p>Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。其中A、B、C3类(如下表格）由Internet委员会在全球范围内统一分配，D、E类为特殊地址。</p><table><thead><tr><th align="center">类别</th><th align="center">最大网络数</th><th align="center">IP地址范围</th><th align="center">单个网段最大主机数</th><th align="center">私有IP地址范围</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">126（2^7-2）</td><td align="center">1.0.0.1-126.255.255.254</td><td align="center">16777214</td><td align="center">10.0.0.0-10.255.255.255</td></tr><tr><td align="center">B</td><td align="center">16384(2^14)</td><td align="center">128.0.0.1-191.255.255.254</td><td align="center">65534</td><td align="center">172.16.0.0-172.31.255.255</td></tr><tr><td align="center">C</td><td align="center">2097152(2^21)</td><td align="center">192.0.0.1-223.255.255.254</td><td align="center">254</td><td align="center">192.168.0.0-192.168.255.255</td></tr></tbody></table><h2 id="A类IP地址"><a href="#A类IP地址" class="headerlink" title="A类IP地址"></a>A类IP地址</h2><p>一个A类IP地址是指，在IP地址的四段号码中，<strong>第一段号码为网络号码，剩下的三段号码为本地计算机的号码</strong>。如果用二进制表示IP地址的话<strong>，A类IP地址就由1字节的网络地址和3字节主机地址组成</strong>，**网络地址的最高位必须是“0”**。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。<br>A类IP地址地址范围1.0.0.1-126.255.255.254。最后一个.255是广播地址。<br>A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。</p><h2 id="B类IP地址"><a href="#B类IP地址" class="headerlink" title="B类IP地址"></a>B类IP地址</h2><p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，<strong>B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是”10””</strong>。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。<br>B类IP地址地址范围128.0.0.1-191.255.255.254 。最后一个是广播地址。<br>B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。</p><h2 id="C类IP地址"><a href="#C类IP地址" class="headerlink" title="C类IP地址"></a>C类IP地址</h2><p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是”110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数星较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。<br>C类IP地址范围192.0.0.1-223.255.255.254。最后一个是广播地址。<br>C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。</p><h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><p>每一个字节都为О的地址(“0.0.0.0”）对应于当前主机;<br>IP地址中的每一个字节都为1的IP地址(“255.255.255.255”)是当前子网的广播地址;IP地址中凡是以“11110”开头的E类IP地址都保留用于将来和实验使用。<br>IP地址中不能以十进制127”作为开头，该类地址中数字127.0.0.1到127.255.255.255用于回路测试，如:127.0.0.1可以代表本机IP地址。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><blockquote><p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址—起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。（实现IP地址的划分，有效利用IP）<br>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。</p></blockquote><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><blockquote><p>“端口”认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，<strong>特指TCP/IP协议中的端口</strong>，是逻辑意义上的端口。例如计算机中的80端口、21端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用R11插口也属于物理端口的范畴。<br>如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536个。端口是通过端口号来标记的，端口号只有整数，范围是从0到65535 (2^16-1)。</p></blockquote><h2 id="端口类型"><a href="#端口类型" class="headerlink" title="端口类型"></a>端口类型</h2><p><strong>1.周知端口(Well Known Ports)</strong><br>用于一些特定服务的公认端口。例如80端口分配给WWW服务，21端口分配给FTP服务，23端口分配给Telnet服务等等。此类端口一般不可占用，有的不能改变。<br><strong>⒉.注册端口(Registered Ports)</strong><br>端口号从1024到49151，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是用户安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以由用户端动态选用为源端口。（用户常用端口）<br><strong>3. 动态端口/私有端口(Dynamic Ports / Private Ports)</strong><br>动态端口的范围是从49152到65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。</p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多进程的一些知识点</title>
    <link href="/multiprocess-development.html"/>
    <url>/multiprocess-development.html</url>
    
    <content type="html"><![CDATA[<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><p>进程是正在运行的程序的实例。是操作系统动态执行的基本单元。在传统操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><ol><li>同一主机：<br>$$<br>同一主机进程间通信=\left{<br>\begin{matrix}<br> Unix进程间通信方式 \<br> System V进程间通信方式 \<br> POSIX进程间通信方式<br>\end{matrix}<br>\right.<br>$$<br>$$<br>Unix进程间通信方式=\left{<br>\begin{matrix}<br> 匿名管道 \<br> 有名管道 \<br> 信号<br>\end{matrix}<br>\right.<br>$$<br>$$<br>System V进程间通信 、<br> POSIX进程间通信 =\left{<br>\begin{matrix}<br> 消息队列 \<br> 共享内存 \<br> 信号量<br>\end{matrix}<br>\right.<br>$$</li><li>不同主机（网络）进程间通信：Socket<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1></li><li>管道是在内核内存中维护的缓冲器，不同操作系统大小不一定相同。</li><li>管道拥有文件的特质：读和写。匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</li><li>一个管道是一个字节流，可以从中读取任意大小的数据块。</li><li>管道传递的数据是顺序的，读出来的顺序和写入时一致。</li><li>管道的数据传递是单向的，一端写入，一端用于读取，属于半双工。</li><li>管道内数据是一次性操作，一旦被读走，就会被删掉来释放空间。</li><li>匿名管道只能在具有公共祖先的进程中使用。（因为拥有相同的文件描述符，指向的管道一致）。</li><li>管道的数据结构是环形的。</li></ol><p>（堵塞）管道<strong>读写</strong>特点：</p><ol><li>如果管道写端的文件描述符都关闭了，且管道内无数据后，再次read将会<strong>返回0</strong>，而不是堵塞。</li><li>如果管道读端的文件描述符都关闭了，这时候向管道写数据，该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。</li><li>如果管道读端的文件描述符没有关闭，且没有从管道读数据，那么在管道写满后再次write会<strong>堵塞</strong>，直到有空位置才能再次写入数据并返回。</li><li>进程启动，若只先开启读端，将会堵塞，直到读端开启。同理，若只开启写段，也会堵塞到读端开启。</li></ol><p><strong>匿名管道（pipe）</strong>：通过一个没有实体的管道，实现具有亲缘关系的进程间通信。</p><p><strong>有名管道（FIFO）</strong>：克服了匿名管道只能用于亲缘关系的进程通信。<br>有名管道提供了一个路径名与之关联，以FIFO文件形式存在于文件系统中，进程间可以访问该路径而彼此通信。</p><p>匿名有名的不同点：</p><ol><li>FIFO在文件系统中作为一个特殊文件存在，但其内容存放于内存中。</li><li>FIFO文件在进程退出后继续保存在文件系统中。</li><li>FIFO有名字，因而不相关的进程可以访问该文件进行通信。</li></ol><h1 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h1><p>kill -l: 查看系统定义的信号列表<br>信号编号-信号名-默认动作-对应事件<br>2:SIGINT：终止进程。&lt;Ctrl+C&gt;，用户终端向正在运行中的由该终端启动的程序发出此信号。<br>3.SIGQUIT：终止进程。&lt;Ctrl+\&gt;,同信号2。<br>9.SIGKILL：终止进程（可以杀死任何进程）。无条件终止进程，该信号不能被忽略，处理和阻塞。<br>11.SIGSEGV：终止进程并产生core文件。指示进程进行了无效内存访问。<br>13.SIGPIPE：终止进程。pipe向一个没有读端的管道写数据。<br>17.SIGCHIL：忽略这个信号。子进程结束时，父进程收到该信号。<br>18.SIGCONT：继续/忽略。如果进程已停止，则使其继续运行。<br>19.SIGSTOP：终止进程。停止进程的执行。该信号不能被忽略，处理和阻塞。<br>SIGKILL和SIGSTOP只能执行默认动作。</p><p>查看信号详细信息：man 7 signal<br>信号的五种默认处理动作：</p><ol><li>Term：终止进程</li><li>Ign：当前进程忽略掉这个信号</li><li>Core：终止进程并生成core文件</li><li>Stop：暂停当前进程</li><li>Cont：继续执行当前被暂停的进程<br>信号的状态：产生、未决（没有被处理的状态）、递达（信号被处理了）</li></ol><p>SIGCHLD信号产生条件：<br>    * 子进程终止时<br>    * 子进程接收到SIGSTOP信号停止时<br>    * 子进程处在停止态，接收到SIGCONT唤醒时<br>产生的SIGCHLD信号会发送给父进程，父进程默认忽略该信号。</p><h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>两个主要信号集：<br>阻塞信号集：阻止信号响应，并不阻止产生。<br>未决信号集：还未产生响应的信号。</p><ol><li>在内核中，所有没被处理的信号存储在一个集合中，信号状态存储在第二个标志位上。标志位为0，信号不是处于未决状态；标志位为1，信号处于未决状态。</li><li>处理未决信号前，需要和阻塞信号机比较。阻塞信号集默认不阻塞任何信号，如果要阻塞，需要调用系统API。</li><li>在处理未决信号前对阻塞信号集的标志位进行查询。若没有设置阻塞，则正常处理信号；若阻塞了，信号就继续处于未决状态，直至阻塞解除。</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-comment">// 以下五个函数控制的是用户自定义的信号集sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 清空信号集中的数据，将信号集中的所有的标志位置0</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将信号集中所有的标志位置1</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为1，表示阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为0，表示不阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 判断某个信号是否阻塞</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -set: 需要操作的数据集</span><br><span class="hljs-comment">    -signum: 需要判断哪个信号</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    0: 不阻塞</span><br><span class="hljs-comment">    1: 阻塞</span><br><span class="hljs-comment">    -1: 失败</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">kernel_sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">kernel_sigset_t</span> *oldset)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将自定义信号集中的数据设置到内核中(阻塞,解除阻塞)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -how:</span><br><span class="hljs-comment">        -SIG_BLOCK: 设置阻塞信号, 要设置的位,置1</span><br><span class="hljs-comment">        -SIG_UNBLOCK: 解除阻塞,  要解除的位,置1</span><br><span class="hljs-comment">        example: 内核默认阻塞信号集mask, 设置阻塞mask|set,再解除阻塞mask&amp;~set. 即当设置的信号一样的时候,阻塞和非阻塞的值一样</span><br><span class="hljs-comment">    -set: 用户初始化好的自定义信号集</span><br><span class="hljs-comment">    -oldset: 保存之前的信号集状态,一般为NULL</span><br><span class="hljs-comment">    return: </span><br><span class="hljs-comment">        success: return 0</span><br><span class="hljs-comment">        fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 获取内核中的未决信号集</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 信号捕捉优先使用这个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 信号捕捉</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -signum: 需要捕捉的信号的编号或宏值</span><br><span class="hljs-comment">    -act: 捕捉到信号后的处理动作</span><br><span class="hljs-comment">    -oldact: 上一次信号捕捉的设置,一般为NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction {</span><br><span class="hljs-comment">               void (*sa_handler)(int); //指向的函数指针</span><br><span class="hljs-comment">               void (*sa_sigaction)(int, siginfo_t *, void *); //不常用</span><br><span class="hljs-comment">               sigset_t sa_mask;    //临时阻塞信号集, 信号捕捉过程中,临时阻塞某些信号</span><br><span class="hljs-comment">               int sa_flags;    //0: 表示使用sa_handler处理信号  1: 表示使用sa_sigaction处理信号</span><br><span class="hljs-comment">               void (*sa_restorer)(void); //已无用,使用NULL</span><br><span class="hljs-comment">           };</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"><code class="language-hljs c"><span class="hljs-comment">// 以下五个函数控制的是用户自定义的信号集sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 清空信号集中的数据，将信号集中的所有的标志位置0</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将信号集中所有的标志位置1</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为1，表示阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 设置信号集中的某一个信号对应的标志位为0，表示不阻塞该信号</span><br><span class="hljs-comment">parameter: -set, 传出参数, 需要操作的信号集</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: 返回0</span><br><span class="hljs-comment">    fail: 返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 判断某个信号是否阻塞</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -set: 需要操作的数据集</span><br><span class="hljs-comment">    -signum: 需要判断哪个信号</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    0: 不阻塞</span><br><span class="hljs-comment">    1: 阻塞</span><br><span class="hljs-comment">    -1: 失败</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">kernel_sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">kernel_sigset_t</span> *oldset)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将自定义信号集中的数据设置到内核中(阻塞,解除阻塞)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -how:</span><br><span class="hljs-comment">        -SIG_BLOCK: 设置阻塞信号, 要设置的位,置1</span><br><span class="hljs-comment">        -SIG_UNBLOCK: 解除阻塞,  要解除的位,置1</span><br><span class="hljs-comment">        example: 内核默认阻塞信号集mask, 设置阻塞mask|set,再解除阻塞mask&amp;~set. 即当设置的信号一样的时候,阻塞和非阻塞的值一样</span><br><span class="hljs-comment">    -set: 用户初始化好的自定义信号集</span><br><span class="hljs-comment">    -oldset: 保存之前的信号集状态,一般为NULL</span><br><span class="hljs-comment">    return: </span><br><span class="hljs-comment">        success: return 0</span><br><span class="hljs-comment">        fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 获取内核中的未决信号集</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 信号捕捉优先使用这个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 信号捕捉</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -signum: 需要捕捉的信号的编号或宏值</span><br><span class="hljs-comment">    -act: 捕捉到信号后的处理动作</span><br><span class="hljs-comment">    -oldact: 上一次信号捕捉的设置,一般为NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction {</span><br><span class="hljs-comment">               void (*sa_handler)(int); //指向的函数指针</span><br><span class="hljs-comment">               void (*sa_sigaction)(int, siginfo_t *, void *); //不常用</span><br><span class="hljs-comment">               sigset_t sa_mask;    //临时阻塞信号集, 信号捕捉过程中,临时阻塞某些信号</span><br><span class="hljs-comment">               int sa_flags;    //0: 表示使用sa_handler处理信号  1: 表示使用sa_sigaction处理信号</span><br><span class="hljs-comment">               void (*sa_restorer)(void); //已无用,使用NULL</span><br><span class="hljs-comment">           };</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对<strong>其他所有</strong>共享同一个段的进程可用。<br>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。<br>共享内存和内存映射的区别：</p><ol><li><p>共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)</p></li><li><p>共享内存效果更高</p></li><li><p>内存</p><p> 所有的进程操作的是同一块共享内存。<br> 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</p></li><li><p>数据安全</p><ul><li>进程突然退出<br>  共享内存还存在内存映射区消失</li><li>运行进程的电脑死机，宕机了<br>  数据存在在共享内存中，没有了<br>  内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</li></ul></li><li><p>生命周期</p><ul><li>内存映射区: 进程退出，内存映射区销毁</li><li>共享内存: 进程退出，共享内存还在，标记删除，或者关机</li></ul></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-comment">//共享内存相关: 创建共享内存段-&gt;关联-&gt;操作共享内存-&gt;解除关联-&gt;删除关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 创建一个新的共享内存段,或者获取一个既有内存共享段的标识</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -key: 通过Key找到或创建一个共享内存,一般16进制</span><br><span class="hljs-comment">    -size: 共享内存的大小 </span><br><span class="hljs-comment">    -shmflg:</span><br><span class="hljs-comment">        访问权限: rwx</span><br><span class="hljs-comment">        附加属性:</span><br><span class="hljs-comment">            IPC_CREAT: 创建一个新的共享内存段</span><br><span class="hljs-comment">            IPC_EXCL: 判断共享内存是否存在,需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 返回共享内存引用的id, &gt;0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将共享内存段与当前进程进行关联</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID，由shmget获取</span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址,指定NULL,由内核指定</span><br><span class="hljs-comment">    -shmflg: </span><br><span class="hljs-comment">        SHM_RDONLY: 读权限,必须要有该权限</span><br><span class="hljs-comment">        0: 读写权限</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: 返回共享内存的首地址</span><br><span class="hljs-comment">    fail: -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 解除当前进程与共享内存的关联</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 删除共享内存, 共享内存需要删除才会消失,创建共享内存的进程被销毁对共享内存没有影响(可重复删除,因为只是标记)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID</span><br><span class="hljs-comment">    -cmd: </span><br><span class="hljs-comment">        IPC_STAT: 获取共享内存的当前状态</span><br><span class="hljs-comment">        IPC_SET: 设置共享内存状态</span><br><span class="hljs-comment">        IPC_RMID: 标记共享内存被销毁,只是标记,需要与其连接的进程全部销毁</span><br><span class="hljs-comment">    -buf: 需要设置或获取的共享内存的属性信息</span><br><span class="hljs-comment">        IPC_STAT: buf用来存储数据</span><br><span class="hljs-comment">        IPC_SET: buf中需要初始化数据,设置到内核</span><br><span class="hljs-comment">        IPC_RMID: NULL</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 根据指定的路径名和int值,生成一个共享内存key</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -pathname: 指定一个存在的路径</span><br><span class="hljs-comment">    -proj_id: int值,系统使用其中一个字节,8位</span><br><span class="hljs-comment"><code class="language-hljs c"><span class="hljs-comment">//共享内存相关: 创建共享内存段-&gt;关联-&gt;操作共享内存-&gt;解除关联-&gt;删除关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 创建一个新的共享内存段,或者获取一个既有内存共享段的标识</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -key: 通过Key找到或创建一个共享内存,一般16进制</span><br><span class="hljs-comment">    -size: 共享内存的大小 </span><br><span class="hljs-comment">    -shmflg:</span><br><span class="hljs-comment">        访问权限: rwx</span><br><span class="hljs-comment">        附加属性:</span><br><span class="hljs-comment">            IPC_CREAT: 创建一个新的共享内存段</span><br><span class="hljs-comment">            IPC_EXCL: 判断共享内存是否存在,需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">return: </span><br><span class="hljs-comment">    success: return 返回共享内存引用的id, &gt;0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 将共享内存段与当前进程进行关联</span><br><span class="hljs-comment">parameter:</span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID，由shmget获取</span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址,指定NULL,由内核指定</span><br><span class="hljs-comment">    -shmflg: </span><br><span class="hljs-comment">        SHM_RDONLY: 读权限,必须要有该权限</span><br><span class="hljs-comment">        0: 读写权限</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: 返回共享内存的首地址</span><br><span class="hljs-comment">    fail: -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 解除当前进程与共享内存的关联</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmaddr: 共享内存的起始地址</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">    success: return 0</span><br><span class="hljs-comment">    fail: return -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 删除共享内存, 共享内存需要删除才会消失,创建共享内存的进程被销毁对共享内存没有影响(可重复删除,因为只是标记)</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -shmid: 共享内存的标识ID</span><br><span class="hljs-comment">    -cmd: </span><br><span class="hljs-comment">        IPC_STAT: 获取共享内存的当前状态</span><br><span class="hljs-comment">        IPC_SET: 设置共享内存状态</span><br><span class="hljs-comment">        IPC_RMID: 标记共享内存被销毁,只是标记,需要与其连接的进程全部销毁</span><br><span class="hljs-comment">    -buf: 需要设置或获取的共享内存的属性信息</span><br><span class="hljs-comment">        IPC_STAT: buf用来存储数据</span><br><span class="hljs-comment">        IPC_SET: buf中需要初始化数据,设置到内核</span><br><span class="hljs-comment">        IPC_RMID: NULL</span><br><span class="hljs-comment">return:</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>{}<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">function: 根据指定的路径名和int值,生成一个共享内存key</span><br><span class="hljs-comment">parameter: </span><br><span class="hljs-comment">    -pathname: 指定一个存在的路径</span><br><span class="hljs-comment">    -proj_id: int值,系统使用其中一个字节,8位</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><h1 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程组是一组相关进程的集合。</li><li>进程组由一个或多个共享同一进程组标识符(PGID)的进程组成。</li><li>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID，新进程</li><li>会继承其父进程所属的进程组ID。</li><li>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。</li><li>进程组首进程无需是最后一个离开进程组的成员。<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2></li><li>会话是一组进程组的集合。</li><li>会话首进程是创建该新会话的进程，其进程ID 会成为会话 ID。新进程会继承其父进程的会话ID。</li><li>一个会话中的所有进程共享<strong>单个</strong>控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li><li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li><li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li></ul><p>#守护进程（Daemon 进程）<br>也称精灵进程，是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端且周期性执行某种任务或等待处理某些事件，名字一般以d结尾，如Internet服务器inetd,Web服务器httpd。</p><ul><li>生命周期长，在系统启动的时候就被创建并一直运行至系统关闭。</li><li>后台运行且没有控制终端，确保内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号。<h2 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h2></li></ul><ul><li>执行一个 fork()，之 后父进程退出，子进程继续执行。（*必要）<br>（父进程退出能够不让终端在父进程结束后显示shell提示符；使用fork确保创建的子进程不会成为进程组的首进程） </li><li>子进程调用setsid()开启一个新会话。（*必要）<br>（首先，进程创建新的会话时，会该进程会成为新会话新进程组的首进程，如果用父进程创建，回合原来的进程组会话冲突，因此要用子进程创建。其次，创建新的会话，如果不建立连接的话，会话是没有控制终端的，也就符合的守护进程的要求。）</li><li>清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限。(函数umask(xxx);)</li><li>修改进程的当前工作目录，通常会改为根目录(/)。<br>（主要因为守护进程是要存活到系统结束，如果在其他目录，该目录就无法卸载，如u盘目录。函数chdir();）</li><li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。<br>（原因同上，防止无法卸载某些关联磁盘）</li><li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null并使用dup2()使所有这些描述符指向这个设备。<br>（防止系统调用这些关闭了的文件描述符后出错，重定向到null目录，null目录内的内容会自动被丢弃）</li><li>核心业务逻辑（*必要）</li></ul>]]></content>
    
    
    <categories>
      
      <category>后台开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多进程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中输入一条URL到页面显示的过程</title>
    <link href="/website-communication.html"/>
    <url>/website-communication.html</url>
    
    <content type="html"><![CDATA[<p>在浏览器中输入一条URL,然后网页会给出响应，进入你想要的页面。那么浏览器又是如何根据一条URL找到对应的信息的呢？接下来就具体说说消息的传递流程。</p><span id="more"></span>  <h1 id="总体流程图"><a href="#总体流程图" class="headerlink" title="总体流程图"></a>总体流程图</h1><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/URL-Communication/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B-%E7%BD%91%E5%9D%80%E8%BE%93%E5%85%A5.39a91oqu6qy0.jpg" alt="网络通信流程-网址输入"></p><p>首先给出总体的流程图，如上图，实线箭头代表数据流向，虚线箭头代表具体内容。本文将根据这个流程图来展开说明。</p><h1 id="第一步：输入URL"><a href="#第一步：输入URL" class="headerlink" title="第一步：输入URL"></a>第一步：输入URL</h1><p><code>URL</code>就是我们要输入的网址。URL的组成为<code>http://xxxx(webserver)/... </code>，其中<code>“http:”</code>代表访问数据的协议，就是规定数据需要变成什么样的规范，<code>"xxxx"</code>代表的是<code>web</code>服务器，后面的<code>“/...”</code>代表的是对应服务器内的文件路径。<br>所以，当浏览器收到输入的<code>URL</code>时，首先就可以得到我们要访问的web服务器是什么和我们要访问的文件路径，然后就可以根据这些信息生成<code>http</code>消息（发送时为请求报文，接收时为响应报文），这些消息里就包含了我们要访问的内容，同时通过DNS查询到了服务器的IP地址。之后就进入了第二步利用<code>TCP/IP</code>协议传输消息。</p><h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><p>上面是大方向的数据传输过程，文中有提到服务器<code>IP</code>地址查询，这一步又时如何实现的呢。以<code>www.baidu.com</code>为例，这是一个很常见的域名，也就是上面说的代表的是<code>web</code>服务器。那么如何根据域名查询<code>IP</code>呢，这里利用的就是<code>DNS</code>服务器，它保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，浏览器可以根据域名去访问<code>DNS</code>服务器，查询对应的IP是什么，然后再返回给浏览器，实现<code>IP</code>地址查询。</p><p>这里简单谈谈DNS查询流程。要知道域名是分层级的，每层之间用<code>.</code>作间隔，层级越高越靠后，分为：</p><ul><li><p>根 DNS 服务器（.）</p></li><li><p>顶级域 DNS 服务器（.com）</p></li><li><p>权威 DNS 服务器（server.com）</p></li></ul><p>在实际域名中，在最后其实是有个<code>.</code>的，如“<code>www.baidu.com.</code>”。当浏览器去查询<code>ip</code>地址时：</p><ol><li>首先访问的是本地DNS服务器，看看里面有没有缓存要查询的域名对应的IP，有的话直接返回，没有的话本地DNS就会去根域名服务器查询。</li><li>根域名收到请求后，会根据域名告诉本地DNS下一级也就是顶级域服务器的地址，具体来说就是<code>".com"</code>，让它去那里查询。</li><li>顶级域服务器收到请求后，会告诉本地DNS权威服务器的地址。</li><li>本地DNS找到权威服务器的后，权威服务器会查询IP，将其返回给本地DNS</li><li>本地DNS再把IP地址发给浏览器，这样就得到访问域名对应的IP地址了。</li></ol><h1 id="第二步-生成TCP报文"><a href="#第二步-生成TCP报文" class="headerlink" title="第二步 生成TCP报文"></a>第二步 生成TCP报文</h1><p>对于http报文，浏览器会利用socket库来委托协议栈工作，最先的步骤就是生成TCP报文。其中报文中的源端口号和目的端口号，这是明确数据要发送到哪个应用。</p><p>在正式发送数据前，浏览器需要和服务器建立连接，利用的就是TCP协议，需要经过三次握手才能建立通信通路，目的是<strong>保证双方都有发送和接收的能力</strong>，断开连接时需要经历4次挥手。</p><p>当数据较长，超过了<code>MSS</code>长度，TCP会把数据拆解为一块块的数据块-称为”段”。每个被拆解的数据块都会添加TCP的头部信息。</p><blockquote><p>MSS:除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</p></blockquote><p>TCP主要负责可靠的数据传输，报文生成后就进入了TCP/IP的第二步–IP报文</p><h1 id="第三步-生成IP报文"><a href="#第三步-生成IP报文" class="headerlink" title="第三步 生成IP报文"></a>第三步 生成IP报文</h1><p>生成IP报文的过程要明确源<code>IP</code>和目的<code>IP</code>。源<code>IP</code>地址就是客户端输出的 <code>IP</code> 地址。目的<code>IP</code>就是通过 <code>DNS</code> 域名解析得到的 <code>Web</code> 服务器 IP。这里有了一个问题，当客户端有多个网卡，会存在多个IP地址，源<code>IP</code>该怎么选？</p><p>解决办法就是利用<strong>路由表</strong>规则。Linux中可通过<code>route -n</code>查看系统路由表，如下图所示。</p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/URL-Communication/image.2szp8sjb1sc0.jpg" alt="image"></p><p>路由表规则：把目的IP地址依次和<strong>子网掩码</strong>（<code>Genmask</code>）进行 <strong>与运算</strong>，判断结果和<strong>目标</strong><code>Destination</code>是否一致，一致则源<code>IP</code>就是对应网卡接口的IP地址。否则继续向下查询判断。如果其他所有条目都无法匹配，那么就会选择默认网关，其对应的子网掩码<code>Netmask</code>和<code>Destination</code>都是<code>0.0.0.0</code>。</p><p>IP报文的生成为数据指明了目的地，但两个IP之间的距离可能会很远，那么直接进行端到端的传输是不现实的，需要经历一层层的中转，也就是每次都要指明一个中转站的目的地，这个功能的实现要依赖MAC地址的生成。</p><h1 id="第四步-生成MAC报文"><a href="#第四步-生成MAC报文" class="headerlink" title="第四步 生成MAC报文"></a>第四步 生成MAC报文</h1><blockquote><p>一般在 TCP/IP 通信里，MAC 报头的<strong>协议类型</strong>只使用：<code>0800</code> ： IP 协议和<code>0806</code> ： ARP 协议。</p></blockquote><p>在 MAC 报文里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。<br>发送方MAC地址就是使用的网卡的MAC地址。接收方MAC地址为下一站的MAC地址。那么我们如何知道接收方MAC地址？</p><p>前面第三步中提到过路由表，利用该表，得到了该使用哪个网卡接口，就是其IP地址，也是我们要发送报文的第一个中转站。明确目的地后，就需要获取对应的MAC地址才能准确发送过去，这就利用到了 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p><p><code>ARP协议</code>会在以太网中以广播的形式向每个设备询问这个IP地址是谁的，只有IP的持有者会给出响应返回MAC地址，如此一来就得到了接收方的MAC地址。</p><blockquote><p>操作系统内有一块<code>ARP缓存</code>，当要广播查询时，会先查询缓存，没有的话再继续广播，返回后会将结果放入缓存中。查看缓存<code>arp -a</code></p></blockquote><p>明确了中转目的地后，就开始从物理层面进入了发送数据的第一步–网卡。</p><h1 id="第五步-数据出口-网卡"><a href="#第五步-数据出口-网卡" class="headerlink" title="第五步 数据出口-网卡"></a>第五步 数据出口-网卡</h1><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。准备完成后就会讲网络包从数字信号变为电信号，发送出去，也就是进入了交换机部分。</p><h1 id="第六步-交换机转发"><a href="#第六步-交换机转发" class="headerlink" title="第六步 交换机转发"></a>第六步 交换机转发</h1><p>交换机把电信号变为数字信号，并决定发送给哪个路由器上。<strong>交换机的端口不具有<code> MAC</code> 地址</strong>，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><blockquote><p>交换机的 <code>MAC</code> 地址表主要包含两个信息：设备的 <code>MAC</code> 地址; 该设备连接在交换机的哪个端口上。</p></blockquote><p>如果有记录则直接从对应端口传输。如果没有，则把信号发送给所有端口，因为其报文内<code>MAC</code>地址的存在，只有相应的接收者才会接收包，其他设备会自动忽略。</p><blockquote><p>发送包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 <code>MAC</code> 地址表，下次也就不需要把包发到所有端口了。</p></blockquote><p>至此，数据脱离了子网，开始进入路由器的层层中转。</p><h1 id="第七步-路由器转发"><a href="#第七步-路由器转发" class="headerlink" title="第七步 路由器转发"></a>第七步 路由器转发</h1><p>路由器区别于交换机，拥有MAC地址和IP地址，性质同网卡，因此数据传输过程和网卡一样，目标<code>IP</code>的选址也需要经过路由表进行选择，再由相应的端口作为发送方将以太网包发送出去。</p><p><strong>路由器接收数据：</strong>电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进行错误校验。如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p><strong>路由器查询路由表确定输出端口：</strong>路由器接收完数据后会把MAC头去掉，然后根据目的IP查询路由表获取下一站的路由IP</p><p><strong>路由器发送数据：</strong>判断查询的网关是<code>IP</code>地址还是<code>0.0.0.0</code>，如果是IP，则意味着还需要再次中转。如果为0，代表到达目的地。</p><blockquote><p>路由器内也有ARP缓存，它获取MAC地址的方式也是查表或是广播。</p></blockquote><p>经过路由器的转发，数据终于抵达了终点-服务器。</p><h1 id="第八步-服务器端"><a href="#第八步-服务器端" class="headerlink" title="第八步 服务器端"></a>第八步 服务器端</h1><p>与从客户端发送数据，层层添加报头相反，数据抵达服务器端后，就是对数据报头的层层拆解。匹配MAC地址，下层协议为IP -&gt; 匹配IP地址，得到下层协议为TCP -&gt; 检验序列号，放入缓存，得到端口号，返回响应 -&gt; 发送给HTTP进程 -&gt; 服务器讲所需网页数据封装在 HTTP 响应报文里 -&gt; 数据发送 。</p><p>最后客户端接收到数据后，确认无误后进行TCP四次挥手，与服务器断开连接。</p><p>以上即为浏览器输入网址到网页显示的全部过程。</p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程的一些知识点</title>
    <link href="/multithreaded-development.html"/>
    <url>/multithreaded-development.html</url>
    
    <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><p>线程是允许应用程序并发执行多个任务的一种机制。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol><li>一个进程可以包含多个线程。</li><li>同一程序中所有线程均会独立执行相同程序，且共享同一份全局内存区域。</li><li>进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。</li><li>线程是轻量级的进程（LWP：Light Weight Process），在Linux下线程的本质还是进程。</li></ol><span id="more"></span><h2 id="与进程的区别："><a href="#与进程的区别：" class="headerlink" title="与进程的区别："></a>与进程的区别：</h2><ul><li>进程间的信息难以共享，父子进程并未共享除只读代码段外的内存，需要采用一些通信方式；而线程能够方便快速地共享信息，只需将数据复制到共享（全局或堆）变量中即可。</li><li>进程调用fork()采用写时复制技术，时间开销较大；而线程创建通常比进程快10倍以上，线程间共享虚拟地址空间，无需复制内存，也无需复制页表。<h2 id="线程间地资源共享"><a href="#线程间地资源共享" class="headerlink" title="线程间地资源共享"></a>线程间地资源共享</h2><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Multithreaded_Development/image.1vkki4h1ss5c.jpg" alt="image"></li></ul><p>反应到虚拟内存空间中为：不共享栈空间和.text</p><div align="center"><img src="https://git.poker/fight-ing-go/image_repository/blob/master/202207/Multithreaded_Development/image.6yzd9vnj8jo0.jpg?raw=true" width="20%/"></div> <h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程的主要优势在于，能够通过全局变量来共享信息。然而这也引发了一个新问题：同一个变量被多个线程同时修改或者某个线程读取了正在被其他线程修改的变量。为解决这个问题，就需要用到线程同步。<br>临界区：是指访问某一<strong>共享资源的代码片段</strong>，并且这段代码的执行应为<strong>原子操作</strong>，也就是执行到临界区时一定要执行完整段代码，不能被其他访问该共享资源的线程打断。<br><strong>线程同步</strong>: 即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</p><h2 id="互斥锁（互斥量）"><a href="#互斥锁（互斥量）" class="headerlink" title="互斥锁（互斥量）"></a>互斥锁（互斥量）</h2><p><strong>互斥锁</strong>是实现线程同步的一种方式，保证线程对任意共享资源的原子操作。<br>互斥锁有两种状态:已锁定(locked和未锁定(unlocked)。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。<br>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源(可能由多个相关变量组成)会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议:</p><ul><li>针对共享资源锁定</li><li>互斥量访问共享资源</li><li>对互斥量解锁</li></ul><div align="center"><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Multithreaded_Development/image.5w3i7rc9voo0.jpg" width="30%/"></div> <h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁</strong>：两个或两个以上的线程在执行过程种，因争夺共享资源而造成的一种互相等待的现象。此时若无外力作用，程序将无法执行下去。<br><strong>死锁可能产生的原因</strong>：当超过一个线程加锁同一组互斥量时，就有可能发生死锁。<br><strong>死锁产生的几种场景</strong>：</p><ul><li>忘记释放锁：线程A给临界区上锁后没有释放，当A再次执行到该临界区，会因已被上锁而进入死锁状态。</li><li>重复加锁：线程A给临界区上锁后，再次给该区上锁而进入死锁状态。常见的是线程里有两个子函数，都进行了上锁操作。</li><li>多线程多锁，抢占锁资源：如图所示，当线程A，B都会访问到资源1和2，当A给资源1上锁而B给资源2上锁时，A若想访问资源2需要B先解锁，而B因为资源1的上锁而堵塞，无法给资源2解锁，此时系统就进入了死锁状态。</li></ul><div align="center"><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/202207/Multithreaded_Development/image.2zzklhmx1uc0.jpg"></div> <h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在使用互斥锁时，当一个线程A把共享资源锁住时，其他线程均不能访问该资源，但多个线程同时读取一块共享资源是不存在问题的。实际中，对数据的读写操作，读操作的次数是远大于写操作的，这样互斥锁的使用就显得有些不太恰当了。为了提高多线程的读写效率，线程定义了读写锁来实现。<br>读写锁的特点：</p><ul><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作</li><li><strong>写是独占的</strong>，写的优先级高(即当同时申请读锁和写锁时，优先分配写锁)</li></ul><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>线程使用中，设计到了一种生产者消费者模型。该模型有三个部分：生产者-&gt;容器-&gt;消费者。生产者负责生产产品，然后将产品放至容器内，消费者负责消耗产品。这里面的生产者与消费者代表的是线程，容器代表的则是共享资源。</p><p>首先，实现这种模型的基础是要实现线程同步，这里用互斥锁解决（因为这里的生产消费都是写的操作，用读写锁没意义）。但这里面产生了两种情况：容器满了，需要提醒消费者消耗资源，等消腾出空余后再生产；容器空了，需要提醒生产者生产资源，等生产完了再消耗。两种情况代表的问题都一样，拿第一种举例。当本次线程生产后（即线程结束），容器满了，但在消费者并没有消耗产品的情况下再次生产产品，此时就会因容器的溢出而出错。所以我们需要一个线程间的“沟通员”，保持线程同步的同时，在容器满的时候，让生产者停下来，让消费者赶紧去消耗产品，等有空余了，再回归原来的模式，让生产者再次生产。线程中，起这种辅助线程同步的就叫<strong>“条件变量”</strong>。（另一种方式：信号量，可用于线程和进程）</p>]]></content>
    
    
    <categories>
      
      <category>后台开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间序列集体异常检测与DBSCAN实战</title>
    <link href="/collective-anomaly-and-dbscan.html"/>
    <url>/collective-anomaly-and-dbscan.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-异常类型"><a href="#1-异常类型" class="headerlink" title="1.异常类型"></a>1.异常类型</h1><ul><li><p><strong>point outliers（点异常）</strong>：这种异常样本往往以单个点的形式存在，其数值相较于整体样本而言是明显异常的（例如异常大或异常小的全局异常）。</p></li><li><p><strong>contextual outliers（上下文异常）</strong>：contextual outlier的异常体现在某一段时间区间。例如下图的第二幅子图，该异常点相对于整体样本而言并无异常，但如果考虑其相邻时间内的样本，其有明显的异常特性。</p><span id="more"></span>  </li><li><p><strong>collective outliers（集体异常）</strong>：指一段时间序列数据为异常。且该段数据中单独看每个样本点都不是异常的，样本的异常性体现在该段数据整体而言是异常的。<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/1.1p11ki2gci80.jpg" alt="1"></p></li></ul><h1 id="2-集体异常检测"><a href="#2-集体异常检测" class="headerlink" title="2.集体异常检测"></a>2.集体异常检测</h1><p>检测集体（模式）异常的常见做法：</p><ul><li><strong>不和谐分析</strong>：利用滑动窗口将时间序列分割成多个子序列，并计算子序列之间的距离（例如，欧几里德距离）以找到时间序列数据中的不和谐，如矩阵配置文件、HotSAX。 </li><li><strong>子序列聚类</strong>：也将子序列分割应用于时间序列数据，并采用子序列作为每个时间点的特征，其中滑动窗口的大小是特征的数量。然后，采用无监督机器学习方法，例如聚类（例如，Kmeans，PCA）或逐点异常值检测算法来检测模式异常值。<br>其中，基于子序列的方法有三种不同的检测策略：<br>基于模型的方法：每个时间序列被转换为模型参数，然后选择合适的模型距离和聚类算法(通常是传统的聚类算法)，并将其应用于提取的模型参数。<br>基于特征的方法：通常在这种方法中，先从每个时间序列中计算等长特征向量，然后进行欧氏距离测量。<br>基于形状的方法：通常直接处理原始时间序列数据。依据序列间的距离/相似度度量进行聚类<h1 id="3-集体异常检测实战"><a href="#3-集体异常检测实战" class="headerlink" title="3.集体异常检测实战"></a>3.集体异常检测实战</h1>检测策略：基于特征的子序列聚类，PCA提取重要特征，DBSCAN算法实现聚类。<br>检测流程：</li></ul><ol><li>加载原始数据</li><li>为了提高检测效果，对数据进行滤波平滑处理。</li><li>去除数据趋势影响。</li><li>按照实际数据模式，划分子序列，并提取特征。</li><li>特征过滤，PCA降维。</li><li>DBSCAN聚类，检测异常序列。<br>首先加载必要的工具并加载数据。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold   <br><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> NearestNeighbors<br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><span class="hljs-keyword">import</span> plotly.graph_objs <span class="hljs-keyword">as</span> go<br><br><span class="hljs-comment">#加载资源文件数据</span><br>data = pd.read_csv(<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold   <br><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> NearestNeighbors<br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><span class="hljs-keyword">import</span> plotly.graph_objs <span class="hljs-keyword">as</span> go<br><br><span class="hljs-comment">#加载资源文件数据</span><br>data = pd.read_csv(<span class="hljs-string">'./Data.csv'</span>)<br>data.index = pd.to_datetime(data.Datetime)<br></code></pre></td></tr></tbody></table></figure><p>使用低通滤波器滤波。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python">b, a = signal.butter(<span class="hljs-number">10</span>,<span class="hljs-number">0.026</span> , <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>data[<span class="hljs-string">'Hu1_0'</span>] = signal.filtfilt(b, a, data[<span class="hljs-string">'Hu_0'</span>]) <span class="hljs-comment">#data为要过滤的信号</span><br><span class="hljs-comment">#可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">5</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string">'Hu1_0'</span>])<br>plt.plot(data[<span class="hljs-string"><code class="language-hljs python">b, a = signal.butter(<span class="hljs-number">10</span>,<span class="hljs-number">0.026</span> , <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>data[<span class="hljs-string">'Hu1_0'</span>] = signal.filtfilt(b, a, data[<span class="hljs-string">'Hu_0'</span>]) <span class="hljs-comment">#data为要过滤的信号</span><br><span class="hljs-comment">#可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">5</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string">'Hu1_0'</span>])<br>plt.plot(data[<span class="hljs-string">'Hu_0'</span>])<br></code></pre></td></tr></tbody></table></figure><p>结果曲线图如下：<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/2.5ttokbw5tz00.jpg" alt="2">  </p><p>利用时间序列分解，去除曲线趋势。在前期数据分析时找出数据存在两个周期，77min和1day。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 去趋势</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">'Hu1_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期</span><br>data[<span class="hljs-string">"detrend_77"</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.seasonal<br><span class="hljs-comment">#分解1440周期</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">"detrend_77"</span>] , model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 趋势分量</span><br>data[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment">#删除含空值的行，前面分解的序列前端末端含有空值。</span><br>data = data.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#去除趋势</span><br>data[<span class="hljs-string">'detrend_Hu0'</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.trend<br><span class="hljs-comment"># 可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 去趋势</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">'Hu1_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期</span><br>data[<span class="hljs-string">"detrend_77"</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.seasonal<br><span class="hljs-comment">#分解1440周期</span><br>decompose_result = seasonal_decompose(data[<span class="hljs-string">"detrend_77"</span>] , model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 趋势分量</span><br>data[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment">#删除含空值的行，前面分解的序列前端末端含有空值。</span><br>data = data.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#去除趋势</span><br>data[<span class="hljs-string">'detrend_Hu0'</span>] = data[<span class="hljs-string">'Hu1_0'</span>] - decompose_result.trend<br><span class="hljs-comment"># 可视化</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(data[<span class="hljs-string">'detrend_Hu0'</span>])<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/3.36x9yqdo7280.jpg" width="60%/"></div>  <p>接下来按照77窗口大小划分子序列，无重复窗口，并提取每个子序列的特征。使用tsfresh工具包，按照API要求，在表中添加id列。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">data[<span class="hljs-string">'id'</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort:按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">76</span> ,min_timeshift = <span class="hljs-number">76</span>,rolling_direction=-<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 特征提取</span><br>df_features = extract_features(df_rolled.drop(<span class="hljs-string">"time"</span>,axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string"><code class="language-hljs python">data[<span class="hljs-string">'id'</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort:按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">76</span> ,min_timeshift = <span class="hljs-number">76</span>,rolling_direction=-<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 特征提取</span><br>df_features = extract_features(df_rolled.drop(<span class="hljs-string">"time"</span>,axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string">"id"</span>)<br></code></pre></td></tr></tbody></table></figure><p>利用方差和相关系数进行特征过滤。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#删除含空值列</span><br>df_features_dropna_All = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 标准化</span><br>scaler1 = StandardScaler()<br>df_features_Standar = pd.DataFrame(scaler1.fit_transform(df_features_dropna_All),index=df_features_dropna_All.index, columns=df_features_dropna_All.columns)<br>df_features_Standar<br><span class="hljs-comment"># 特征过滤 filter方差</span><br>X_fratures_columns = df_features_Standar.columns<br>selector = VarianceThreshold(<span class="hljs-number">0.9</span>)<br>X_features = selector.fit_transform(df_features_Standar)<br>df_features_filter = pd.DataFrame(X_features,index=df_features_Standar.index, columns=X_fratures_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br><span class="hljs-comment"># df_filter.corr()</span><br>corr_features = df_features_filter.corr()<br>threshold = <span class="hljs-number">0.4</span><br>upper_features = corr_features.where(np.triu(np.ones(corr_features.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br>corr_features_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper_features.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper_features[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_features_filter = df_features_filter.drop(corr_features_drop,axis=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#删除含空值列</span><br>df_features_dropna_All = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 标准化</span><br>scaler1 = StandardScaler()<br>df_features_Standar = pd.DataFrame(scaler1.fit_transform(df_features_dropna_All),index=df_features_dropna_All.index, columns=df_features_dropna_All.columns)<br>df_features_Standar<br><span class="hljs-comment"># 特征过滤 filter方差</span><br>X_fratures_columns = df_features_Standar.columns<br>selector = VarianceThreshold(<span class="hljs-number">0.9</span>)<br>X_features = selector.fit_transform(df_features_Standar)<br>df_features_filter = pd.DataFrame(X_features,index=df_features_Standar.index, columns=X_fratures_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br><span class="hljs-comment"># df_filter.corr()</span><br>corr_features = df_features_filter.corr()<br>threshold = <span class="hljs-number">0.4</span><br>upper_features = corr_features.where(np.triu(np.ones(corr_features.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br>corr_features_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper_features.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper_features[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_features_filter = df_features_filter.drop(corr_features_drop,axis=<span class="hljs-number">1</span>)<br>df_features_filter<br></code></pre></td></tr></tbody></table></figure><p>过滤后的特征有14个，再使用PCA特征降维。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># PCA降维,目标维数为7。</span><br>pca = PCA(n_components=<span class="hljs-number">7</span>)<br>pca.fit(df_features_filter)<br><span class="hljs-comment">#获取特征主成分占比</span><br>variance = pca.explained_variance_ratio_ <br>var=np.cumsum(np.<span class="hljs-built_in">round</span>(variance, <span class="hljs-number">3</span>)*<span class="hljs-number">100</span>)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br>plt.ylabel(<span class="hljs-string">'% Variance Explained'</span>)<br>plt.xlabel(<span class="hljs-string">'# of Features'</span>)<br>plt.title(<span class="hljs-string">'PCA Analysis'</span>)<br>plt.ylim(<span class="hljs-number">0</span>,<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># PCA降维,目标维数为7。</span><br>pca = PCA(n_components=<span class="hljs-number">7</span>)<br>pca.fit(df_features_filter)<br><span class="hljs-comment">#获取特征主成分占比</span><br>variance = pca.explained_variance_ratio_ <br>var=np.cumsum(np.<span class="hljs-built_in">round</span>(variance, <span class="hljs-number">3</span>)*<span class="hljs-number">100</span>)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br>plt.ylabel(<span class="hljs-string">'% Variance Explained'</span>)<br>plt.xlabel(<span class="hljs-string">'# of Features'</span>)<br>plt.title(<span class="hljs-string">'PCA Analysis'</span>)<br>plt.ylim(<span class="hljs-number">0</span>,<span class="hljs-number">100.5</span>)<br>plt.plot(var)<br></code></pre></td></tr></tbody></table></figure><p>画出特征主成分占比曲线图。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/4.50ewczun4dc0.jpg" width="60%/"></div>  <p>选择占比最大的三个特征。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">pca = PCA(n_components=<span class="hljs-number">3</span>)<br>pca.fit(df_features_filter)<br>pca_scale = pca.transform(df_features_filter)<br>pca_df = pd.DataFrame(pca_scale, columns=[<span class="hljs-string">'pc1'</span>, <span class="hljs-string">'pc2'</span>, <span class="hljs-string">'pc3'</span>])<br><span class="hljs-built_in"><code class="language-hljs python">pca = PCA(n_components=<span class="hljs-number">3</span>)<br>pca.fit(df_features_filter)<br>pca_scale = pca.transform(df_features_filter)<br>pca_df = pd.DataFrame(pca_scale, columns=[<span class="hljs-string">'pc1'</span>, <span class="hljs-string">'pc2'</span>, <span class="hljs-string">'pc3'</span>])<br><span class="hljs-built_in">print</span>(pca.explained_variance_ratio_)<br>pca_df <br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/4.4a1wi33d3o20.jpg" width="25%/"></div>  <p>查看特征3D图。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(colorscale=<span class="hljs-string">'Greys'</span>, opacity=<span class="hljs-number">0.6</span>, size = <span class="hljs-number">10</span>))<br>layout = go.Layout(margin=<span class="hljs-built_in">dict</span>(l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>),scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number"><code class="language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(colorscale=<span class="hljs-string">'Greys'</span>, opacity=<span class="hljs-number">0.6</span>, size = <span class="hljs-number">10</span>))<br>layout = go.Layout(margin=<span class="hljs-built_in">dict</span>(l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>),scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number">1000</span>)<br>data = [trace]<br>fig = go.Figure(data = data, layout = layout)<br>fig.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/5.3cmrrg0tjgu0.jpg" width="45%/"></div>  <p>DBSCAN需要确定两个参数：epsilon：聚类半径；minPts：聚类点数。其中minPts一般取特征数目的两倍，对应项目中取6。epsilon利用肘形图确定。<br>画出特征的肘形图，即在y轴上，绘制点之间的平均距离，在x轴上绘制数据集中的所有数据点。从图中，取肘部数值约1.4。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>nn = NearestNeighbors(n_neighbors=<span class="hljs-number">6</span>).fit(pca_df)<br>distances, idx = nn.kneighbors(pca_df)<br>distances = np.sort(distances, axis=<span class="hljs-number">0</span>)<br>distances = distances[:,<span class="hljs-number"><code class="language-hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>nn = NearestNeighbors(n_neighbors=<span class="hljs-number">6</span>).fit(pca_df)<br>distances, idx = nn.kneighbors(pca_df)<br>distances = np.sort(distances, axis=<span class="hljs-number">0</span>)<br>distances = distances[:,<span class="hljs-number">1</span>]<br>plt.plot(distances)<br>plt.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/6.3ph5oy7aiym0.jpg" width="60%/"></div>  <p>确定完两个参数后，开始聚类。输出结果为聚类簇数、噪声点数和剪影得分（评价聚类效果，越接近1越好）。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python">db = DBSCAN(eps=<span class="hljs-number">1.4</span>, min_samples=<span class="hljs-number">6</span>).fit(pca_df)<br>labels = db.labels_<span class="hljs-comment"># Number of clusters in labels, ignoring noise if present.</span><br>n_clusters_ = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels)) - (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> labels <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>n_noise_ = <span class="hljs-built_in">list</span>(labels).count(-<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of clusters: %d'</span> % n_clusters_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of noise points: %d'</span> % n_noise_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string"><code class="language-hljs python">db = DBSCAN(eps=<span class="hljs-number">1.4</span>, min_samples=<span class="hljs-number">6</span>).fit(pca_df)<br>labels = db.labels_<span class="hljs-comment"># Number of clusters in labels, ignoring noise if present.</span><br>n_clusters_ = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels)) - (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> labels <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>n_noise_ = <span class="hljs-built_in">list</span>(labels).count(-<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of clusters: %d'</span> % n_clusters_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'Estimated number of noise points: %d'</span> % n_noise_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"Silhouette Coefficient: %0.3f"</span> % metrics.silhouette_score(pca_df, labels))<br></code></pre></td></tr></tbody></table></figure><p>输出结果：<br>Estimated number of clusters: 1<br>Estimated number of noise points: 10<br>Silhouette Coefficient: 0.528<br>将筛选出来的噪声点即异常点反映在3D图上。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>labels = db.labels_<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(color = labels, colorscale=<span class="hljs-string">'Viridis'</span>, size = <span class="hljs-number">10</span>, line = <span class="hljs-built_in">dict</span>(color = <span class="hljs-string">'gray'</span>,width = <span class="hljs-number">5</span>)))<br>layout = go.Layout(scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number">1000</span>)<br>data = [trace]<br>fig = go.Figure(data = data, layout = layout)<br>fig.update_layout(title=<span class="hljs-string">'DBSCAN clusters Derived from PCA'</span>, font=<span class="hljs-built_in">dict</span>(size=<span class="hljs-number"><code class="language-hljs python">Scene = <span class="hljs-built_in">dict</span>(xaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC1'</span>),yaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC2'</span>),zaxis = <span class="hljs-built_in">dict</span>(title = <span class="hljs-string">'PC3'</span>))<br>labels = db.labels_<br>trace = go.Scatter3d(x=pca_df.iloc[:,<span class="hljs-number">0</span>], y=pca_df.iloc[:,<span class="hljs-number">1</span>], z=pca_df.iloc[:,<span class="hljs-number">2</span>], mode=<span class="hljs-string">'markers'</span>,marker=<span class="hljs-built_in">dict</span>(color = labels, colorscale=<span class="hljs-string">'Viridis'</span>, size = <span class="hljs-number">10</span>, line = <span class="hljs-built_in">dict</span>(color = <span class="hljs-string">'gray'</span>,width = <span class="hljs-number">5</span>)))<br>layout = go.Layout(scene = Scene, height = <span class="hljs-number">1000</span>,width = <span class="hljs-number">1000</span>)<br>data = [trace]<br>fig = go.Figure(data = data, layout = layout)<br>fig.update_layout(title=<span class="hljs-string">'DBSCAN clusters Derived from PCA'</span>, font=<span class="hljs-built_in">dict</span>(size=<span class="hljs-number">12</span>,))<br>fig.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/7.6znotbvxhto0.jpg" width="45%/"></div>   <p>将筛选出的异常序列反映到时间序列中。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs python">df_rolled[<span class="hljs-string">'id'</span>] = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(df_rolled)+<span class="hljs-number">1</span>)<br>df_rolled.index = df_rolled.<span class="hljs-built_in">id</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(labels)-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> labels[i]&gt;-<span class="hljs-number">1</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'blue'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'red'</span>)<br>plt.show()<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(df_rolled[<span class="hljs-string"><code class="language-hljs python">df_rolled[<span class="hljs-string">'id'</span>] = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(df_rolled)+<span class="hljs-number">1</span>)<br>df_rolled.index = df_rolled.<span class="hljs-built_in">id</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(labels)-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> labels[i]&gt;-<span class="hljs-number">1</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'blue'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        data = df_rolled[i*<span class="hljs-number">77</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">77</span>]<br>        plt.plot(data[<span class="hljs-string">'time'</span>],data[<span class="hljs-string">'detrend_Hu0'</span>],color=<span class="hljs-string">'red'</span>)<br>plt.show()<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.title(<span class="hljs-string">'Hu_0'</span>)<br>plt.plot(df_rolled[<span class="hljs-string">'detrend_Hu0'</span>])<br>plt.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202205/Collective-anomaly-And-DBSCAN/8.36lgllzomlk0.jpg" width="60%/"></div>   ]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集体异常</tag>
      
      <tag>子序列聚类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows7环境bat安装mariadb</title>
    <link href="/installing-mariadb-with-bat-in-windows-7-environment.html"/>
    <url>/installing-mariadb-with-bat-in-windows-7-environment.html</url>
    
    <content type="html"><![CDATA[<p>功能实现：编写bat批处理命令，在windows环境下，根据下载的安装包一键安装mariadb。</p><span id="more"></span> <ol><li><p>准备<a href="https://mariadb.org/download/?t=mariadb&amp;o=true&amp;p=mariadb&amp;r=10.5.4&amp;os=windows&amp;cpu=x86&amp;pkg=zip">mariadb安装包</a></p></li><li><p>解压，在解压后的文件中添加data文件夹。(因为最终目标是将所有要安装的东西打个包，实现一键安装，所以一些不需要后续改动的操作就直接手动完成了。当然，也可以使用bat命令解压再添加文件夹，我试过，完全可以的。前置条件是要先安装一个解压软件，windows7没有解压软件，也就是先静默安装360解压，再继续往下走。)</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/1.68rotst9k800.jpg" width="60%/"></div>  </li><li><p>配置环境变量。配置成功后可在环境变量path中查看是否存在。</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs dos">:: 此处将cds设置为bat文件所在绝对路径<br><span class="hljs-built_in">set</span> cds=%~dp0<br><span class="hljs-built_in">set</span> cds<br><span class="hljs-built_in">set</span> mpth=mariadb<br>:: mysql_path为mariadb解压后的路径（此处bat文件和解压文件在同级目录，解压文件名为mariadb）<br><span class="hljs-built_in">set</span> mysql_path=<span class="hljs-variable">%cds%</span><span class="hljs-variable">%mpth%</span><br><span class="hljs-built_in">echo</span>.<br>:: %引用变量<br><span class="hljs-built_in">echo</span> 安装路径：<span class="hljs-variable">%mysql_path%</span><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">pause</span><br><span class="hljs-built_in">echo</span> 配置环境变量<br><span class="hljs-built_in">echo</span>.<br>::setx设置环境变量  setx "变量名" "变量值"<br>setx <span class="hljs-built_in">PATH</span> "<span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin"<br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">ERRORLEVEL</span> <span class="hljs-number">1</span> (<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span> 配置环境变量失败，即将退出<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-keyword">goto</span> END<br>)<br><span class="hljs-built_in">set</span> <span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin<br><span class="hljs-built_in">echo</span> 环境配置成功<br><span class="hljs-built_in">pause</span><br>:END<br><span class="hljs-built_in"><code class="language-hljs dos">:: 此处将cds设置为bat文件所在绝对路径<br><span class="hljs-built_in">set</span> cds=%~dp0<br><span class="hljs-built_in">set</span> cds<br><span class="hljs-built_in">set</span> mpth=mariadb<br>:: mysql_path为mariadb解压后的路径（此处bat文件和解压文件在同级目录，解压文件名为mariadb）<br><span class="hljs-built_in">set</span> mysql_path=<span class="hljs-variable">%cds%</span><span class="hljs-variable">%mpth%</span><br><span class="hljs-built_in">echo</span>.<br>:: %引用变量<br><span class="hljs-built_in">echo</span> 安装路径：<span class="hljs-variable">%mysql_path%</span><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">pause</span><br><span class="hljs-built_in">echo</span> 配置环境变量<br><span class="hljs-built_in">echo</span>.<br>::setx设置环境变量  setx "变量名" "变量值"<br>setx <span class="hljs-built_in">PATH</span> "<span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin"<br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">ERRORLEVEL</span> <span class="hljs-number">1</span> (<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span> 配置环境变量失败，即将退出<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-keyword">goto</span> END<br>)<br><span class="hljs-built_in">set</span> <span class="hljs-variable">%path%</span>;<span class="hljs-variable">%mysql_path%</span>\bin<br><span class="hljs-built_in">echo</span> 环境配置成功<br><span class="hljs-built_in">pause</span><br>:END<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>mariadb安装与注册服务。(注意：第二条注册服务命令为<strong>mysqld</strong>别搞错了，血的教训)。注册成功会有success提示。</p><figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs fortran">mysql_install_db.exe<br><span class="hljs-keyword">pause</span><br>:: 在前面安装后会在创建的<span class="hljs-keyword">data</span>文件夹中存在my.ini文件，mariadb为创建服务的名称<br>mysqld -install mariadb --<span class="hljs-keyword">default</span>-<span class="hljs-keyword">file</span>=”my.ini文件的路径“<br><span class="hljs-keyword"><code class="language-hljs fortran">mysql_install_db.exe<br><span class="hljs-keyword">pause</span><br>:: 在前面安装后会在创建的<span class="hljs-keyword">data</span>文件夹中存在my.ini文件，mariadb为创建服务的名称<br>mysqld -install mariadb --<span class="hljs-keyword">default</span>-<span class="hljs-keyword">file</span>=”my.ini文件的路径“<br><span class="hljs-keyword">pause</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>注册表修改。在注册服务后，查看服务中的可执行文件路径，会发现执行路径是默认的c盘内的Program Files内的mysqld执行程序，如果你就装在相应路径里，可以不用修改。如果不一致，则需要改成对应的执行程序的路径，也就是一开始解压的文件bin目录里的mysqld程序。(注册表的路径都是一样的，不同的是最后的命名为前面创建服务时的命名，要修改的仅有ImagePath的值)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><span class="hljs-built_in">echo</span> 修改注册表<br><br>::reg add 注册表路径 /v 值名 /t 要修改的数值类型 /d 想要输入的数据 /f<br><br>reg add <span class="hljs-string">"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\mariadb"</span> /v ImagePath /t REG_EXPAND_SZ /d <span class="hljs-string">"\"C:\XFTP\mariadb\bin\mysqld\" --defaults-file=C:\XFTP\mariadb\data mariadb"</span> /f<br><br><span class="hljs-built_in"><code class="language-hljs bash"><span class="hljs-built_in">echo</span> 修改注册表<br><br>::reg add 注册表路径 /v 值名 /t 要修改的数值类型 /d 想要输入的数据 /f<br><br>reg add <span class="hljs-string">"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\mariadb"</span> /v ImagePath /t REG_EXPAND_SZ /d <span class="hljs-string">"\"C:\XFTP\mariadb\bin\mysqld\" --defaults-file=C:\XFTP\mariadb\data mariadb"</span> /f<br><br><span class="hljs-built_in">echo</span> 修改注册表完成<br>pause<br></code></pre></td></tr></tbody></table></figure></li><li><p>启动mariadb服务，并登录进入。默认无密码，直接回车就可进入。</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in"><code class="language-hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mariadb<br>mariadb -uroot -p<br></code></pre></td></tr></tbody></table></figure></li><li><p>数据库备份与恢复。（这部分为初始化数据库，先从模板中导出数据，再应用到其他新建的数据库中，还未完成）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装与环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mariadb</tag>
      
      <tag>bat批处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间序列特征工程</title>
    <link href="/characteristic-engineering-of-time-series.html"/>
    <url>/characteristic-engineering-of-time-series.html</url>
    
    <content type="html"><![CDATA[<p>完成数据清洗之后，需要提取有意义的样本特征输入模型中训练，目的是为了更高效的利用算法。提取特征的步骤叫特征工程，分为三步：特征提取、特征预处理、特征降维。下面将针对时序序列的特征工程进行讲述。</p><span id="more"></span><h1 id="1-特征提取"><a href="#1-特征提取" class="headerlink" title="1. 特征提取"></a>1. 特征提取</h1><p>提取时间序列的特征可以从三方面着手。</p><h2 id="1-1-从时间中提取特征"><a href="#1-1-从时间中提取特征" class="headerlink" title="1.1 从时间中提取特征"></a>1.1 从时间中提取特征</h2><p>每条样本数据对应的时间数据包含很多信息，可以从中发现时间上的一些规律特征。<br>提取时间特征可以对时间进行拆解，如2022.04.23 15:08:03，可以将其中年月日时分秒分别拆解为一列，或者以某个时间点为起点，计算经过的时间，如一天中的第几分钟，一年中的第几天或第几周等等。对于受季节、节假日影响的数据，也可以判断是否月初、月末、周末、公共假期、营业时间等等。<br><strong>举例程序实现：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre class=" language-hljs python">df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal"><code class="language-hljs python">df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>)<br>df<br></code></pre></td></tr></tbody></table></figure><p>结果如下图所示：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/时间特征.407xag8uznw0.jpg"></div> <h2 id="1-2-从时序规律中提取特征"><a href="#1-2-从时序规律中提取特征" class="headerlink" title="1.2 从时序规律中提取特征"></a>1.2 从时序规律中提取特征</h2><p>在数据清洗后的数据分析中，通常会分析时间序列的一些特性，如周期性、时间序列分解、历史数据，可以把这些分析出来的数据用作特征。<br>**举例程序实现： **</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string">"Hu0_resid"</span>] = decompose_result.resid<br>df<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%97%B6%E5%BA%8F%E8%A7%84%E5%BE%8B%E7%89%B9%E5%BE%81.5n1vvk2y3d40.jpg" alt="时序规律特征"></p><h2 id="1-3-从统计窗口提取特征"><a href="#1-3-从统计窗口提取特征" class="headerlink" title="1.3 从统计窗口提取特征"></a>1.3 从统计窗口提取特征</h2><p>要想提取时间序列的统计特征，需要按固定时间长度把一条时间序列划分为n多条子序列，然后对这些子序列分别构造统计特征。<br>**举例程序实现： **</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># sum() 值的总和</span><br><span class="hljs-comment"># mean() 均值</span><br><span class="hljs-comment"># median() 值的算术中值</span><br><span class="hljs-comment"># min() 最小值</span><br><span class="hljs-comment"># max() 最大</span><br><span class="hljs-comment"># std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment"># var() 无偏方差</span><br><span class="hljs-comment"># cov() 无偏协方差（二元）</span><br><span class="hljs-comment"># corr() 相关（二进制）</span><br><span class="hljs-comment"># variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment"># polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment"># df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment"># 一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># sum() 值的总和</span><br><span class="hljs-comment"># mean() 均值</span><br><span class="hljs-comment"># median() 值的算术中值</span><br><span class="hljs-comment"># min() 最小值</span><br><span class="hljs-comment"># max() 最大</span><br><span class="hljs-comment"># std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment"># var() 无偏方差</span><br><span class="hljs-comment"># cov() 无偏协方差（二元）</span><br><span class="hljs-comment"># corr() 相关（二进制）</span><br><span class="hljs-comment"># variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment"># polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment"># df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment"># 一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_diff_std"</span>] = roll_data_diff.std()<br>df<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E7%BB%9F%E8%AE%A1%E7%89%B9%E5%BE%81.6ahmg2mw8s00.jpg" alt="统计特征"></p><h1 id="2-特征预处理"><a href="#2-特征预处理" class="headerlink" title="2. 特征预处理"></a>2. 特征预处理</h1><p>特征预处理是对提取出来的特征无量纲化，目的是让特征处于同等地位，避免特征之间差异太大而影响模型学习效果。常用的处理手段有两种：归一化和标准化。归一化是将原数据映射到[m,n]（通常为[0,1]）内，但当数据异常点较多时，容易影响归一化结果，适合小样本。标准化是将数据变换为均值为0，标准差为1的范围内。而平均值和标准差受异常值影响较小，能克服归一化的缺点。此处使用标准化进行举例。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment"><code class="language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br>df_Standar = pd.DataFrame(scaler.fit_transform(df),index=df.index, columns=df.columns)<br>df_Standar<br></code></pre></td></tr></tbody></table></figure><h1 id="3-特征降维"><a href="#3-特征降维" class="headerlink" title="3. 特征降维"></a>3. 特征降维</h1><p>特征降维指的是对提取出来的特征进行过滤筛选，减少特征维度。目的是为了降低学习任务的难度和减轻维度灾难问题。<br>通常，从两个方面考虑来选择特征：</p><ol><li>特征是否发散<br>如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li><li>特征与目标的相关性<br>与目标相关性高的特征，应当优先选择。<br>区别：特征与特征之间相关性高的，应当优先去除掉其中一个特征，因为它们是替代品。<br>特征选择方法有：Filter过滤法、Wrapper包装法和Embedded嵌入法。其中第二三种方法都适合于有监督学习，需要与目标值关联进行特征选择。因为原数据是为异常检测，没有标签，属于无监督学习，这里仅举例过滤法。<br>通过筛选小方差和强相关特征来达到过滤特征的目的。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br>df_filter<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number">1</span>)<br>df_filter<br></code></pre></td></tr></tbody></table></figure><h1 id="4-Tsfresh特征提取工具"><a href="#4-Tsfresh特征提取工具" class="headerlink" title="4. Tsfresh特征提取工具"></a>4. Tsfresh特征提取工具</h1>最后讲一个用于时间序列特征提取的工具<a href="https://tsfresh.readthedocs.io/en/latest/index.html">tsfresh</a><br>工具介绍就不讲了，直接说一下用法。对于一条长时间序列，要想利用tsfresh工具提取特征，还需要先将其化为一个个子窗口序列。该工具包内就包含这个功能。原表结构为：<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8E%9F%E8%A1%A8%E7%BB%93%E6%9E%84.119hmuad0jy8.jpg" alt="滚动窗口原表结构"></li></ol><p>其中id,time列是在原表的基础上后加上的，目的是为了方便使用API接口函数。id代表组别，time代表时间顺序。然后使用API转换为窗口子序列。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number">1</span>)<br>df_rolled<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/tsfresh%E7%AA%97%E5%8F%A3%E5%BA%8F%E5%88%97.4f2dy005fr40.jpg" alt="tsfresh窗口序列"><br>转化后的id是原id与原时间的组合，也为后面特征提取中的组别。（1，1）代表1号组别的第一个时间点组成的子序列，（1，43316）代表1号组别第43316个点组成的子序列。然后再进行特征提取.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string">"id"</span>)<br>df_features<br></code></pre></td></tr></tbody></table></figure><p>以上即为tsfresh特征提取的步骤，其内置的特征过滤函数因需要目标值而不适用我的数据，所以后续特征降维仍使用上述过滤法进行选择。</p><blockquote><p>参考网站：<br><a href="https://cloud.tencent.com/developer/article/1536537">特征工程系列：时间特征构造以及时间序列特征构造</a><br><a href="https://www.heywhale.com/mw/project/5d86eced8499bc002c108cc8">特征工程理论与代码实现特征工程理论与代码实现</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>时间序列</tag>
      
      <tag>特征工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7安装QT及环境配置</title>
    <link href="/centos7-an-zhuang-qt-ji-huan-jing-pei-zhi.html"/>
    <url>/centos7-an-zhuang-qt-ji-huan-jing-pei-zhi.html</url>
    
    <content type="html"><![CDATA[<ol><li><p>正常下载安装QT</p></li><li><p>打开QT，打开工具-&gt;选项-&gt;Kits，手动添加一个kit(不懂为啥自动检测出来的都不好使，我就全部都手动添加了)，名称和自动的一样就好。</p><span id="more"></span>  <div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/10.4dpjrrcig4g0.jpg" width="60%/"></div>  </li><li><p>首先设置QT versions,手动添加qmake，路劲就是你安装QT的地方，和自动检测出来的一样，设置完点击Apply。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/1.5d7pkq3aynw0.jpg" width="60%/"></div> </li><li><p>然后是添加编译器，这个比较麻烦，需要安装gcc，下面具体说一下操作步骤。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/2.1zgz8yzam9a8.jpg" width="60%/"></div></li></ol><ul><li><p>回到centos界面，打开终端，执行命令 gcc -v，查看是否已经安装gcc,我这里已经安装过了，用的yum自动给我下的，centos7下载的就是这个4.8.5版本的,但这个版本有问题，不支持c++11，所以还需要换更高些的版本。（没下载的话别用yum下，要么自己找高版本下，要么看我后面）</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/3.uxn6sxffcn4.jpg" width="60%/"></div> </li><li><p>gcc升级这步骤浪费了我很多时间，但搞完回头一看，其实步骤很简单。首先一定要看看有没有网，ping一下看看，虚拟机联网百度一下，这里有个问题是试过百度方法后依然不行，service network start命令无法启动，然后看到了一个大佬的评论，设置一下IP地址就好了，命令是：dhclient ens33，这里的ens33是自己网卡名字，前面设置联网的过程应该有看到过，自己更改就可以了。有网之后分别执行下面三条命令：</p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs mipsasm">sudo yum <span class="hljs-keyword">install </span>centos-release-<span class="hljs-keyword">scl</span><br><span class="hljs-keyword"></span>sudo yum <span class="hljs-keyword">install </span>devtoolset<span class="hljs-number">-8</span>-gcc*<br><span class="hljs-keyword">scl </span>enable devtoolset<span class="hljs-number">-8</span> <span class="hljs-keyword"><code class="language-hljs mipsasm">sudo yum <span class="hljs-keyword">install </span>centos-release-<span class="hljs-keyword">scl</span><br><span class="hljs-keyword"></span>sudo yum <span class="hljs-keyword">install </span>devtoolset<span class="hljs-number">-8</span>-gcc*<br><span class="hljs-keyword">scl </span>enable devtoolset<span class="hljs-number">-8</span> <span class="hljs-keyword">bash</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>这里可以自己选择版本，利用centos-release-scl工具，让你不需要重写编译gcc，能同时保留多个版本的gcc，你需要哪个版本enable一下。执行完后再看一下版本是否更新了。用这个工具缺点是重新启动需要再次enable，可以设置开机自启动，我还没设置，因为QT里不需要，设置一下路径就Ok了。开机启动命令是“ echo “source /opt/rh/devtoolset-9/enable” &gt;&gt; /etc/profile ”，我还没试，不懂行不行。</p></blockquote></li><li><p>查看gcc的路径</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/4.7c8mgb783300.jpg" width="60%/"></div></li></ul><ol start="5"><li>打开QT里的编译器设置，手动添加gcc,路径就是你前面查找的，具体就是下面两张图。设置完后点应用。<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/5.4l9lse48f7c0.jpg" width="60%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/6.2p6xnaktsni0.jpg" width="60%/"></div></li><li>回到kit，设置一下compiler和QT version，然后点击Apply。<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/7.72ch9al9tvc0.jpg" width="60%/"></div></li><li>这时候可以打开一个例子试试，build一下，发现还是有问题，报错“ cannot find -lGL”；<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/8.3wp797r848m0.jpg" width="60%/"></div>原因在于QT寻找的libGL路径和centos自带的libGL路径不一致，且名称有点区别，所以需要加一个软链接。输入命令：locate libGL ，查看系统libGL的路径和名称，这里选第一个libGL.so.1。<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/centos7安装QT及环境配置/9.7jiqgedk3000.jpg" width="60%/"></div>创建链接：# ln -s /usr/lib64/libGL.so.1 /usr/lib/libGL.so 需要root权限，可使用sudo su命令进入root。创建成功后再次build，发现成功啦。</li></ol><p>这就是centos7安装QT的全过程了。因为第一次用linux系统，安装个QT就浪费我两天，不停试错，心累，于是搞好后赶忙在这记录一下，留待备用。</p><p>备注：这里还有一个问题是：设置好的kit会有警告：the abi of selected debugger does not match the toolchain abi，是关于debugger的，这是因为自带的gdb版本低了，换个高些的版本就ok了。</p>]]></content>
    
    
    <categories>
      
      <category>安装与环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序数据异常检测流程与项目实战</title>
    <link href="/anomaly-detection-process.html"/>
    <url>/anomaly-detection-process.html</url>
    
    <content type="html"><![CDATA[<p>本文主要内容为对时序数据异常检测流程进行简单介绍，然后通过项目实战进行详细解释。全文内容根据个人实际经验所得。</p><h1 id="1-总体流程介绍"><a href="#1-总体流程介绍" class="headerlink" title="1.总体流程介绍"></a>1.总体流程介绍</h1><p>针对项目中传感器数据异常检测，经调研后，个人初步总结工程上实现异常检测的流程。流程框图如下图所示：<br> <span id="more"></span>  </p><p><img src="https://cdn.staticaly.com/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Anomaly_detection_process.6l6blsl243s0.jpg" alt="Anomaly_detection_process"></p><p>总体步骤有五步：  </p><ol><li>数据清洗：对数据做初步处理，方便后续的数据分析。包括时间戳的转换（因为是时序数据，需要对时间列做专门处理）、数据重采样（修改时间频率）、缺失值处理、异常值处理、数据平滑处理</li><li>探索性数据分析EDA：通过作图、制表、方程拟合、计算特征量等手段探索数据的结构和规律的一种数据分析方法。主要是利用各种方式自由探索数据分布、数据相关性等。分析后决定检测哪种类型的异常。</li><li>特征提取/相关性分析：对于单维序列，因为缺乏可用特征，需要进行特征提取，以便后续训练模型，时序序列中比较重要的特征是周比环比。对于多维序列，需要先进行相关性分析，剔除相关性强的数据。要根据检测的异常类型，实施特征提取方案。</li><li>训练模型：对数据分析后选择合适的算法进行建模，用提取出的特征或若相关数据进行模型训练。</li><li>异常检测：利用训练好的模型检测实际数据。单维常用算法有LSTM + Vae，通过预测的方式检测异常；多维可利用孤立森林、SVM、kmeans等。</li></ol><h1 id="2-项目实战"><a href="#2-项目实战" class="headerlink" title="2.项目实战"></a>2.项目实战</h1><p>利用工具：jupyter notebook; 语言：python</p><h2 id="2-1-数据清洗"><a href="#2-1-数据清洗" class="headerlink" title="2.1 数据清洗"></a>2.1 数据清洗</h2><p>实现目标：提取csv文件数据，处理缺失值、异常值、数据平滑化，完成数据清洗。<br>首先加载必要库:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_pacf<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br><span class="hljs-keyword">import</span> random <span class="hljs-keyword">as</span> rd <br><span class="hljs-keyword">import</span> datetime <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> matplotlib.dates <span class="hljs-keyword">as</span> mdate<br><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf<br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_pacf<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br></code></pre></td></tr></tbody></table></figure><p>提取csv文件,利用pd.read_csv()函数可完整提取表中全部内容，函数有很多参数可以选择，实现众多功能</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#读取表格数据</span><br>data1 = pd.read_csv(<span class="hljs-string">'./data/componet.csv'</span>)<br>data2 = pd.read_csv(<span class="hljs-string">'./data/tehu.csv'</span>)<br>data1 <span class="hljs-comment"><code class="language-hljs python"><span class="hljs-comment">#读取表格数据</span><br>data1 = pd.read_csv(<span class="hljs-string">'./data/componet.csv'</span>)<br>data2 = pd.read_csv(<span class="hljs-string">'./data/tehu.csv'</span>)<br>data1 <span class="hljs-comment">#展示data1中数据</span><br></code></pre></td></tr></tbody></table></figure><p>表格数据如图所示：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet.4mjopka34v80.jpg" width="60%/"></div>  <p>查询表中是否有缺失值，使用.isnull()查询，返回含有缺失值的行。我的数据没有缺失值，表为空，就不展示了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 查看缺失值</span><br>pivot_data[pivot_data.isnull().T.<span class="hljs-built_in"><code class="language-hljs python"><span class="hljs-comment"># 查看缺失值</span><br>pivot_data[pivot_data.isnull().T.<span class="hljs-built_in">any</span>()]<br></code></pre></td></tr></tbody></table></figure><p>将data1中时间列数据设置为索引，方便查询，也方便可视化</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python">data1.index = pd.to_datetime(data1.Datetime) <span class="hljs-comment"><code class="language-hljs python">data1.index = pd.to_datetime(data1.Datetime) <span class="hljs-comment">#设置时间列为索引</span><br>data1<br></code></pre></td></tr></tbody></table></figure><p>设置完后数据：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_index.78rh4tnfar00.jpg" width="60%/"></div>  <p>先对未处理的数据进行可视化，看看数据形态：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#可视化</span><br><span class="hljs-comment">#设置x轴显示格式，设置x轴显示范围，freq代表间隔频率，tmp_data1.index[0]代表起始时间,tmp_data1.index[-1]代表结束时间</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    t_disc = tmp_data1[c_disc]<br>    plt.figure(figsize=(<span class="hljs-number">120</span>,<span class="hljs-number">10</span>))<br>    plt.title(c_disc)    <br>    plt.ylabel(c_disc)    <br>    plt.gca().xaxis.set_major_formatter(mdate.DateFormatter(<span class="hljs-string">'%Y-%m-%d'</span>))<br>    plt.xticks(pd.date_range(tmp_data1.index[<span class="hljs-number">0</span>],tmp_data1.index[-<span class="hljs-number">1</span>],freq=<span class="hljs-string">'D'</span>),rotation=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#可视化</span><br><span class="hljs-comment">#设置x轴显示格式，设置x轴显示范围，freq代表间隔频率，tmp_data1.index[0]代表起始时间,tmp_data1.index[-1]代表结束时间</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    t_disc = tmp_data1[c_disc]<br>    plt.figure(figsize=(<span class="hljs-number">120</span>,<span class="hljs-number">10</span>))<br>    plt.title(c_disc)    <br>    plt.ylabel(c_disc)    <br>    plt.gca().xaxis.set_major_formatter(mdate.DateFormatter(<span class="hljs-string">'%Y-%m-%d'</span>))<br>    plt.xticks(pd.date_range(tmp_data1.index[<span class="hljs-number">0</span>],tmp_data1.index[-<span class="hljs-number">1</span>],freq=<span class="hljs-string">'D'</span>),rotation=<span class="hljs-number">45</span>) <br>    plt.plot(t_disc)<br></code></pre></td></tr></tbody></table></figure><p>其中一个曲线示意图：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_plot.4833uxky2zg0.jpg" width="100%/"></div> <p>可以看出，数据有明显的异常点，要么很大，要么很小。为了后面的数据分析与模型训练，我们所以需要对这些明显的异常点进行简单处理。处理方式为使用箱型图，筛选出异常点，然后用前值进行替换。 在此之前，我们先对时间索引进行处理。在这里，我的数据采样间隔大致为2s，但并不固定。因此，在尽可能不影响原数据的情况下，将重采样间隔设置为2S，只做规范时间频率使用。使用resample()函数处理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#重采样 </span><br>tmp_data1 = data1.resample(<span class="hljs-string">'2S'</span>).mean() <span class="hljs-comment"><code class="language-hljs python"><span class="hljs-comment">#重采样 </span><br>tmp_data1 = data1.resample(<span class="hljs-string">'2S'</span>).mean() <span class="hljs-comment">#时间间隔取2S，mean()取平均值,用tmp_data1接收转换后的表，不改变原表内容</span><br>tmp_data1<br></code></pre></td></tr></tbody></table></figure><p>重采样后的数据：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_resample.tfaifs2cgrk.jpg" width="100%/"></div>  <p>可以看出，数据时间间隔已变为2S等距，且值也有所变化，因为非等距时间间隔，不可避免地出现了缺失值。因此下一步对缺失值进行<strong>填补</strong>。填补策略为：对短时间缺失数据填补，长时间缺失数据删除。填补使用缺失点前7个历史数据的均值填补，以是否连续缺失十个点判断是否是长时间缺失数据。这里自己写了个填补函数用于实现上面的功能。（对于几百万的数据量，填补时间很长，有一两小时）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nmeans_fill_missing</span>(<span class="hljs-params">fill_col, df , window=<span class="hljs-number">7</span>, time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 对表格中的某一列的缺失值进行填补，使用邻近历史数据的均值填补，对于大范围缺失点，不进行填补，可对均值窗口、缺失时间范围进行设置</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        window: 插值窗口大小</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        count = <span class="hljs-number">0</span><br>        i=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            <span class="hljs-comment"># count += 1</span><br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    i += time_range<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        i +=<span class="hljs-number">1</span><br>                    count = i   <br>                <span class="hljs-keyword">else</span>:  <br>                    <span class="hljs-keyword">if</span> i - count &lt;= window:         <span class="hljs-comment">#判断当前位置是否有足够历史数据进行插值</span><br>                        <span class="hljs-keyword">if</span> i+window&gt;=<span class="hljs-built_in">len</span>(df):       <span class="hljs-comment">#如果已经到了表格末尾，后续数据不够进行填补，直接略过剩下的点。该策略仅针对数据量足够大的情况</span><br>                            <span class="hljs-keyword">break</span><br>                        train_value_list = []   <span class="hljs-comment">#用于当历史数据不够的情况存放窗口内的点，如 [1,2,3,current:NAN,5,6,7]  此时历史数据不够，则取从1开始的7个点，掠过略过空值</span><br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(window):<br>                            train_value = np.isnan(df[fill_col].iloc[j+count]) <br>                            <span class="hljs-keyword">if</span> train_value == <span class="hljs-literal">False</span>:<br>                                train_value_list.append(df[fill_col].iloc[j+count])<br>                        df[fill_col].iloc[i] = np.array(train_value_list).mean()<br>                    <span class="hljs-keyword">else</span>:<br>                        df[fill_col].iloc[i] = df[fill_col][i - window:i].mean()  <span class="hljs-comment">#如果窗口大小满足，取前window内的均值填补</span><br>            i +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> df<br><br><span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">islong_missing</span>(<span class="hljs-params">fill_col, df , range_window=<span class="hljs-number">10</span>, row_index=<span class="hljs-number">0</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        判断当前空值点是否是长间隔</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表  </span><br><span class="hljs-string">        window:插值窗口大小</span><br><span class="hljs-string">        range_window: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        fill_col: 选择插值的列,可填名字.也可填index</span><br><span class="hljs-string">        row_index: 开始判断的起始索引</span><br><span class="hljs-string">        '''</span><br><br>        islonginterval = <span class="hljs-literal">True</span>    <span class="hljs-comment">#判断当前空值是否属于长时间范围内的空值，是的话就跳过，不进行插值填补</span><br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 判断逻辑：判断后续十个时间点是否为空，当存在一个非空点，即跳出循环，且islonginterval为false</span><br>        <span class="hljs-keyword">while</span> row_index+count&lt;<span class="hljs-built_in">len</span>(df) <span class="hljs-keyword">and</span> islonginterval==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> count&lt;=range_window:<br>            islonginterval = np.isnan(df[fill_col].iloc[row_index+count])<br>            count +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> islonginterval<br><br><span class="hljs-comment">#对两列分别填补</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    tmp_data1 = nmeans_fill_missing(c_disc, tmp_data1, window=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nmeans_fill_missing</span>(<span class="hljs-params">fill_col, df , window=<span class="hljs-number">7</span>, time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 对表格中的某一列的缺失值进行填补，使用邻近历史数据的均值填补，对于大范围缺失点，不进行填补，可对均值窗口、缺失时间范围进行设置</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        window: 插值窗口大小</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        count = <span class="hljs-number">0</span><br>        i=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            <span class="hljs-comment"># count += 1</span><br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    i += time_range<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        i +=<span class="hljs-number">1</span><br>                    count = i   <br>                <span class="hljs-keyword">else</span>:  <br>                    <span class="hljs-keyword">if</span> i - count &lt;= window:         <span class="hljs-comment">#判断当前位置是否有足够历史数据进行插值</span><br>                        <span class="hljs-keyword">if</span> i+window&gt;=<span class="hljs-built_in">len</span>(df):       <span class="hljs-comment">#如果已经到了表格末尾，后续数据不够进行填补，直接略过剩下的点。该策略仅针对数据量足够大的情况</span><br>                            <span class="hljs-keyword">break</span><br>                        train_value_list = []   <span class="hljs-comment">#用于当历史数据不够的情况存放窗口内的点，如 [1,2,3,current:NAN,5,6,7]  此时历史数据不够，则取从1开始的7个点，掠过略过空值</span><br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(window):<br>                            train_value = np.isnan(df[fill_col].iloc[j+count]) <br>                            <span class="hljs-keyword">if</span> train_value == <span class="hljs-literal">False</span>:<br>                                train_value_list.append(df[fill_col].iloc[j+count])<br>                        df[fill_col].iloc[i] = np.array(train_value_list).mean()<br>                    <span class="hljs-keyword">else</span>:<br>                        df[fill_col].iloc[i] = df[fill_col][i - window:i].mean()  <span class="hljs-comment">#如果窗口大小满足，取前window内的均值填补</span><br>            i +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> df<br><br><span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">islong_missing</span>(<span class="hljs-params">fill_col, df , range_window=<span class="hljs-number">10</span>, row_index=<span class="hljs-number">0</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        判断当前空值点是否是长间隔</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表  </span><br><span class="hljs-string">        window:插值窗口大小</span><br><span class="hljs-string">        range_window: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        fill_col: 选择插值的列,可填名字.也可填index</span><br><span class="hljs-string">        row_index: 开始判断的起始索引</span><br><span class="hljs-string">        '''</span><br><br>        islonginterval = <span class="hljs-literal">True</span>    <span class="hljs-comment">#判断当前空值是否属于长时间范围内的空值，是的话就跳过，不进行插值填补</span><br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 判断逻辑：判断后续十个时间点是否为空，当存在一个非空点，即跳出循环，且islonginterval为false</span><br>        <span class="hljs-keyword">while</span> row_index+count&lt;<span class="hljs-built_in">len</span>(df) <span class="hljs-keyword">and</span> islonginterval==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> count&lt;=range_window:<br>            islonginterval = np.isnan(df[fill_col].iloc[row_index+count])<br>            count +=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> islonginterval<br><br><span class="hljs-comment">#对两列分别填补</span><br><span class="hljs-keyword">for</span> c_disc <span class="hljs-keyword">in</span> [<span class="hljs-string">'Comp0_Te'</span>,<span class="hljs-string">'Comp1_Te'</span>]:<br>    tmp_data1 = nmeans_fill_missing(c_disc, tmp_data1, window=<span class="hljs-number">7</span>)<br>tmp_data1<br></code></pre></td></tr></tbody></table></figure><p>为了检验填补效果，又写了个子函数，用来获取每次检测到的长间隔时间端的开始时间和结束时间对于的行数。根据返回的结果，查询对应的时间信息，判断是否满足填补策略</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_long_missing</span>(<span class="hljs-params">fill_col, df , time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 获取长间隔断点的点信息，返回dot_list数组，每两个为一对时间段</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        i=<span class="hljs-number">0</span><br>        dot_list = []<br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    dot_list.append(i)<br>                    i += (time_range-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        i +=<span class="hljs-number">1</span><br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        <br>                    dot_list.append(i)   <br>            i +=<span class="hljs-number">1</span><br>        <span class="hljs-keyword"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_long_missing</span>(<span class="hljs-params">fill_col, df , time_range = <span class="hljs-number">10</span></span>):<br>        <span class="hljs-string">'''</span><br><span class="hljs-string">        实现功能： 获取长间隔断点的点信息，返回dot_list数组，每两个为一对时间段</span><br><span class="hljs-string">        fill_col: 选择插值的列，可填名字，也可填index</span><br><span class="hljs-string">        df: DataFrame,输入需要插值的表</span><br><span class="hljs-string">        time_range: 设置判断长时间间隔的点数</span><br><span class="hljs-string">        '''</span><br>        <span class="hljs-comment"># count记录起始位置，每当遇到长间隔空值点，会将count移动到下一个非空值点</span><br>        i=<span class="hljs-number">0</span><br>        dot_list = []<br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(df):<br>            value = np.isnan(df[fill_col].iloc[i])   <span class="hljs-comment">#判断当前值是否为空</span><br>            <span class="hljs-keyword">if</span> value == <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 判断当前空值点是否是长间隔</span><br>                islonginterval = islong_missing(fill_col, df , range_window=time_range, row_index=i)<br>                <span class="hljs-comment">#当遇到长间隔空值时，将count一直移动到下一个非空点</span><br>                <span class="hljs-keyword">if</span> islonginterval:<br>                    dot_list.append(i)<br>                    i += (time_range-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">while</span> value ==<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> i&lt;<span class="hljs-built_in">len</span>(df):<br>                        i +=<span class="hljs-number">1</span><br>                        value = np.isnan(df[fill_col].iloc[i])<br>                        <br>                    dot_list.append(i)   <br>            i +=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dot_list<br></code></pre></td></tr></tbody></table></figure><p>然后删除缺失值并导出。使用reset_index()是为了让时间索引一起导出来。这里用的导出方法缺点是索引需要自己手动加上去。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#删除缺失值</span><br>tmp_data1 = tmp_data1.dropna(axis = <span class="hljs-number">0</span>, how = <span class="hljs-string">'all'</span>,inplace = <span class="hljs-literal">False</span>)<br><span class="hljs-comment">#避免之后重新填补，导出经插值，删除空值后的表</span><br>path = os.path.abspath(<span class="hljs-string">r'./data/l1_tehu'</span>)  <span class="hljs-comment"># 文件夹路径</span><br>new_file_name = <span class="hljs-string">'tmp_data1_insert.csv'</span><br>tmp_data1.reset_index().to_csv(path + <span class="hljs-string">'/'</span> + new_file_name, mode=<span class="hljs-string">'a'</span>, encoding=<span class="hljs-string">'gbk'</span>, header=<span class="hljs-literal">False</span>, index=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment">#删除缺失值</span><br>tmp_data1 = tmp_data1.dropna(axis = <span class="hljs-number">0</span>, how = <span class="hljs-string">'all'</span>,inplace = <span class="hljs-literal">False</span>)<br><span class="hljs-comment">#避免之后重新填补，导出经插值，删除空值后的表</span><br>path = os.path.abspath(<span class="hljs-string">r'./data/l1_tehu'</span>)  <span class="hljs-comment"># 文件夹路径</span><br>new_file_name = <span class="hljs-string">'tmp_data1_insert.csv'</span><br>tmp_data1.reset_index().to_csv(path + <span class="hljs-string">'/'</span> + new_file_name, mode=<span class="hljs-string">'a'</span>, encoding=<span class="hljs-string">'gbk'</span>, header=<span class="hljs-literal">False</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></tbody></table></figure><p>下面对前面的<strong>异常值</strong>进行处理。这里只选取其中一个片段进行示范。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python">twoday_data = tmp_data1[<span class="hljs-string">'2021-11-01 18:58:30'</span>: <span class="hljs-string">'2021-11-03 11:35:00'</span>]<br>twoday_data.describe()  <span class="hljs-comment"><code class="language-hljs python">twoday_data = tmp_data1[<span class="hljs-string">'2021-11-01 18:58:30'</span>: <span class="hljs-string">'2021-11-03 11:35:00'</span>]<br>twoday_data.describe()  <span class="hljs-comment">#描述表的一些信息</span><br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_twoday_describe.3qyix6pukji0.jpg" width="40%/"></div>  <p>画出箱线图，可以看出存在的一些异常点：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp0_Te'</span>])<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp1_Te'</span>])<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number"><code class="language-hljs python">plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp0_Te'</span>])<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>plt.boxplot(twoday_data[<span class="hljs-string">'Comp1_Te'</span>])<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br>plt.show()<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_twoday_boxplot.705wl11k1jo0.jpg" width="60%/"></div>  <p>然后利用四分位，删除异常值并用前值进行填补。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 超过了上四分位2倍四分位距或下四分位2倍距离都算异常值，用上一个值填充</span><br>a = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.75</span>)<br>b = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.25</span>)<br>c = twoday_data[<span class="hljs-string">'Comp0_Te'</span>]<br>c[(c&gt;=(a-b)*<span class="hljs-number">2</span>+a)|(c&lt;=b-(a-b)*<span class="hljs-number">2</span>)]=np.nan<br>c.fillna(method=<span class="hljs-string">'pad'</span>,inplace=<span class="hljs-literal">True</span>)<br>twoday_data[<span class="hljs-string">'Comp0_Te'</span>] = c<br><span class="hljs-built_in">print</span>(twoday_data[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 超过了上四分位2倍四分位距或下四分位2倍距离都算异常值，用上一个值填充</span><br>a = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.75</span>)<br>b = twoday_data[<span class="hljs-string">'Comp0_Te'</span>].quantile(<span class="hljs-number">0.25</span>)<br>c = twoday_data[<span class="hljs-string">'Comp0_Te'</span>]<br>c[(c&gt;=(a-b)*<span class="hljs-number">2</span>+a)|(c&lt;=b-(a-b)*<span class="hljs-number">2</span>)]=np.nan<br>c.fillna(method=<span class="hljs-string">'pad'</span>,inplace=<span class="hljs-literal">True</span>)<br>twoday_data[<span class="hljs-string">'Comp0_Te'</span>] = c<br><span class="hljs-built_in">print</span>(twoday_data[<span class="hljs-string">'Comp0_Te'</span>].describe())<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/componet_twoday_boxplot_new.44m969zxzbg0.jpg" width="60%/"></div>  <p>异常值处理完后，还有数据平滑处理。平滑处理在第二张表中演示。下面处理第二张表的数据。同样的操作，先将时间列设为索引，展示data2中数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python">data2.index = pd.to_datetime(data2.Datetime) <span class="hljs-comment"><code class="language-hljs python">data2.index = pd.to_datetime(data2.Datetime) <span class="hljs-comment">#设置时间列为索引</span><br>data2<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/L1_id_data.6dh59h41kq40.jpg" width="40%/"></div>   <p>表中有个ID列，表示各个传感器的型号，做数据分析时，可以将ID列提取出来，作为列索引，方便观察。因此，先对表格进行<strong>透视</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#数据透视</span><br><span class="hljs-comment">#tmp_data2用来拷贝data2数据变为二重索引表，原表数据保留 </span><br>tmp_data2=data2   <br>tmp_data2[<span class="hljs-string">'L1_id'</span>] = tmp_data2[<span class="hljs-string">'L1_id'</span>].astype(<span class="hljs-built_in">str</span>)<br>tmp_data2=data2.pivot_table(index=<span class="hljs-string">'Datetime'</span>,columns=<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment">#数据透视</span><br><span class="hljs-comment">#tmp_data2用来拷贝data2数据变为二重索引表，原表数据保留 </span><br>tmp_data2=data2   <br>tmp_data2[<span class="hljs-string">'L1_id'</span>] = tmp_data2[<span class="hljs-string">'L1_id'</span>].astype(<span class="hljs-built_in">str</span>)<br>tmp_data2=data2.pivot_table(index=<span class="hljs-string">'Datetime'</span>,columns=<span class="hljs-string">'L1_id'</span>)<br>tmp_data2<br></code></pre></td></tr></tbody></table></figure><p>透视结果如下所示：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/L1_id_pivot.2ab6wthn3ack.jpg" width="100%/"></div>  <p>表格的列变成了二重索引，为了方便后续引用，将其变为一重索引。需要注意的是，这种变换需要数据类型都为string型，如果不是，需要提前转换。当然，还有一种手动方法，变为二重索引后导出表，将原列索引删除，自己再加上索引就好。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#改为一重列索引表，用one_class_data2表示</span><br>one_class_data2 =tmp_data2.copy(deep=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#拷贝表格</span><br>one_class_data2.columns = [<span class="hljs-string">"_"</span>.join(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> one_class_data2.columns.ravel()]  <span class="hljs-comment">#将原来的二重索引的列名进行拼接</span><br><span class="hljs-comment"><code class="language-hljs python"><span class="hljs-comment">#改为一重列索引表，用one_class_data2表示</span><br>one_class_data2 =tmp_data2.copy(deep=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#拷贝表格</span><br>one_class_data2.columns = [<span class="hljs-string">"_"</span>.join(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> one_class_data2.columns.ravel()]  <span class="hljs-comment">#将原来的二重索引的列名进行拼接</span><br><span class="hljs-comment"># one_class_data2.columns = tmp_data2.columns.droplevel(0)  #这个方法是直接将外围第二重索引去掉，只取第一重列索引。</span><br>one_class_data2<br></code></pre></td></tr></tbody></table></figure><p>结果如下：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/L1_id_oneclass.59gip30dtvk0.jpg" width="100%/"></div>  <p>可以看到，列已经变为一重，列名为二重列名拼接而成。后续步骤与第一张表一样，这里不再做解释。最后再对其进行<strong>平滑处理</strong>。平滑方式选用传统的<em>巴特沃斯</em> 低通滤波器。对于参数wn的确定，首先采样频率定为1=采样长度/采样时间（其实采样频率可以自己定，其他的频率以采样频率为基准进行计算即可，结果都一样）。截止频率需要根据实际的来，我的数据中最大的频率差不多以77个点为一个周期，所以稍微扩大下范围后计算截止频率 = 1/60（采样频率为1，那么采样时间即为周期T=1）。根据公式wn = 2*截止频率/采样频率 = 0.033。以两天的数据量为例。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 低通滤波器-巴特沃斯</span><br><span class="hljs-comment"># wn=2*截至频率/采样频率   如果一天采样10个点，采样频率为10，截止频率为想要滤除的频率上限或下限</span><br><span class="hljs-comment"># pivot_data为透视后清理完的表</span><br>twoday_data = pivot_data[<span class="hljs-string">'2022-01-26 00:00:00'</span>:<span class="hljs-string">'2022-01-28 00:00:00'</span>]<br>b, a = signal.butter(<span class="hljs-number">10</span>, <span class="hljs-number">0.033</span>, <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>twoday_data[<span class="hljs-string">'Te_0_filter'</span>] = signal.filtfilt(b, a, twoday_data[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 低通滤波器-巴特沃斯</span><br><span class="hljs-comment"># wn=2*截至频率/采样频率   如果一天采样10个点，采样频率为10，截止频率为想要滤除的频率上限或下限</span><br><span class="hljs-comment"># pivot_data为透视后清理完的表</span><br>twoday_data = pivot_data[<span class="hljs-string">'2022-01-26 00:00:00'</span>:<span class="hljs-string">'2022-01-28 00:00:00'</span>]<br>b, a = signal.butter(<span class="hljs-number">10</span>, <span class="hljs-number">0.033</span>, <span class="hljs-string">'lowpass'</span>) <span class="hljs-comment">#配置滤波器 8 表示滤波器的阶数</span><br>twoday_data[<span class="hljs-string">'Te_0_filter'</span>] = signal.filtfilt(b, a, twoday_data[<span class="hljs-string">'Te_0'</span>])<br></code></pre></td></tr></tbody></table></figure><p>滤波结果如下：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/butter.6leaq5g4j7s0.jpg" width="50%/"></div>  <h2 id="2-2-探索性数据分析EDA"><a href="#2-2-探索性数据分析EDA" class="headerlink" title="2.2 探索性数据分析EDA"></a>2.2 探索性数据分析EDA</h2><p>首先进行相关性分析。这里以表data2为例。分析的数据取较完整地一个月的时间片段，重采样为1min适当减小数据量。（记得导入表后先设置时间索引）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs python">Month_data2 = data2[<span class="hljs-string">'2022-01-25 13:12:30'</span>:<span class="hljs-string">'2022-02-24 15:13:00'</span>]<br><span class="hljs-comment"># 重采样一分钟(一个月数据)</span><br>Month_data2_1T = Month_data2.resample(<span class="hljs-string">'T'</span>).mean()<br>Month_data2_1T=Month_data2_1T.<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">#保留两位小数。</span><br><span class="hljs-comment"><code class="language-hljs python">Month_data2 = data2[<span class="hljs-string">'2022-01-25 13:12:30'</span>:<span class="hljs-string">'2022-02-24 15:13:00'</span>]<br><span class="hljs-comment"># 重采样一分钟(一个月数据)</span><br>Month_data2_1T = Month_data2.resample(<span class="hljs-string">'T'</span>).mean()<br>Month_data2_1T=Month_data2_1T.<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">#保留两位小数。</span><br><span class="hljs-comment"># 相关系数</span><br>Month_data2_1T.corr()<br></code></pre></td></tr></tbody></table></figure><p>这里仅展示部分结果图：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_corr.5gurkritpvs0.jpg" width="50%/"></div>  <p>可以看到，每个变量间的相关程度都很高，不利用互相作为特征值。<br>对数据的自相关性和偏相关性进行分析。自相关：描述的是一组时间序列和它前面间隔n个时刻的一组时间序列之前的相关性。偏自相关：描述的是一组时间序列和它前面间隔n个时刻的一组时间序列之前的偏相关性。这里的偏相关性可以从本质上理解为去除了样本之间的干涉，也就是更早时刻的相关性影响。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 自相关，偏自相关，列出每一列的相关图</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    fig = plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">121</span>)<br>    ax1.set_xlabel(c)<br>    ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>    ax2.set_xlabel(c)<br>    plot_acf(Month_data2_1T[c],lags=<span class="hljs-number">50</span>,ax = ax1)<br>    plot_pacf(Month_data2_1T[c],lags=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># 自相关，偏自相关，列出每一列的相关图</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    fig = plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">121</span>)<br>    ax1.set_xlabel(c)<br>    ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>    ax2.set_xlabel(c)<br>    plot_acf(Month_data2_1T[c],lags=<span class="hljs-number">50</span>,ax = ax1)<br>    plot_pacf(Month_data2_1T[c],lags=<span class="hljs-number">50</span>,ax = ax2)<br>    plt.tight_layout()<br></code></pre></td></tr></tbody></table></figure><p>同样的，展示部分结果图。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_acf.3xqf5jmk4f80.jpg" width="60%/"></div>  <p>研究自相关、偏相关可用于判断是否适合使用时间预测方法,也可用于查看周期（下面会有演示）。该图可应用于LSTM算法，作为参数选择的依据。具体使用方法有待明确。<br>查看温湿度的统计分布。这里仅仅是查看下数据分布，目前没有对于其分析的一些想法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 管道温湿度统计分布图</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col: <br>    plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">3</span>))<br>    sns.distplot(Month_data2_1T[c], bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in"><code class="language-hljs python"><span class="hljs-comment"># 管道温湿度统计分布图</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col: <br>    plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">3</span>))<br>    sns.distplot(Month_data2_1T[c], bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in">len</span>(Month_data2_1T[c]))))<br></code></pre></td></tr></tbody></table></figure><p>展示部分结果图。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_distplot.462fv8dw1b00.jpg" width="60%/"></div>  <p>数据平稳性判断，使用单位根检验法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_stationarity</span>(<span class="hljs-params">y, lags_plots=<span class="hljs-number">48</span>, figsize=(<span class="hljs-params"><span class="hljs-number">22</span>,<span class="hljs-number">8</span></span>)</span>):<br>    <span class="hljs-string">"Use Series as parameter"</span><br>    <span class="hljs-comment"># Creating plots of the DF</span><br>    y = pd.Series(y)<br>    fig = plt.figure()<br><br>    ax1 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br>    ax2 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>))<br>    ax3 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    ax4 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br><br>    y.plot(ax=ax1, figsize=figsize)<br>    ax1.set_title(<span class="hljs-string">'Nums Variation'</span>)<br>    plot_acf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax2);<br>    plot_pacf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax3);<br>    sns.distplot(y, bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in">len</span>(y))), ax=ax4)<br>    ax4.set_title(<span class="hljs-string">'Distribution Chart'</span>)<br><br>    plt.tight_layout()<br>    <span class="hljs-comment"># plt.show()</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Results of Dickey-Fuller Test:'</span>)<br>    <span class="hljs-comment">#  regression：{c”，“ct”，“ctt”，“n”}要包含在回归中的常数和趋势顺序。</span><br>    <span class="hljs-comment"># “c”：仅限常量（默认值）。</span><br>    <span class="hljs-comment"># “ct”：恒定和趋势。</span><br>    <span class="hljs-comment"># “ctt”：常数、线性和二次趋势。</span><br>    <span class="hljs-comment"># n：没有常数，没有趋势。</span><br><br>    <span class="hljs-comment"># ADF的结果主要看以下两个方面：</span><br>    <span class="hljs-comment"># Test Statistic的值如果比Critical Value (5%)小则满足稳定性需求.</span><br>    <span class="hljs-comment"># p-value越低（理论上需要低于0.05）证明序列越稳定。</span><br>    adfinput = adfuller(y,regression = <span class="hljs-string">'c'</span>)  <span class="hljs-comment">#单位根检验</span><br>    adftest = pd.Series(adfinput[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], index=[<span class="hljs-string">'Test Statistic'</span>,<span class="hljs-string">'p-value'</span>,<span class="hljs-string">'Lags Used'</span>,<span class="hljs-string">'Number of Observations Used'</span>])<br>    adftest = <span class="hljs-built_in">round</span>(adftest,<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> adfinput[<span class="hljs-number">4</span>].items():<br>        adftest[<span class="hljs-string">"Critical Value (%s)"</span>%key] = value.<span class="hljs-built_in">round</span>(<span class="hljs-number">4</span>)<br>        <br>    <span class="hljs-built_in">print</span>(adftest)<br>    <br>    <span class="hljs-keyword">if</span> adftest[<span class="hljs-number">0</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) &lt; adftest[<span class="hljs-number">5</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'\nThe Test Statistics is lower than the Critical Value of 5%.\nThe serie seems to be stationary'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nThe Test Statistics is higher than the Critical Value of 5%.\nThe serie isn't stationary"</span>)<br><br><span class="hljs-comment"># 检验平稳性</span><br>check_stationarity(Month_data2_1T[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_stationarity</span>(<span class="hljs-params">y, lags_plots=<span class="hljs-number">48</span>, figsize=(<span class="hljs-params"><span class="hljs-number">22</span>,<span class="hljs-number">8</span></span>)</span>):<br>    <span class="hljs-string">"Use Series as parameter"</span><br>    <span class="hljs-comment"># Creating plots of the DF</span><br>    y = pd.Series(y)<br>    fig = plt.figure()<br><br>    ax1 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br>    ax2 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>))<br>    ax3 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    ax4 = plt.subplot2grid((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br><br>    y.plot(ax=ax1, figsize=figsize)<br>    ax1.set_title(<span class="hljs-string">'Nums Variation'</span>)<br>    plot_acf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax2);<br>    plot_pacf(y, lags=lags_plots, zero=<span class="hljs-literal">False</span>, ax=ax3);<br>    sns.distplot(y, bins=<span class="hljs-built_in">int</span>(np.sqrt(<span class="hljs-built_in">len</span>(y))), ax=ax4)<br>    ax4.set_title(<span class="hljs-string">'Distribution Chart'</span>)<br><br>    plt.tight_layout()<br>    <span class="hljs-comment"># plt.show()</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Results of Dickey-Fuller Test:'</span>)<br>    <span class="hljs-comment">#  regression：{c”，“ct”，“ctt”，“n”}要包含在回归中的常数和趋势顺序。</span><br>    <span class="hljs-comment"># “c”：仅限常量（默认值）。</span><br>    <span class="hljs-comment"># “ct”：恒定和趋势。</span><br>    <span class="hljs-comment"># “ctt”：常数、线性和二次趋势。</span><br>    <span class="hljs-comment"># n：没有常数，没有趋势。</span><br><br>    <span class="hljs-comment"># ADF的结果主要看以下两个方面：</span><br>    <span class="hljs-comment"># Test Statistic的值如果比Critical Value (5%)小则满足稳定性需求.</span><br>    <span class="hljs-comment"># p-value越低（理论上需要低于0.05）证明序列越稳定。</span><br>    adfinput = adfuller(y,regression = <span class="hljs-string">'c'</span>)  <span class="hljs-comment">#单位根检验</span><br>    adftest = pd.Series(adfinput[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], index=[<span class="hljs-string">'Test Statistic'</span>,<span class="hljs-string">'p-value'</span>,<span class="hljs-string">'Lags Used'</span>,<span class="hljs-string">'Number of Observations Used'</span>])<br>    adftest = <span class="hljs-built_in">round</span>(adftest,<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> adfinput[<span class="hljs-number">4</span>].items():<br>        adftest[<span class="hljs-string">"Critical Value (%s)"</span>%key] = value.<span class="hljs-built_in">round</span>(<span class="hljs-number">4</span>)<br>        <br>    <span class="hljs-built_in">print</span>(adftest)<br>    <br>    <span class="hljs-keyword">if</span> adftest[<span class="hljs-number">0</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>) &lt; adftest[<span class="hljs-number">5</span>].<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'\nThe Test Statistics is lower than the Critical Value of 5%.\nThe serie seems to be stationary'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nThe Test Statistics is higher than the Critical Value of 5%.\nThe serie isn't stationary"</span>)<br><br><span class="hljs-comment"># 检验平稳性</span><br>check_stationarity(Month_data2_1T[<span class="hljs-string">'Te_0'</span>])<br></code></pre></td></tr></tbody></table></figure><blockquote><p>输出结果为：<br>Results of Dickey-Fuller Test:<br>Test Statistic                    -1.4583<br>p-value                            0.5540<br>Lags Used                         55.0000<br>Number of Observations Used    43266.0000<br>Critical Value (1%)               -3.4305<br>Critical Value (5%)               -2.8616<br>Critical Value (10%)              -2.5668<br>dtype: float64<br>The Test Statistics is higher than the Critical Value of 5%.<br>The serie isn’t stationary  </p></blockquote><p>判断平稳性两个标准：Test Statistic小于Critical Value (5%)　或是p-value小于0.05。平稳性是多数统计学模型的必要条件之一。可见原数据并不是平稳序列。<br>对于非平稳序列，可使用一阶差分使其平稳化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#序列平稳化，一阶差分</span><br>Month_data2_1T[<span class="hljs-string">'Te_0_diff'</span>] = Month_data2_1T[<span class="hljs-string">'Te_0'</span>].diff(<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#序列平稳化，一阶差分</span><br>Month_data2_1T[<span class="hljs-string">'Te_0_diff'</span>] = Month_data2_1T[<span class="hljs-string">'Te_0'</span>].diff(<span class="hljs-number">1</span>)<br></code></pre></td></tr></tbody></table></figure><p>其稳定性结果为：</p><blockquote><p>Results of Dickey-Fuller Test:<br>Test Statistic                   -51.9122<br>p-value                            0.0000<br>Lags Used                         54.0000<br>Number of Observations Used    43267.0000<br>Critical Value (1%)               -3.4305<br>Critical Value (5%)               -2.8616<br>Critical Value (10%)              -2.5668<br>dtype: float64<br>The Test Statistics is lower than the Critical Value of 5%.<br>The serie seems to be stationary</p></blockquote><p>可见一阶差分可以有效是原序列平稳。后期可利用差分序列进行异常检测训练。<br>时间序列分解：所谓分解就是将时序数据分离成不同的成分，分解为：长期趋势Trend、季节性Seasonality和随机残差Residuals。分解序列后可针对每个子序列分别建模处理，如建模趋势后，在原数据中减去趋势的干扰。又或者当作特征值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 管道温湿度时序序列分解：趋势+季节性+残差</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    <span class="hljs-comment">#用加性模型，周期1440为1440min，分解数据时间频率为1min，一天为1440min。这里将一天设为周期，那么分解出的季节性数据以1天为周期</span><br>    decompose_result = seasonal_decompose(Month_data2_1T[c], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br>    fig = plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">411</span>)<br>    ax2 = fig.add_subplot(<span class="hljs-number">412</span>)<br>    ax3 = fig.add_subplot(<span class="hljs-number">413</span>)<br>    ax4 = fig.add_subplot(<span class="hljs-number">414</span>)<br>    ax1.set_xlabel(c)<br>    ax1.set_ylabel(<span class="hljs-string">'init'</span>)<br>    ax2.set_xlabel(c)<br>    ax2.set_ylabel(<span class="hljs-string">'trend'</span>)<br>    ax3.set_xlabel(c)<br>    ax3.set_ylabel(<span class="hljs-string">'seasonal'</span>)<br>    ax4.set_xlabel(c)<br>    ax4.set_ylabel(<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment"># 管道温湿度时序序列分解：趋势+季节性+残差</span><br>col = Month_data2_1T.columns<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> col:  <br>    <span class="hljs-comment">#用加性模型，周期1440为1440min，分解数据时间频率为1min，一天为1440min。这里将一天设为周期，那么分解出的季节性数据以1天为周期</span><br>    decompose_result = seasonal_decompose(Month_data2_1T[c], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br>    fig = plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>))<br>    ax1 = fig.add_subplot(<span class="hljs-number">411</span>)<br>    ax2 = fig.add_subplot(<span class="hljs-number">412</span>)<br>    ax3 = fig.add_subplot(<span class="hljs-number">413</span>)<br>    ax4 = fig.add_subplot(<span class="hljs-number">414</span>)<br>    ax1.set_xlabel(c)<br>    ax1.set_ylabel(<span class="hljs-string">'init'</span>)<br>    ax2.set_xlabel(c)<br>    ax2.set_ylabel(<span class="hljs-string">'trend'</span>)<br>    ax3.set_xlabel(c)<br>    ax3.set_ylabel(<span class="hljs-string">'seasonal'</span>)<br>    ax4.set_xlabel(c)<br>    ax4.set_ylabel(<span class="hljs-string">'resid'</span>)<br>    ax1.plot(Month_data2_1T[c])<br>    ax2.plot(decompose_result.trend)<br>    ax3.plot(decompose_result.seasonal)<br>    ax4.plot(decompose_result.resid)<br>    plt.tight_layout()<br></code></pre></td></tr></tbody></table></figure><p>部分结果如下：</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data2_1T_decompose.7bi8h01gdf40.jpg" width="80%/"></div><p>接下来进行周期性检验。首先使用FFT查看频谱图：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">define_fft</span>(<span class="hljs-params">data, fs = <span class="hljs-number">1</span>, show_pic=<span class="hljs-literal">False</span></span>): <br>    <span class="hljs-string">""" </span><br><span class="hljs-string">    # Parameters  </span><br><span class="hljs-string"></span><br><span class="hljs-string">    data: 检测数据，dataframe类型 </span><br><span class="hljs-string">    show_pic: 是否展示图片 </span><br><span class="hljs-string">    fs: 采样频率，采样时长除以采样点数 = 采样频率</span><br><span class="hljs-string">    """</span> <br>    n = data.shape[<span class="hljs-number">0</span>]<br>    x = data.values<br>    yy = fft(x)<br>    fre = fftfreq(n, <span class="hljs-number">1</span>/fs)<span class="hljs-comment">#求频率横坐标</span><br>    indices = np.where(fre &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">#筛选大于零的频率</span><br>    w_pos = <span class="hljs-number">2</span>*<span class="hljs-built_in">abs</span>(yy[indices])/n<span class="hljs-comment">#计算幅度值</span><br>    F_pos = fre[indices]<br><br>    result_fft = pd.DataFrame(columns=[<span class="hljs-string">'freq'</span>, <span class="hljs-string">'spec'</span>, <span class="hljs-string">'T'</span>]) <br>    result_fft[<span class="hljs-string">'freq'</span>] = F_pos <br>    result_fft[<span class="hljs-string">'spec'</span>] = w_pos <br>    result_fft[<span class="hljs-string">'T'</span>] = <span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span><br>    <span class="hljs-comment"># 按照频率强弱程度降序排列 </span><br>    result_fft = result_fft.sort_values(by=<span class="hljs-string">'spec'</span>, ascending=<span class="hljs-literal">False</span>) <br>    <span class="hljs-built_in">print</span>(result_fft.head(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">if</span> show_pic :<br>        <span class="hljs-comment"># 频率转换为周期 </span><br>        plt.plot(<span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span>, w_pos)<br>        plt.show()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>define_fft(Month_data2_1T[<span class="hljs-string">'Te_0'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">define_fft</span>(<span class="hljs-params">data, fs = <span class="hljs-number">1</span>, show_pic=<span class="hljs-literal">False</span></span>): <br>    <span class="hljs-string">""" </span><br><span class="hljs-string">    # Parameters  </span><br><span class="hljs-string"></span><br><span class="hljs-string">    data: 检测数据，dataframe类型 </span><br><span class="hljs-string">    show_pic: 是否展示图片 </span><br><span class="hljs-string">    fs: 采样频率，采样时长除以采样点数 = 采样频率</span><br><span class="hljs-string">    """</span> <br>    n = data.shape[<span class="hljs-number">0</span>]<br>    x = data.values<br>    yy = fft(x)<br>    fre = fftfreq(n, <span class="hljs-number">1</span>/fs)<span class="hljs-comment">#求频率横坐标</span><br>    indices = np.where(fre &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">#筛选大于零的频率</span><br>    w_pos = <span class="hljs-number">2</span>*<span class="hljs-built_in">abs</span>(yy[indices])/n<span class="hljs-comment">#计算幅度值</span><br>    F_pos = fre[indices]<br><br>    result_fft = pd.DataFrame(columns=[<span class="hljs-string">'freq'</span>, <span class="hljs-string">'spec'</span>, <span class="hljs-string">'T'</span>]) <br>    result_fft[<span class="hljs-string">'freq'</span>] = F_pos <br>    result_fft[<span class="hljs-string">'spec'</span>] = w_pos <br>    result_fft[<span class="hljs-string">'T'</span>] = <span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span><br>    <span class="hljs-comment"># 按照频率强弱程度降序排列 </span><br>    result_fft = result_fft.sort_values(by=<span class="hljs-string">'spec'</span>, ascending=<span class="hljs-literal">False</span>) <br>    <span class="hljs-built_in">print</span>(result_fft.head(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">if</span> show_pic :<br>        <span class="hljs-comment"># 频率转换为周期 </span><br>        plt.plot(<span class="hljs-number">1</span>/F_pos/<span class="hljs-number">1440</span>, w_pos)<br>        plt.show()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>define_fft(Month_data2_1T[<span class="hljs-string">'Te_0'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data_1T_periodogram.bx0uzqbkjcw.jpg" width="40%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/Month_data_1T_residperiod.4rqdgw1afwu0.jpg" width="30%/"></div>  <p>查看左侧频谱图，可以发现图是有问题的。在周期最大的三个点，也即频率最小的三个点处出现了很大的峰值，低频成分上翘，这明显不对。考虑原因可能有二。  </p><ol><li>原数据存在直流偏移的影响。<br>  解决办法：减去直流量，试减去平均值  </li><li>原数据中趋势的存在干扰了频谱分析。当信号中有明显的趋势项而未消除时，进行相关性分析和功率谱密度分析时会出现畸变，造成低频成分上翘甚至淹没主频成分。<br>  解决办法：去趋势。</li></ol><p>对原数据减去平均值后进行FFT分析，发现频谱图的形状并没有变化，改试方案2。去趋势的方法在网上有许多，这里使用了两种办法：多项式拟合去趋势和时序序列分解。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 多项式拟合去趋势,使用滤波后的数据</span><br>n = Month_data2_1T[<span class="hljs-string">'Te_0_filter'</span>].shape[<span class="hljs-number">0</span>]<br>x=np.linspace(<span class="hljs-number">1</span>, n, n)<br>y = Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>].values<br>z1 = np.polyfit(x, y, <span class="hljs-number">10</span>)              <span class="hljs-comment"># 曲线拟合，返回值为多项式的各项系数，10为阶数，具体数据选取看曲线拟合程度，可进行可视化查看</span><br>p1 = np.poly1d(z1)                    <span class="hljs-comment"># 返回值为多项式的表达式，也就是函数式子</span><br><span class="hljs-comment"># print(p1)</span><br>y_pred = p1(x)                        <span class="hljs-comment"># 根据函数的多项式表达式，求解 y,即趋势</span><br>Month_data_1T[<span class="hljs-string">'x'</span>]=Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>]-y_pred<br>define_fft(Month_data_1T[<span class="hljs-string">'x'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment"># 多项式拟合去趋势,使用滤波后的数据</span><br>n = Month_data2_1T[<span class="hljs-string">'Te_0_filter'</span>].shape[<span class="hljs-number">0</span>]<br>x=np.linspace(<span class="hljs-number">1</span>, n, n)<br>y = Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>].values<br>z1 = np.polyfit(x, y, <span class="hljs-number">10</span>)              <span class="hljs-comment"># 曲线拟合，返回值为多项式的各项系数，10为阶数，具体数据选取看曲线拟合程度，可进行可视化查看</span><br>p1 = np.poly1d(z1)                    <span class="hljs-comment"># 返回值为多项式的表达式，也就是函数式子</span><br><span class="hljs-comment"># print(p1)</span><br>y_pred = p1(x)                        <span class="hljs-comment"># 根据函数的多项式表达式，求解 y,即趋势</span><br>Month_data_1T[<span class="hljs-string">'x'</span>]=Month_data_1T[<span class="hljs-string">'Te_0_filter'</span>]-y_pred<br>define_fft(Month_data_1T[<span class="hljs-string">'x'</span>],fs=<span class="hljs-number">1</span>,show_pic=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure><p>下图为原数据曲线图、趋势图、原数据去趋势图和FFT图。可以看出，用拟合法去趋势后，FFT图尾端翘起现象几乎没有了，但仍有小尾巴残留。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/polyfit.1wq4d6hwhjq8.jpg" width="80%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/polyfit_detrend.2eofsy7hwrwg.jpg" width="80%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/ployfit_FFT.4u82p09d7n60.jpg" width="50%/">    </div>  <p>接下来是由时序序列分解法。该方法上面讲过了，操作步骤一致，只是在分解趋势适合，分解了两次，使用77周期分解以此，发现还有周期现象，又使用1440周期对分解出的趋势分解了一次，对用原数据减去二次趋势，再求FFT，结果如图。第一张为去趋势后的图，第二张为FFT结果图。可以看出，该方法去趋势效果更好。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/twice_detrend.7jhgdh1lahw0.jpg" width="80%/"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/twice_detrend_FFT.ekqba34lveo.jpg" width="40%/">    </div>  <p>根据频谱图结果，列出最大的三个能量谱的点依次为1天，0.5天，77min。可能的周期也是这三个点。再根据这三个点看自相关图，分别列出滞后点为1000和10000的相关图。如图所示。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Anomaly_detection_process_img/acf_1000.hy1dzybmthk.jpg" width="80%/"></div>  对于自相关图，当序列存在周期时，会在周期出出现一个高峰。从图中可以看出，曲线分别以约77和1440为周期处出现高峰。再结合实际，77min大致为系统运行一个周期，1440min为系统运行一天。由此可见，数据约以77min和1440min为周期。<h2 id="2-3-特征工程"><a href="#2-3-特征工程" class="headerlink" title="2.3 特征工程"></a>2.3 特征工程</h2><h3 id="2-3-1-特征提取"><a href="#2-3-1-特征提取" class="headerlink" title="2.3.1 特征提取"></a>2.3.1 特征提取</h3><ol><li><strong>从时间中提取特征</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#仅取第一列Hu_0数据</span><br>df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment">#仅取第一列Hu_0数据</span><br>df = Month_data_1T.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>df[<span class="hljs-string">'时间'</span>] = df.index<br><span class="hljs-comment"># 年份</span><br>df[<span class="hljs-string">'年'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.year)<br><span class="hljs-comment"># 月份</span><br>df[<span class="hljs-string">'月'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.month)<br><span class="hljs-comment"># 日</span><br>df[<span class="hljs-string">'日'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.day)<br><span class="hljs-comment"># 小时</span><br>df[<span class="hljs-string">'时'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.hour)<br><span class="hljs-comment"># 分钟</span><br>df[<span class="hljs-string">'分'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute)<br><span class="hljs-comment"># 一天中的第几分钟</span><br>df[<span class="hljs-string">'一天中的第几分钟'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.minute + x.hour*<span class="hljs-number">60</span>)<br><span class="hljs-comment"># 星期几；</span><br>df[<span class="hljs-string">'星期几'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofweek)<br><span class="hljs-comment"># 一年中的第几天</span><br>df[<span class="hljs-string">'一年中的第几天'</span>]=df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.dayofyear)<br><span class="hljs-comment"># # 一年中的第几周</span><br><span class="hljs-comment"># df['一年中的第几周']=df['时间'].apply(lambda x: x.week)</span><br><span class="hljs-comment"># 一天中哪个时间段：凌晨、早晨、上午、中午、下午、傍晚、晚上、深夜；</span><br>period_dict ={<br>    <span class="hljs-number">23</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>: <span class="hljs-number">0x00</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0x01</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0x01</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0x02</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0x03</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0x03</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-number">0x04</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0x04</span>,<span class="hljs-number">14</span>: <span class="hljs-number">0x04</span>, <br>    <span class="hljs-number">15</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">16</span>: <span class="hljs-number">0x05</span>, <span class="hljs-number">17</span>: <span class="hljs-number">0x05</span>,<span class="hljs-number">18</span>: <span class="hljs-number">0x05</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">20</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">21</span>: <span class="hljs-number">0x07</span>, <span class="hljs-number">22</span>: <span class="hljs-number">0x07</span>,<br><span class="hljs-comment">#     23: '深夜', 0: '深夜', 1: '深夜',</span><br><span class="hljs-comment">#     2: '凌晨', 3: '凌晨', 4: '凌晨',</span><br><span class="hljs-comment">#     5: '早晨', 6: '早晨', 7: '早晨',</span><br><span class="hljs-comment">#     8: '上午', 9: '上午', 10: '上午', 11: '上午',</span><br><span class="hljs-comment">#     12: '中午', 13: '中午',14: '中午',</span><br><span class="hljs-comment">#     15: '下午', 16: '下午', 17: '下午',18: '下午',</span><br><span class="hljs-comment">#     19: '晚上', 20: '晚上', 21: '晚上', 22: '晚上',</span><br>}<br>df[<span class="hljs-string">'时间段'</span>]=df[<span class="hljs-string">'时'</span>].<span class="hljs-built_in">map</span>(period_dict)<br><span class="hljs-comment"># # 一年中的哪个季度</span><br><span class="hljs-comment"># season_dict = {</span><br><span class="hljs-comment">#     1: '春季', 2: '春季', 3: '春季',</span><br><span class="hljs-comment">#     4: '夏季', 5: '夏季', 6: '夏季',</span><br><span class="hljs-comment">#     7: '秋季', 8: '秋季', 9: '秋季',</span><br><span class="hljs-comment">#     10: '冬季', 11: '冬季', 12: '冬季',</span><br><span class="hljs-comment"># }</span><br><span class="hljs-comment"># df['季节']=df['月'].map(season_dict)</span><br><span class="hljs-comment"># # 是否闰年</span><br><span class="hljs-comment"># df['是否闰年'] = df['时间'].apply(lambda x: x.is_leap_year)</span><br><span class="hljs-comment"># 是否月初</span><br>df[<span class="hljs-string">'是否月初'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_start)<br><span class="hljs-comment"># 是否月末</span><br>df[<span class="hljs-string">'是否月末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: x.is_month_end)<br><span class="hljs-comment"># 是否季节初</span><br><span class="hljs-comment"># df['是否季节初'] = df['时间'].apply(lambda x: x.is_quarter_start)</span><br><span class="hljs-comment"># 是否季节末</span><br><span class="hljs-comment"># df['是否季节末'] = df['时间'].apply(lambda x: x.is_quarter_end)</span><br><span class="hljs-comment"># 是否年初</span><br><span class="hljs-comment"># df['是否年初'] = df['时间'].apply(lambda x: x.is_year_start)</span><br><span class="hljs-comment"># 是否年尾</span><br><span class="hljs-comment"># df['是否年尾'] = df['时间'].apply(lambda x: x.is_year_end)</span><br><span class="hljs-comment"># 是否周末</span><br>df[<span class="hljs-string">'是否周末'</span>] = df[<span class="hljs-string">'时间'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> x.dayofweek <span class="hljs-keyword">in</span> [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>)<br>df<br></code></pre></td></tr></tbody></table></figure>结果如下图所示：<div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/时间特征.407xag8uznw0.jpg"></div> </li><li><strong>从时序规律中提取特征</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose<br><span class="hljs-comment"># 数据含有两个周期77和1440</span><br><span class="hljs-comment"># 偏移6min差分</span><br>df[<span class="hljs-string">"Hu0_-5S"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># 偏移77min差分，一小周期</span><br>df[<span class="hljs-string">"Hu0_-1period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移两小周期</span><br>df[<span class="hljs-string">"Hu0_-2period"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">2</span>*<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 偏移1天，一大周期</span><br>df[<span class="hljs-string">"Hu0_-1day"</span>] = df[<span class="hljs-string">'Hu_0'</span>].shift(<span class="hljs-number">1</span>*<span class="hljs-number">1440</span>)<br>decompose_result = seasonal_decompose(df[<span class="hljs-string">'Hu_0'</span>], model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">77</span>)<br><span class="hljs-comment"># 分离77周期分离</span><br>df[<span class="hljs-string">"Hu0_77seasonal"</span>] = decompose_result.seasonal<br>decompose_result = seasonal_decompose(decompose_result.seasonal, model=<span class="hljs-string">"additive"</span>, period=<span class="hljs-number">1440</span>)<br><span class="hljs-comment"># 分离1440周期分量</span><br>df[<span class="hljs-string">"Hu0_1440seasonal"</span>] = decompose_result.seasonal<br><span class="hljs-comment"># 趋势分量</span><br>df[<span class="hljs-string">"Hu0_trend"</span>] = decompose_result.trend<br><span class="hljs-comment"># 残差分量</span><br>df[<span class="hljs-string">"Hu0_resid"</span>] = decompose_result.resid<br>df<br></code></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%97%B6%E5%BA%8F%E8%A7%84%E5%BE%8B%E7%89%B9%E5%BE%81.5n1vvk2y3d40.jpg" alt="时序规律特征"></li><li><strong>从统计窗口提取特征</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#sum() 值的总和</span><br><span class="hljs-comment">#mean() 均值</span><br><span class="hljs-comment">#median() 值的算术中值</span><br><span class="hljs-comment">#min() 最小值</span><br><span class="hljs-comment">#max() 最大</span><br><span class="hljs-comment">#std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment">#var() 无偏方差</span><br><span class="hljs-comment">#cov() 无偏协方差（二元）</span><br><span class="hljs-comment">#corr() 相关（二进制）</span><br><span class="hljs-comment">#variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment">#polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment">#df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment">#一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string"><code class="language-hljs python"><span class="hljs-comment">#sum() 值的总和</span><br><span class="hljs-comment">#mean() 均值</span><br><span class="hljs-comment">#median() 值的算术中值</span><br><span class="hljs-comment">#min() 最小值</span><br><span class="hljs-comment">#max() 最大</span><br><span class="hljs-comment">#std() 贝塞尔修正样本标准差(均方差)</span><br><span class="hljs-comment">#var() 无偏方差</span><br><span class="hljs-comment">#cov() 无偏协方差（二元）</span><br><span class="hljs-comment">#corr() 相关（二进制）</span><br><span class="hljs-comment">#variation_v = std_v/mean_v 离散系数</span><br><span class="hljs-comment">#polyfit 线性拟合，求斜率</span><br><br><span class="hljs-comment">#使用rolling滚动窗口，窗口大小为7</span><br>roll_data = df[<span class="hljs-string">'Hu_0'</span>].rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_mean"</span>] = roll_data.mean()<br>df[<span class="hljs-string">"Hu0_median"</span>] = roll_data.median()<br>df[<span class="hljs-string">"Hu0_min"</span>] = roll_data.<span class="hljs-built_in">min</span>()<br>df[<span class="hljs-string">"Hu0_max"</span>] = roll_data.<span class="hljs-built_in">max</span>()<br>df[<span class="hljs-string">"Hu0_std"</span>] = roll_data.std()<br>df[<span class="hljs-string">"Hu0_var"</span>] = roll_data.var()<br>df[<span class="hljs-string">"Hu0_cov"</span>] = roll_data.cov()<br>df[<span class="hljs-string">"Hu0_corr"</span>] = roll_data.corr()<br>df[<span class="hljs-string">"Hu0_variation"</span>] = df[<span class="hljs-string">"Hu0_std"</span>]/df[<span class="hljs-string">"Hu0_mean"</span>]<br>df[<span class="hljs-string">"Hu0_sum"</span>] = roll_data.<span class="hljs-built_in">sum</span>()<br>df[<span class="hljs-string">"Hu0_sum_diff2"</span>] = df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">1</span>)-df[<span class="hljs-string">"Hu0_sum"</span>].shift(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#df["Hu0_autocorr1"] = df["Hu_0"].autocorr(1)</span><br><span class="hljs-comment">#df["Hu0_autocorr2"] = df["Hu_0"].autocorr(2)</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>z = <span class="hljs-keyword">lambda</span> y : np.polyfit(x, y, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>df[<span class="hljs-string">"Hu0_polyfit"</span>] = roll_data.apply(z)<br><span class="hljs-comment">#一阶差分的均方差</span><br>roll_data_diff = df[<span class="hljs-string">'Hu_0'</span>].diff(<span class="hljs-number">1</span>).rolling(window=<span class="hljs-number">7</span>)<br>df[<span class="hljs-string">"Hu0_diff_std"</span>] = roll_data_diff.std()<br>df<br></code></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E7%BB%9F%E8%AE%A1%E7%89%B9%E5%BE%81.6ahmg2mw8s00.jpg" alt="统计特征"></li><li><strong>利用tsfresh工具提取特征</strong><br>先将原序列转换为n个窗口子序列。原表one_data结构为：<br><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8E%9F%E8%A1%A8%E7%BB%93%E6%9E%84.119hmuad0jy8.jpg" alt="滚动窗口原表结构"><br>其中id,time列是在原表的基础上后加上的，目的是为了方便使用API接口函数。id代表组别，time代表时间顺序。然后使用API转换为窗口子序列。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh.utilities.dataframe_functions <span class="hljs-keyword">import</span> roll_time_series<br><span class="hljs-comment"># 滚动窗口</span><br><span class="hljs-comment">#max_timeshift:最大偏移量，min_timeshift：最小偏移量，rolling_direction：每次移动的大小和方向。column_sort按什么排序，默认已从小到大排好</span><br>df_rolled = roll_time_series(one_data, column_id=<span class="hljs-string">"id"</span>, column_sort=<span class="hljs-string">"time"</span>,max_timeshift = <span class="hljs-number">6</span> ,min_timeshift = <span class="hljs-number">6</span>,rolling_direction=-<span class="hljs-number">1</span>)<br>df_rolled<br></code></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/202204/Characteristic-Engineering-of-Time-Series/tsfresh%E7%AA%97%E5%8F%A3%E5%BA%8F%E5%88%97.4f2dy005fr40.jpg" alt="tsfresh窗口序列"><br>转化后的id是原id与原时间的组合，也为后面特征提取中的组别。（1，1）代表1号组别的第一个时间点组成的子序列，（1，43316）代表1号组别第43316个点组成的子序列。然后再进行特征提取.</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> tsfresh <span class="hljs-keyword">import</span> extract_features<br><span class="hljs-comment"># 特征提取,使用drop先删去多余的列，column_id为组别</span><br>df_features = extract_features(df_rolled.drop([<span class="hljs-string">"date"</span>,<span class="hljs-string">"time"</span>],axis = <span class="hljs-number">1</span>), column_id=<span class="hljs-string">"id"</span>)<br>df_features<br></code></pre></td></tr></tbody></table></figure><h3 id="2-3-2-特征预处理"><a href="#2-3-2-特征预处理" class="headerlink" title="2.3.2 特征预处理"></a>2.3.2 特征预处理</h3><p>首先处理表中的空值，因为前面窗口大小选为7，所以需要把表df（前面没有划分子窗口的表）的前六行删去，与df_features表的大小保持一致。df_features表中存在大量的空值，需要先将含空值的列删去。然后将df_features的索引设为df的索引，之后会利用concat函数将两表合并。又df表中，因为提取时序规律的特征中，头和尾存在许多空值，需要将其删除，然后取删除后的时间区段，选取df_features表的对应时间段。最后使用concat函数合并两表。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment">#删除前6行</span><br>df = df.iloc[<span class="hljs-number">6</span>:,:]<br><span class="hljs-comment"># 删除有空值的列</span><br>df_features = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#设置索引</span><br>df_features.index = df.index<br><span class="hljs-comment">#删除空值行，此时查看表可以得到时间段</span><br>df = df.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#合并两表</span><br>df_concat = pd.concat([df,df_features[<span class="hljs-string">'2022-01-26 13:12:00'</span>:<span class="hljs-string">'2022-02-24 03:13:00'</span>]] , axis = <span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment">#删除前6行</span><br>df = df.iloc[<span class="hljs-number">6</span>:,:]<br><span class="hljs-comment"># 删除有空值的列</span><br>df_features = df_features.dropna(axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#设置索引</span><br>df_features.index = df.index<br><span class="hljs-comment">#删除空值行，此时查看表可以得到时间段</span><br>df = df.dropna(axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#合并两表</span><br>df_concat = pd.concat([df,df_features[<span class="hljs-string">'2022-01-26 13:12:00'</span>:<span class="hljs-string">'2022-02-24 03:13:00'</span>]] , axis = <span class="hljs-number">1</span>)<br>df_concat<br></code></pre></td></tr></tbody></table></figure><p>然后需要对特征无量纲化。使用标准化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment"><code class="language-hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br>df_Standar = pd.DataFrame(scaler.fit_transform(df_concat),index=df_concat.index, columns=df_concat.columns)<br>df_Standar<br></code></pre></td></tr></tbody></table></figure><h3 id="2-3-3-特征降维"><a href="#2-3-3-特征降维" class="headerlink" title="2.3.3 特征降维"></a>2.3.3 特征降维</h3><p>使用过滤法，利用方差和相关系数过滤特征。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 filter</span><br><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold  <br>X_train_columns = df_Standar.columns<br><span class="hljs-comment">#方差过滤，返回方差大于设定阈值的列</span><br>selector = VarianceThreshold(<span class="hljs-number">0.5</span>)<br>X = selector.fit_transform(df_Standar)<br><span class="hljs-comment">#因为上式返回结果为series，这里将其转换为表格形式。</span><br><span class="hljs-comment">#X_train_columns[selector.get_support(indices=True)]结果为筛选后的列名</span><br>df_filter = pd.DataFrame(X,index=df_concat.index, columns=X_train_columns[selector.get_support(indices=<span class="hljs-literal">True</span>)])<br>df_filter<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number"><code class="language-hljs python"><span class="hljs-comment"># 特征过滤 相关系数corr</span><br><span class="hljs-comment"># 剔除相关性系数高于threshold的corr_drop</span><br>corr_df = df_filter.corr()<br>threshold = <span class="hljs-number">0.9</span><br><span class="hljs-comment">#k=1,返回上三角矩阵</span><br>upper = corr_df.where(np.triu(np.ones(corr_df.shape), k=<span class="hljs-number">1</span>).astype(np.<span class="hljs-built_in">bool</span>))<br><span class="hljs-comment">#返回相关系数大于阈值的列名</span><br>corr_drop = [column <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> upper.columns <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(upper[column].<span class="hljs-built_in">abs</span>() &gt; threshold)]<br>df_filter = df_filter.drop(corr_drop,axis=<span class="hljs-number">1</span>)<br>df_filter<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时序数据</tag>
      
      <tag>异常处理</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c/c++编译流程</title>
    <link href="/compilation-process.html"/>
    <url>/compilation-process.html</url>
    
    <content type="html"><![CDATA[<p>c/c++程序从源代码到二进制程序的编译一般依靠编译工具GCC(GNU Compiler Collection)实现，具体流程分为4步：</p><ol><li>预处理(Preprocessing)</li><li>编译(Compilation)</li><li>汇编(Assemble)</li><li>链接(Linking)   <span id="more"></span></li></ol><h1 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h1><p>对.c或.h或.cpp文件进行预处理，使用预处理器将头文件内容复制到源代码中、删除注释、对宏进行替换等。处理后的文件后缀为.i，实际为完整的源代码，此时文件大小会大许多。gcc命令为:<br><code>gcc -E test.c -o test.i</code><br>-o是指定输出文件名。  </p><h1 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h1><p>将预处理文件转换为汇编语言的形式即汇编代码，处理后的文件后缀为.s。编译完后文件已经变得很小了。gcc命令为：<br><code>gcc -S test.i -o test.s</code></p><h1 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3.汇编"></a>3.汇编</h1><p>对汇编代码进一步翻译为机器码，形成目标代码，处理后文件后缀为.o。gcc命令为：<br><code>gcc -c test.s -o test.o</code></p><h1 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h1><p>使用链接器将目标代码与其他目标代码、库代码、启动代码等链接起来生成可执行程序，处理后文件后缀为.out(windows下为.exe)。gcc命令为：<br><code>gcc test.o -o test</code><br>gcc工作流程示意图： </p><div align="center"><img src="https://cdn.jsdelivr.net/gh/fight-ing-go/image_repository@master/Compilation_process_img/gcc-compilation-process.33xk22nfohu0.webp" width="60%/"></div><p>注：直接编译为可执行程序的命令为：<code> gcc &lt;文件名&gt; -o &lt;生成的文件名&gt;</code><br>　　gcc命令对于c代码，g++命令对应c++代码。  </p><p>存在误区：</p><ul><li>并不是gcc只能编c，g++只能编c++，两者都可以。后缀为.c的gcc会认作c程序，g++会认作c++；而后缀为.cpp的，两者都会认为是c++程序。g++在编译阶段能调用gcc，而gcc不能自动和c++程序使用的库联结，所以需要g++完成链接，为了统一编译/链接都用了g++。  </li><li>gcc和g++都会定义_cplusplus宏，这个宏只标志编译器将代码按c还是c++语法解释。</li><li>编译能使用gcc/g++，因为在编译阶段g++能自动调用gcc，两者等价；但gcc不能进行库连接，所以链接用g++或gcc -lstdc++。</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习笔记</title>
    <link href="/machine-learning-notes.html"/>
    <url>/machine-learning-notes.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">机器学习三要素：数据、算法、模型简单来说，机器学习就是利用已有的数据通过选择的算法训练模型，用以预测分析。</code></pre><h1 id="1-机器学习算法分类"><a href="#1-机器学习算法分类" class="headerlink" title="1 机器学习算法分类"></a>1 机器学习算法分类</h1><ul><li><strong>监督学习</strong>：输入的数据有标签。<br>对于离散数据，标签用于分类，可以归结为分类问题。<br>对于连续数据标签，归结为回归问题。</li><li><strong>无监督学习</strong>：输入数据无标签。</li></ul> <span id="more"></span><h1 id="2-开发流程"><a href="#2-开发流程" class="headerlink" title="2 开发流程"></a>2 开发流程</h1><ol><li>收集数据。要考虑到后续分析所需要的数据，选取重要特征、足够多的数据等。</li><li>准备数据。实际中，收集到的数据可能存在很多问题，需要进行数据清洗。然后再将其划分为训练集(占比较大)和测试集。</li><li>选择模型。根据实际情况，选择合适的模型。监督学习模型和无监督学习模型。</li><li>训练。使用训练集数据对选择的模型进行训练，需要反复测试。</li><li>评估。对训练出的模型，用测试集进行测试，检验其性能好坏。评估指标主要有：准确率、召回率、F值。</li><li>参数调整。主要是调整参数对模型进行改进。</li><li>预测。将模型应用于实际，对相关问题进行预测。</li></ol><h1 id="3-学习工具"><a href="#3-学习工具" class="headerlink" title="3 学习工具"></a>3 学习工具</h1><ol><li>机器学习库：sklearn。Python的机器学习工具，包含许多机器学习算法的实现。</li><li>数据集：scikit-learn、kaggle、UCI</li><li>开发工具：pycharm、vscode、Jupyter notebook(网页版可视化)</li></ol><h1 id="4-特征工程"><a href="#4-特征工程" class="headerlink" title="4 特征工程"></a>4 特征工程</h1><p>  在使用模型进行训练前，需要对原始数据展开特征工程，目的是为了更高效的利用算法，能影响机器学习的效果。<br>  包含三个步骤：特征提取、特征预处理、特征降维。</p><h2 id="4-1-特征提取"><a href="#4-1-特征提取" class="headerlink" title="4.1 特征提取"></a>4.1 特征提取</h2><pre><code class="hljs">从原本的数据集中提取出适合机器学习的数据。  主要是为了解决三个问题:  </code></pre><ul><li>原始数据特征中的强相关性造成的冗余信息。  </li><li>原始数据十分稀疏.</li><li>原始数据维度较大。<blockquote><p>API: sklearn.feature_extraction</p></blockquote></li></ul><h2 id="4-2-特征预处理"><a href="#4-2-特征预处理" class="headerlink" title="4.2 特征预处理"></a>4.2 特征预处理</h2><p>  对特征无量纲化，目的是让特征处于同等地位。常见方法有：归一化和标准化。</p><h3 id="4-2-1-归一化"><a href="#4-2-1-归一化" class="headerlink" title="4.2.1 归一化"></a>4.2.1 归一化</h3><p>  将原始数据映射到[0，1]之间。公式为：<br>  $x’=\frac {x-min}{max-min}$　　　$x’’=x’*(mx-mi)+mi$<br>  其中，ｘ’’为最终结果，max为一列中的最大值，min为一列中的最小值。mx,mi为指定映射的区间，通常mx=1,mi=0<br>  缺点：当数据存在较多异常点是，会影响归一化结果。该方法鲁棒性差，只适合精确小数据场景。  </p><blockquote><p>API: sklearn.preprocessing.MinMaxScaler(feature_range=(0,1)…)</p></blockquote><h3 id="4-2-2-标准化"><a href="#4-2-2-标准化" class="headerlink" title="4.2.2 标准化"></a>4.2.2 标准化</h3><p>  将数据变换为均值为0，标准差为1的范围内。公式为:<br>  $x’=\frac{x-\overline x}{\sigma}$<br>  作用于每一列，$\overline x$ 为平均值，$\sigma$ 为标准差<br>  平均值和标准差受异常值影响较小，标准化方法能一定程度上克服异常点带来的干扰。适用于样本数量大的情况。</p><blockquote><p>API: sklearn.preprocessing.StandardScaler()  </p></blockquote><h2 id="4-3-特征降维"><a href="#4-3-特征降维" class="headerlink" title="4.3 特征降维"></a>4.3 特征降维</h2><p>  减少相关性较强的特征，得到一组不相关的主变量。常见方法有：特征选择和主成分分析。  </p><h3 id="4-3-1-特征选择"><a href="#4-3-1-特征选择" class="headerlink" title="4.3.1 特征选择"></a>4.3.1 特征选择</h3><p>  在原有的冗余特征中找出主要特征。</p><ul><li>Filter(过滤式): <ul><li>方差选择法：过滤低方差特征<blockquote><p>API: sklearn.feature_selection.VarianceThreshold(threshold = 0.0)  </p></blockquote></li><li>相关系数： 过滤相关程度高的特征,常用有皮尔逊相关系数。对于相关性程度高的特征：<ol><li>选取其中一个</li><li>加权求和</li><li>主成分分析<blockquote><p>API: scipy.stats.pearsonr</p></blockquote></li></ol></li></ul></li><li>Embedded(嵌入式)：<ul><li>决策树</li><li>正则化 <h3 id="4-3-2-主成分分析-PCA"><a href="#4-3-2-主成分分析-PCA" class="headerlink" title="4.3.2 主成分分析(PCA)"></a>4.3.2 主成分分析(PCA)</h3>将n维特征映射到k维上，实现特征降维，减少复杂度。一般用于回归分析或聚类。<blockquote><p>API: sklearn.decomposition.PCA(n_components=None)  </p></blockquote><h1 id="5-模型选择与调优"><a href="#5-模型选择与调优" class="headerlink" title="5. 模型选择与调优"></a>5. 模型选择与调优</h1><p>一般来说，模型调优有3个方向：选择更好的算法，调优模型参数，改进数据。这里简单说下模型参数调优。<br>模型参数调优有两步：交叉验证(cross validation)和超参数搜索-网格搜索(Grid Search)。</p></li></ul></li><li>交叉验证：对于训练集数据，再次将其划分为训练集和验证集，用以评估模型预测准确性，让模型更加准确可信。限制模型过拟合、欠拟合等问题。</li><li>超参数搜索-网格搜索:对于算法中需要自定义的参数，叫超参数。对模型预设几种超参数组合，同时训练，选出最优参数组合。<blockquote><p>API: sklearn.model_selection.GridSearchCV  (同时进行交叉验证和网格搜索)</p></blockquote></li></ul><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><p>机器学习实战流程：</p><ol><li>导入数据</li><li>划分数据集</li><li>特征工程</li><li>模型训练与调优</li><li>模型评估</li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
